{
  "data": {
    "edges": [
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GoogleDriveFolderReader",
            "id": "CustomComponent-hZVAg",
            "name": "documents",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "data_inputs",
            "id": "SplitText-bhJsI",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__CustomComponent-hZVAg{œdataTypeœ:œGoogleDriveFolderReaderœ,œidœ:œCustomComponent-hZVAgœ,œnameœ:œdocumentsœ,œoutput_typesœ:[œDataFrameœ]}-SplitText-bhJsI{œfieldNameœ:œdata_inputsœ,œidœ:œSplitText-bhJsIœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "CustomComponent-hZVAg",
        "sourceHandle": "{œdataTypeœ:œGoogleDriveFolderReaderœ,œidœ:œCustomComponent-hZVAgœ,œnameœ:œdocumentsœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "SplitText-bhJsI",
        "targetHandle": "{œfieldNameœ:œdata_inputsœ,œidœ:œSplitText-bhJsIœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "SplitText",
            "id": "SplitText-bhJsI",
            "name": "dataframe",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "ingest_data",
            "id": "AstraDB-S7pRc",
            "inputTypes": [
              "Data",
              "DataFrame"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__SplitText-bhJsI{œdataTypeœ:œSplitTextœ,œidœ:œSplitText-bhJsIœ,œnameœ:œdataframeœ,œoutput_typesœ:[œDataFrameœ]}-AstraDB-S7pRc{œfieldNameœ:œingest_dataœ,œidœ:œAstraDB-S7pRcœ,œinputTypesœ:[œDataœ,œDataFrameœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "SplitText-bhJsI",
        "sourceHandle": "{œdataTypeœ:œSplitTextœ,œidœ:œSplitText-bhJsIœ,œnameœ:œdataframeœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "AstraDB-S7pRc",
        "targetHandle": "{œfieldNameœ:œingest_dataœ,œidœ:œAstraDB-S7pRcœ,œinputTypesœ:[œDataœ,œDataFrameœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "EmbeddingModel",
            "id": "EmbeddingModel-K3FqD",
            "name": "embeddings",
            "output_types": [
              "Embeddings"
            ]
          },
          "targetHandle": {
            "fieldName": "embedding_model",
            "id": "AstraDB-S7pRc",
            "inputTypes": [
              "Embeddings"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__EmbeddingModel-K3FqD{œdataTypeœ:œEmbeddingModelœ,œidœ:œEmbeddingModel-K3FqDœ,œnameœ:œembeddingsœ,œoutput_typesœ:[œEmbeddingsœ]}-AstraDB-S7pRc{œfieldNameœ:œembedding_modelœ,œidœ:œAstraDB-S7pRcœ,œinputTypesœ:[œEmbeddingsœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "EmbeddingModel-K3FqD",
        "sourceHandle": "{œdataTypeœ:œEmbeddingModelœ,œidœ:œEmbeddingModel-K3FqDœ,œnameœ:œembeddingsœ,œoutput_typesœ:[œEmbeddingsœ]}",
        "target": "AstraDB-S7pRc",
        "targetHandle": "{œfieldNameœ:œembedding_modelœ,œidœ:œAstraDB-S7pRcœ,œinputTypesœ:[œEmbeddingsœ],œtypeœ:œotherœ}"
      }
    ],
    "nodes": [
      {
        "data": {
          "id": "AstraDB-S7pRc",
          "node": {
            "base_classes": [
              "Data",
              "DataFrame",
              "VectorStore"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Ingest and search documents in Astra DB",
            "display_name": "Astra DB",
            "documentation": "https://docs.langflow.org/bundles-datastax",
            "edited": false,
            "field_order": [
              "token",
              "environment",
              "database_name",
              "api_endpoint",
              "keyspace",
              "collection_name",
              "autodetect_collection",
              "ingest_data",
              "search_query",
              "should_cache_vector_store",
              "embedding_model",
              "content_field",
              "deletion_field",
              "ignore_invalid_documents",
              "astradb_vectorstore_kwargs",
              "search_method",
              "reranker",
              "lexical_terms",
              "number_of_results",
              "search_type",
              "search_score_threshold",
              "advanced_search_filter"
            ],
            "frozen": false,
            "icon": "AstraDB",
            "last_updated": "2026-01-15T18:42:47.576Z",
            "legacy": false,
            "metadata": {
              "code_hash": "d52094e54e96",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "astrapy",
                    "version": "2.1.0"
                  },
                  {
                    "name": "langchain_core",
                    "version": "0.3.81"
                  },
                  {
                    "name": "lfx",
                    "version": "0.2.1"
                  },
                  {
                    "name": "langchain_astradb",
                    "version": "0.6.1"
                  }
                ],
                "total_dependencies": 4
              },
              "module": "lfx.components.datastax.astradb_vectorstore.AstraDBVectorStoreComponent"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Search Results",
                "group_outputs": false,
                "loop_types": null,
                "method": "search_documents",
                "name": "search_results",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "DataFrame",
                "group_outputs": false,
                "loop_types": null,
                "method": "as_dataframe",
                "name": "dataframe",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Vector Store Connection",
                "group_outputs": false,
                "hidden": false,
                "loop_types": null,
                "method": "as_vector_store",
                "name": "vectorstoreconnection",
                "options": null,
                "required_inputs": null,
                "selected": "VectorStore",
                "tool_mode": true,
                "types": [
                  "VectorStore"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_frontend_node_flow_id": {
                "value": "bb806354-6312-47bb-ab99-c042fd9a7518"
              },
              "_frontend_node_folder_id": {
                "value": "3f1d0bf7-bd50-4fa9-a5d3-0974cfa99642"
              },
              "_type": "Component",
              "advanced_search_filter": {
                "_input_type": "NestedDictInput",
                "advanced": true,
                "display_name": "Search Metadata Filter",
                "dynamic": false,
                "info": "Optional dictionary of filters to apply to the search query.",
                "list": false,
                "list_add_label": "Add More",
                "name": "advanced_search_filter",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "NestedDict",
                "value": {}
              },
              "api_endpoint": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Astra DB API Endpoint",
                "dynamic": false,
                "external_options": {},
                "info": "The API Endpoint for the Astra DB instance. Supercedes database selection.",
                "name": "api_endpoint",
                "options": [],
                "options_metadata": [],
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "str",
                "value": ""
              },
              "astradb_vectorstore_kwargs": {
                "_input_type": "NestedDictInput",
                "advanced": true,
                "display_name": "AstraDBVectorStore Parameters",
                "dynamic": false,
                "info": "Optional dictionary of additional parameters for the AstraDBVectorStore.",
                "list": false,
                "list_add_label": "Add More",
                "name": "astradb_vectorstore_kwargs",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "NestedDict",
                "value": {}
              },
              "autodetect_collection": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Autodetect Collection",
                "dynamic": false,
                "info": "Boolean flag to determine whether to autodetect the collection.",
                "list": false,
                "list_add_label": "Add More",
                "name": "autodetect_collection",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from astrapy import DataAPIClient\nfrom langchain_core.documents import Document\n\nfrom lfx.base.datastax.astradb_base import AstraDBBaseComponent\nfrom lfx.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\nfrom lfx.base.vectorstores.vector_store_connection_decorator import vector_store_connection\nfrom lfx.helpers.data import docs_to_data\nfrom lfx.io import BoolInput, DropdownInput, FloatInput, HandleInput, IntInput, NestedDictInput, QueryInput, StrInput\nfrom lfx.schema.data import Data\nfrom lfx.serialization import serialize\nfrom lfx.utils.version import get_version_info\n\n\n@vector_store_connection\nclass AstraDBVectorStoreComponent(AstraDBBaseComponent, LCVectorStoreComponent):\n    display_name: str = \"Astra DB\"\n    description: str = \"Ingest and search documents in Astra DB\"\n    documentation: str = \"https://docs.langflow.org/bundles-datastax\"\n    name = \"AstraDB\"\n    icon: str = \"AstraDB\"\n\n    inputs = [\n        *AstraDBBaseComponent.inputs,\n        *LCVectorStoreComponent.inputs,\n        HandleInput(\n            name=\"embedding_model\",\n            display_name=\"Embedding Model\",\n            input_types=[\"Embeddings\"],\n            info=\"Specify the Embedding Model. Not required for Astra Vectorize collections.\",\n            required=False,\n            show=True,\n        ),\n        StrInput(\n            name=\"content_field\",\n            display_name=\"Content Field\",\n            info=\"Field to use as the text content field for the vector store.\",\n            advanced=True,\n        ),\n        StrInput(\n            name=\"deletion_field\",\n            display_name=\"Deletion Based On Field\",\n            info=\"When this parameter is provided, documents in the target collection with \"\n            \"metadata field values matching the input metadata field value will be deleted \"\n            \"before new data is loaded.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"ignore_invalid_documents\",\n            display_name=\"Ignore Invalid Documents\",\n            info=\"Boolean flag to determine whether to ignore invalid documents at runtime.\",\n            advanced=True,\n        ),\n        NestedDictInput(\n            name=\"astradb_vectorstore_kwargs\",\n            display_name=\"AstraDBVectorStore Parameters\",\n            info=\"Optional dictionary of additional parameters for the AstraDBVectorStore.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"search_method\",\n            display_name=\"Search Method\",\n            info=(\n                \"Determine how your content is matched: Vector finds semantic similarity, \"\n                \"and Hybrid Search (suggested) combines both approaches \"\n                \"with a reranker.\"\n            ),\n            options=[\"Hybrid Search\", \"Vector Search\"],  # TODO: Restore Lexical Search?\n            options_metadata=[{\"icon\": \"SearchHybrid\"}, {\"icon\": \"SearchVector\"}],\n            value=\"Vector Search\",\n            advanced=True,\n            real_time_refresh=True,\n        ),\n        DropdownInput(\n            name=\"reranker\",\n            display_name=\"Reranker\",\n            info=\"Post-retrieval model that re-scores results for optimal relevance ranking.\",\n            show=False,\n            toggle=True,\n        ),\n        QueryInput(\n            name=\"lexical_terms\",\n            display_name=\"Lexical Terms\",\n            info=\"Add additional terms/keywords to augment search precision.\",\n            placeholder=\"Enter terms to search...\",\n            separator=\" \",\n            show=False,\n            value=\"\",\n        ),\n        IntInput(\n            name=\"number_of_results\",\n            display_name=\"Number of Search Results\",\n            info=\"Number of search results to return.\",\n            advanced=True,\n            value=4,\n        ),\n        DropdownInput(\n            name=\"search_type\",\n            display_name=\"Search Type\",\n            info=\"Search type to use\",\n            options=[\"Similarity\", \"Similarity with score threshold\", \"MMR (Max Marginal Relevance)\"],\n            value=\"Similarity\",\n            advanced=True,\n        ),\n        FloatInput(\n            name=\"search_score_threshold\",\n            display_name=\"Search Score Threshold\",\n            info=\"Minimum similarity score threshold for search results. \"\n            \"(when using 'Similarity with score threshold')\",\n            value=0,\n            advanced=True,\n        ),\n        NestedDictInput(\n            name=\"advanced_search_filter\",\n            display_name=\"Search Metadata Filter\",\n            info=\"Optional dictionary of filters to apply to the search query.\",\n            advanced=True,\n        ),\n    ]\n\n    async def update_build_config(\n        self,\n        build_config: dict,\n        field_value: str | dict,\n        field_name: str | None = None,\n    ) -> dict:\n        \"\"\"Update build configuration with proper handling of embedding and search options.\"\"\"\n        # Handle base astra db build config updates\n        build_config = await super().update_build_config(\n            build_config,\n            field_value=field_value,\n            field_name=field_name,\n        )\n\n        # Set embedding model display based on provider selection\n        if isinstance(field_value, dict) and \"02_embedding_generation_provider\" in field_value:\n            embedding_provider = field_value.get(\"02_embedding_generation_provider\")\n            is_custom_provider = embedding_provider and embedding_provider != \"Bring your own\"\n            provider = embedding_provider.lower() if is_custom_provider and embedding_provider is not None else None\n\n            build_config[\"embedding_model\"][\"show\"] = not bool(provider)\n            build_config[\"embedding_model\"][\"required\"] = not bool(provider)\n\n        # Early return if no API endpoint is configured\n        if not self.get_api_endpoint():\n            return build_config\n\n        # Configure search method and related options\n        return self._configure_search_options(build_config)\n\n    def _configure_search_options(self, build_config: dict) -> dict:\n        \"\"\"Configure hybrid search, reranker, and vector search options.\"\"\"\n        # Detect available hybrid search capabilities\n        hybrid_capabilities = self._detect_hybrid_capabilities()\n\n        # Return if we haven't selected a collection\n        if not build_config[\"collection_name\"][\"options\"] or not build_config[\"collection_name\"][\"value\"]:\n            return build_config\n\n        # Get collection options\n        collection_options = self._get_collection_options(build_config)\n\n        # Get the selected collection index\n        index = build_config[\"collection_name\"][\"options\"].index(build_config[\"collection_name\"][\"value\"])\n        provider = build_config[\"collection_name\"][\"options_metadata\"][index][\"provider\"]\n        build_config[\"embedding_model\"][\"show\"] = not bool(provider)\n        build_config[\"embedding_model\"][\"required\"] = not bool(provider)\n\n        # Determine search configuration\n        is_vector_search = build_config[\"search_method\"][\"value\"] == \"Vector Search\"\n        is_autodetect = build_config[\"autodetect_collection\"][\"value\"]\n\n        # Apply hybrid search configuration\n        if hybrid_capabilities[\"available\"]:\n            build_config[\"search_method\"][\"show\"] = True\n            build_config[\"search_method\"][\"options\"] = [\"Hybrid Search\", \"Vector Search\"]\n            build_config[\"search_method\"][\"value\"] = build_config[\"search_method\"].get(\"value\", \"Hybrid Search\")\n\n            build_config[\"reranker\"][\"options\"] = hybrid_capabilities[\"reranker_models\"]\n            build_config[\"reranker\"][\"options_metadata\"] = hybrid_capabilities[\"reranker_metadata\"]\n            if hybrid_capabilities[\"reranker_models\"]:\n                build_config[\"reranker\"][\"value\"] = hybrid_capabilities[\"reranker_models\"][0]\n        else:\n            build_config[\"search_method\"][\"show\"] = False\n            build_config[\"search_method\"][\"options\"] = [\"Vector Search\"]\n            build_config[\"search_method\"][\"value\"] = \"Vector Search\"\n            build_config[\"reranker\"][\"options\"] = []\n            build_config[\"reranker\"][\"options_metadata\"] = []\n\n        # Configure reranker visibility and state\n        hybrid_enabled = (\n            collection_options[\"rerank_enabled\"] and build_config[\"search_method\"][\"value\"] == \"Hybrid Search\"\n        )\n\n        build_config[\"reranker\"][\"show\"] = hybrid_enabled\n        build_config[\"reranker\"][\"toggle_value\"] = hybrid_enabled\n        build_config[\"reranker\"][\"toggle_disable\"] = is_vector_search\n\n        # Configure lexical terms\n        lexical_visible = collection_options[\"lexical_enabled\"] and not is_vector_search\n        build_config[\"lexical_terms\"][\"show\"] = lexical_visible\n        build_config[\"lexical_terms\"][\"value\"] = \"\" if is_vector_search else build_config[\"lexical_terms\"][\"value\"]\n\n        # Configure search type and score threshold\n        build_config[\"search_type\"][\"show\"] = is_vector_search\n        build_config[\"search_score_threshold\"][\"show\"] = is_vector_search\n\n        # Force similarity search for hybrid mode or autodetect\n        if hybrid_enabled or is_autodetect:\n            build_config[\"search_type\"][\"value\"] = \"Similarity\"\n\n        return build_config\n\n    def _detect_hybrid_capabilities(self) -> dict:\n        \"\"\"Detect available hybrid search and reranking capabilities.\"\"\"\n        environment = self.get_environment(self.environment)\n        client = DataAPIClient(environment=environment)\n        admin_client = client.get_admin()\n        db_admin = admin_client.get_database_admin(self.get_api_endpoint(), token=self.token)\n\n        try:\n            providers = db_admin.find_reranking_providers()\n            reranker_models = [\n                model.name for provider_data in providers.reranking_providers.values() for model in provider_data.models\n            ]\n            reranker_metadata = [\n                {\"icon\": self.get_provider_icon(provider_name=model.name.split(\"/\")[0])}\n                for provider in providers.reranking_providers.values()\n                for model in provider.models\n            ]\n        except Exception as e:  # noqa: BLE001\n            self.log(f\"Hybrid search not available: {e}\")\n            return {\n                \"available\": False,\n                \"reranker_models\": [],\n                \"reranker_metadata\": [],\n            }\n        else:\n            return {\n                \"available\": True,\n                \"reranker_models\": reranker_models,\n                \"reranker_metadata\": reranker_metadata,\n            }\n\n    def _get_collection_options(self, build_config: dict) -> dict:\n        \"\"\"Retrieve collection-level search options.\"\"\"\n        database = self.get_database_object(api_endpoint=build_config[\"api_endpoint\"][\"value\"])\n        collection = database.get_collection(\n            name=build_config[\"collection_name\"][\"value\"],\n            keyspace=build_config[\"keyspace\"][\"value\"],\n        )\n\n        col_options = collection.options()\n\n        return {\n            \"rerank_enabled\": bool(col_options.rerank and col_options.rerank.enabled),\n            \"lexical_enabled\": bool(col_options.lexical and col_options.lexical.enabled),\n        }\n\n    @check_cached_vector_store\n    def build_vector_store(self):\n        try:\n            from langchain_astradb import AstraDBVectorStore\n            from langchain_astradb.utils.astradb import HybridSearchMode\n        except ImportError as e:\n            msg = (\n                \"Could not import langchain Astra DB integration package. \"\n                \"Please install it with `pip install langchain-astradb`.\"\n            )\n            raise ImportError(msg) from e\n\n        # Get the embedding model and additional params\n        embedding_params = {\"embedding\": self.embedding_model} if self.embedding_model else {}\n\n        # Get the additional parameters\n        additional_params = self.astradb_vectorstore_kwargs or {}\n\n        # Get Langflow version and platform information\n        __version__ = get_version_info()[\"version\"]\n        langflow_prefix = \"\"\n        # if os.getenv(\"AWS_EXECUTION_ENV\") == \"AWS_ECS_FARGATE\":  # TODO: More precise way of detecting\n        #     langflow_prefix = \"ds-\"\n\n        # Get the database object\n        database = self.get_database_object()\n        autodetect = self.collection_name in database.list_collection_names() and self.autodetect_collection\n\n        # Bundle up the auto-detect parameters\n        autodetect_params = {\n            \"autodetect_collection\": autodetect,\n            \"content_field\": (\n                self.content_field\n                if self.content_field and embedding_params\n                else (\n                    \"page_content\"\n                    if embedding_params\n                    and self.collection_data(collection_name=self.collection_name, database=database) == 0\n                    else None\n                )\n            ),\n            \"ignore_invalid_documents\": self.ignore_invalid_documents,\n        }\n\n        # Choose HybridSearchMode based on the selected param\n        hybrid_search_mode = HybridSearchMode.DEFAULT if self.search_method == \"Hybrid Search\" else HybridSearchMode.OFF\n\n        # Attempt to build the Vector Store object\n        try:\n            vector_store = AstraDBVectorStore(\n                # Astra DB Authentication Parameters\n                token=self.token,\n                api_endpoint=database.api_endpoint,\n                namespace=database.keyspace,\n                collection_name=self.collection_name,\n                environment=self.environment,\n                # Hybrid Search Parameters\n                hybrid_search=hybrid_search_mode,\n                # Astra DB Usage Tracking Parameters\n                ext_callers=[(f\"{langflow_prefix}langflow\", __version__)],\n                # Astra DB Vector Store Parameters\n                **autodetect_params,\n                **embedding_params,\n                **additional_params,\n            )\n        except ValueError as e:\n            msg = f\"Error initializing AstraDBVectorStore: {e}\"\n            raise ValueError(msg) from e\n\n        # Add documents to the vector store\n        self._add_documents_to_vector_store(vector_store)\n\n        return vector_store\n\n    def _add_documents_to_vector_store(self, vector_store) -> None:\n        self.ingest_data = self._prepare_ingest_data()\n\n        documents = []\n        for _input in self.ingest_data or []:\n            if isinstance(_input, Data):\n                documents.append(_input.to_lc_document())\n            else:\n                msg = \"Vector Store Inputs must be Data objects.\"\n                raise TypeError(msg)\n\n        documents = [\n            Document(page_content=doc.page_content, metadata=serialize(doc.metadata, to_str=True)) for doc in documents\n        ]\n\n        if documents and self.deletion_field:\n            self.log(f\"Deleting documents where {self.deletion_field}\")\n            try:\n                database = self.get_database_object()\n                collection = database.get_collection(self.collection_name, keyspace=database.keyspace)\n                delete_values = list({doc.metadata[self.deletion_field] for doc in documents})\n                self.log(f\"Deleting documents where {self.deletion_field} matches {delete_values}.\")\n                collection.delete_many({f\"metadata.{self.deletion_field}\": {\"$in\": delete_values}})\n            except ValueError as e:\n                msg = f\"Error deleting documents from AstraDBVectorStore based on '{self.deletion_field}': {e}\"\n                raise ValueError(msg) from e\n\n        if documents:\n            self.log(f\"Adding {len(documents)} documents to the Vector Store.\")\n            try:\n                vector_store.add_documents(documents)\n            except ValueError as e:\n                msg = f\"Error adding documents to AstraDBVectorStore: {e}\"\n                raise ValueError(msg) from e\n        else:\n            self.log(\"No documents to add to the Vector Store.\")\n\n    def _map_search_type(self) -> str:\n        search_type_mapping = {\n            \"Similarity with score threshold\": \"similarity_score_threshold\",\n            \"MMR (Max Marginal Relevance)\": \"mmr\",\n        }\n\n        return search_type_mapping.get(self.search_type, \"similarity\")\n\n    def _build_search_args(self):\n        # Clean up the search query\n        query = self.search_query if isinstance(self.search_query, str) and self.search_query.strip() else None\n        lexical_terms = self.lexical_terms or None\n\n        # Check if we have a search query, and if so set the args\n        if query:\n            args = {\n                \"query\": query,\n                \"search_type\": self._map_search_type(),\n                \"k\": self.number_of_results,\n                \"score_threshold\": self.search_score_threshold,\n                \"lexical_query\": lexical_terms,\n            }\n        elif self.advanced_search_filter:\n            args = {\n                \"n\": self.number_of_results,\n            }\n        else:\n            return {}\n\n        filter_arg = self.advanced_search_filter or {}\n        if filter_arg:\n            args[\"filter\"] = filter_arg\n\n        return args\n\n    def search_documents(self, vector_store=None) -> list[Data]:\n        vector_store = vector_store or self.build_vector_store()\n\n        self.log(f\"Search input: {self.search_query}\")\n        self.log(f\"Search type: {self.search_type}\")\n        self.log(f\"Number of results: {self.number_of_results}\")\n        self.log(f\"store.hybrid_search: {vector_store.hybrid_search}\")\n        self.log(f\"Lexical terms: {self.lexical_terms}\")\n        self.log(f\"Reranker: {self.reranker}\")\n\n        try:\n            search_args = self._build_search_args()\n        except ValueError as e:\n            msg = f\"Error in AstraDBVectorStore._build_search_args: {e}\"\n            raise ValueError(msg) from e\n\n        if not search_args:\n            self.log(\"No search input or filters provided. Skipping search.\")\n            return []\n\n        docs = []\n        search_method = \"search\" if \"query\" in search_args else \"metadata_search\"\n\n        try:\n            self.log(f\"Calling vector_store.{search_method} with args: {search_args}\")\n            docs = getattr(vector_store, search_method)(**search_args)\n        except ValueError as e:\n            msg = f\"Error performing {search_method} in AstraDBVectorStore: {e}\"\n            raise ValueError(msg) from e\n\n        self.log(f\"Retrieved documents: {len(docs)}\")\n\n        data = docs_to_data(docs)\n        self.log(f\"Converted documents to data: {len(data)}\")\n        self.status = data\n\n        return data\n\n    def get_retriever_kwargs(self):\n        search_args = self._build_search_args()\n\n        return {\n            \"search_type\": self._map_search_type(),\n            \"search_kwargs\": search_args,\n        }\n"
              },
              "collection_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {
                  "fields": {
                    "data": {
                      "node": {
                        "description": "Please allow several seconds for creation to complete.",
                        "display_name": "Create new collection",
                        "field_order": [
                          "01_new_collection_name",
                          "02_embedding_generation_provider",
                          "03_embedding_generation_model",
                          "04_dimension"
                        ],
                        "name": "create_collection",
                        "template": {
                          "01_new_collection_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Name",
                            "dynamic": false,
                            "info": "Name of the new collection to create in Astra DB.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_collection_name",
                            "override_skip": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "track_in_telemetry": false,
                            "type": "str",
                            "value": ""
                          },
                          "02_embedding_generation_provider": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Embedding generation method",
                            "dynamic": false,
                            "external_options": {},
                            "helper_text": "To create collections with more embedding provider options, go to <a class=\"underline\" href=\"https://astra.datastax.com/\" target=\" _blank\" rel=\"noopener noreferrer\">your database in Astra DB</a>",
                            "info": "Provider to use for generating embeddings.",
                            "name": "embedding_generation_provider",
                            "options": [],
                            "options_metadata": [],
                            "override_skip": false,
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "track_in_telemetry": true,
                            "type": "str",
                            "value": ""
                          },
                          "03_embedding_generation_model": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Embedding model",
                            "dynamic": false,
                            "external_options": {},
                            "info": "Model to use for generating embeddings.",
                            "name": "embedding_generation_model",
                            "options": [],
                            "options_metadata": [],
                            "override_skip": false,
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "track_in_telemetry": true,
                            "type": "str",
                            "value": ""
                          },
                          "04_dimension": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Dimensions",
                            "dynamic": false,
                            "info": "Dimensions of the embeddings to generate.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "dimension",
                            "override_skip": false,
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "track_in_telemetry": true,
                            "type": "int"
                          }
                        }
                      }
                    }
                  },
                  "functionality": "create"
                },
                "display_name": "Collection",
                "dynamic": false,
                "external_options": {},
                "info": "The name of the collection within Astra DB where the vectors will be stored.",
                "name": "collection_name",
                "options": [],
                "options_metadata": [],
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "refresh_button": true,
                "required": true,
                "show": false,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "str",
                "value": ""
              },
              "content_field": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Content Field",
                "dynamic": false,
                "info": "Field to use as the text content field for the vector store.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "content_field",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "database_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {
                  "fields": {
                    "data": {
                      "node": {
                        "description": "Please allow several minutes for creation to complete.",
                        "display_name": "Create new database",
                        "field_order": [
                          "01_new_database_name",
                          "02_cloud_provider",
                          "03_region"
                        ],
                        "name": "create_database",
                        "template": {
                          "01_new_database_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Name",
                            "dynamic": false,
                            "info": "Name of the new database to create in Astra DB.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_database_name",
                            "override_skip": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "track_in_telemetry": false,
                            "type": "str",
                            "value": ""
                          },
                          "02_cloud_provider": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Cloud provider",
                            "dynamic": false,
                            "external_options": {},
                            "info": "Cloud provider for the new database.",
                            "name": "cloud_provider",
                            "options": [
                              "Google Cloud Platform",
                              "Amazon Web Services"
                            ],
                            "options_metadata": [],
                            "override_skip": false,
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "track_in_telemetry": true,
                            "type": "str",
                            "value": ""
                          },
                          "03_region": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Region",
                            "dynamic": false,
                            "external_options": {},
                            "info": "Region for the new database.",
                            "name": "region",
                            "options": [],
                            "options_metadata": [],
                            "override_skip": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "track_in_telemetry": true,
                            "type": "str",
                            "value": ""
                          }
                        }
                      }
                    }
                  },
                  "functionality": "create"
                },
                "display_name": "Database",
                "dynamic": false,
                "external_options": {},
                "info": "The Database name for the Astra DB instance.",
                "name": "database_name",
                "options": [
                  "support_agent",
                  "agent_memory",
                  "loop",
                  "test",
                  "new"
                ],
                "options_metadata": [
                  {
                    "api_endpoints": [
                      "https://355c70a0-377f-4d42-8845-c76dd00c548d-us-east1.apps.astra.datastax.com"
                    ],
                    "collections": 5,
                    "keyspaces": [
                      "default_keyspace"
                    ],
                    "org_id": "ff115c2b-6489-4c7d-b2d9-9e1c91a47193",
                    "status": null
                  },
                  {
                    "api_endpoints": [
                      "https://9a03db8d-521d-4165-8bc7-b098c0593ae7-us-east1.apps.astra.datastax.com"
                    ],
                    "collections": 9,
                    "keyspaces": [
                      "default_keyspace"
                    ],
                    "org_id": "ff115c2b-6489-4c7d-b2d9-9e1c91a47193",
                    "status": null
                  },
                  {
                    "api_endpoints": [
                      "https://dcfe950b-67f5-4ad7-b1a2-747722fbc65c-us-east1.apps.astra.datastax.com"
                    ],
                    "collections": 2,
                    "keyspaces": [
                      "default_keyspace"
                    ],
                    "org_id": "ff115c2b-6489-4c7d-b2d9-9e1c91a47193",
                    "status": null
                  },
                  {
                    "api_endpoints": [
                      "https://6d492ea7-bd2a-4f77-b0ee-b58b94109dc3-us-east1.apps.astra.datastax.com"
                    ],
                    "collections": 3,
                    "keyspaces": [
                      "default_keyspace"
                    ],
                    "org_id": "ff115c2b-6489-4c7d-b2d9-9e1c91a47193",
                    "status": null
                  },
                  {
                    "api_endpoints": [
                      "https://205bcd51-fe2c-4783-9f09-97531e7d1a27-us-east1.apps.astra.datastax.com"
                    ],
                    "collections": 0,
                    "keyspaces": [
                      "default_keyspace"
                    ],
                    "org_id": "ff115c2b-6489-4c7d-b2d9-9e1c91a47193",
                    "status": null
                  }
                ],
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "refresh_button": true,
                "required": true,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "str",
                "value": ""
              },
              "deletion_field": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Deletion Based On Field",
                "dynamic": false,
                "info": "When this parameter is provided, documents in the target collection with metadata field values matching the input metadata field value will be deleted before new data is loaded.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "deletion_field",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "embedding_model": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Embedding Model",
                "dynamic": false,
                "info": "Specify the Embedding Model. Not required for Astra Vectorize collections.",
                "input_types": [
                  "Embeddings"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "embedding_model",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "other",
                "value": ""
              },
              "environment": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Environment",
                "dynamic": false,
                "external_options": {},
                "info": "The environment for the Astra DB API Endpoint.",
                "name": "environment",
                "options": [
                  "prod",
                  "test",
                  "dev"
                ],
                "options_metadata": [],
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "str",
                "value": "prod"
              },
              "ignore_invalid_documents": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Ignore Invalid Documents",
                "dynamic": false,
                "info": "Boolean flag to determine whether to ignore invalid documents at runtime.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ignore_invalid_documents",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": false
              },
              "ingest_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Ingest Data",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Data",
                  "DataFrame"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "ingest_data",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "other",
                "value": ""
              },
              "is_refresh": false,
              "keyspace": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Keyspace",
                "dynamic": false,
                "external_options": {},
                "info": "Optional keyspace within Astra DB to use for the collection.",
                "name": "keyspace",
                "options": [],
                "options_metadata": [],
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "str",
                "value": ""
              },
              "lexical_terms": {
                "_input_type": "QueryInput",
                "advanced": false,
                "display_name": "Lexical Terms",
                "dynamic": false,
                "info": "Add additional terms/keywords to augment search precision.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "lexical_terms",
                "override_skip": false,
                "placeholder": "Enter terms to search...",
                "required": false,
                "separator": " ",
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "query",
                "value": ""
              },
              "number_of_results": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Search Results",
                "dynamic": false,
                "info": "Number of search results to return.",
                "list": false,
                "list_add_label": "Add More",
                "name": "number_of_results",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "int",
                "value": 4
              },
              "reranker": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Reranker",
                "dynamic": false,
                "external_options": {},
                "info": "Post-retrieval model that re-scores results for optimal relevance ranking.",
                "name": "reranker",
                "options": [],
                "options_metadata": [],
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "toggle": true,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "str",
                "value": ""
              },
              "search_method": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Search Method",
                "dynamic": false,
                "external_options": {},
                "info": "Determine how your content is matched: Vector finds semantic similarity, and Hybrid Search (suggested) combines both approaches with a reranker.",
                "name": "search_method",
                "options": [
                  "Hybrid Search",
                  "Vector Search"
                ],
                "options_metadata": [
                  {
                    "icon": "SearchHybrid"
                  },
                  {
                    "icon": "SearchVector"
                  }
                ],
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "str",
                "value": "Vector Search"
              },
              "search_query": {
                "_input_type": "QueryInput",
                "advanced": false,
                "display_name": "Search Query",
                "dynamic": false,
                "info": "Enter a query to run a similarity search.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "search_query",
                "override_skip": false,
                "placeholder": "Enter a query...",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "query",
                "value": ""
              },
              "search_score_threshold": {
                "_input_type": "FloatInput",
                "advanced": true,
                "display_name": "Search Score Threshold",
                "dynamic": false,
                "info": "Minimum similarity score threshold for search results. (when using 'Similarity with score threshold')",
                "list": false,
                "list_add_label": "Add More",
                "name": "search_score_threshold",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "float",
                "value": 0
              },
              "search_type": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Search Type",
                "dynamic": false,
                "external_options": {},
                "info": "Search type to use",
                "name": "search_type",
                "options": [
                  "Similarity",
                  "Similarity with score threshold",
                  "MMR (Max Marginal Relevance)"
                ],
                "options_metadata": [],
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "str",
                "value": "Similarity"
              },
              "should_cache_vector_store": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Cache Vector Store",
                "dynamic": false,
                "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_cache_vector_store",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": true
              },
              "token": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Astra DB Application Token",
                "dynamic": false,
                "info": "Authentication token for accessing Astra DB.",
                "input_types": [],
                "load_from_db": true,
                "name": "token",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "selected_output": "search_results",
          "showNode": true,
          "type": "AstraDB"
        },
        "dragging": false,
        "id": "AstraDB-S7pRc",
        "measured": {
          "height": 455,
          "width": 320
        },
        "position": {
          "x": 816.0018685162152,
          "y": 547.079352261862
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "CustomComponent-hZVAg",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Reads all documents from a Google Drive folder.",
            "display_name": "Google Drive Folder Reader",
            "documentation": "",
            "edited": true,
            "field_order": [
              "auth_type",
              "service_account_key",
              "service_account_json",
              "folder_id",
              "export_mime_type",
              "include_non_google_docs"
            ],
            "frozen": true,
            "icon": "Google",
            "legacy": false,
            "lf_version": "1.7.1",
            "metadata": {
              "code_hash": "8dcc1fd7af03",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "lfx",
                    "version": "0.2.1"
                  },
                  {
                    "name": "googleapiclient",
                    "version": "2.154.0"
                  },
                  {
                    "name": "google",
                    "version": "1.56.0"
                  }
                ],
                "total_dependencies": 3
              },
              "module": "custom_components.google_drive_folder_reader"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Documents",
                "group_outputs": false,
                "hidden": null,
                "loop_types": null,
                "method": "read_folder",
                "name": "documents",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "auth_type": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Authentication Type",
                "dynamic": false,
                "info": "Select the authentication method for Google Cloud Platform credentials. 'secret' for Secret String, 'file' for JSON File.",
                "name": "auth_type",
                "options": [
                  "secret",
                  "file"
                ],
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "tab",
                "value": "secret"
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from lfx.custom import Component\r\nfrom lfx.io import DropdownInput, FileInput, MessageInput, Output, SecretStrInput, TabInput\r\nfrom lfx.schema.data import Data\r\nfrom lfx.schema.dataframe import DataFrame\r\nfrom googleapiclient.discovery import build\r\nfrom google.oauth2 import service_account\r\nfrom googleapiclient.http import MediaIoBaseDownload\r\nimport io\r\nimport json\r\n\r\n\r\nclass GoogleDriveFolderReader(Component):\r\n    display_name = \"Google Drive Folder Reader\"\r\n    description = \"Reads all documents from a Google Drive folder.\"\r\n    icon = \"Google\"\r\n    name = \"GoogleDriveFolderReader\"\r\n\r\n    inputs = [\r\n        TabInput(\r\n            name=\"auth_type\",\r\n            display_name=\"Authentication Type\",\r\n            options=[\"secret\", \"file\"],\r\n            value=\"secret\",\r\n            info=\"Select the authentication method for Google Cloud Platform credentials. 'secret' for Secret String, 'file' for JSON File.\",\r\n            real_time_refresh=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"service_account_key\",\r\n            display_name=\"GCP Credentials Secret Key\",\r\n            info=\"Your Google Cloud Platform service account JSON key as a secret string (complete JSON content).\",\r\n            required=True,\r\n            advanced=True,\r\n            show=True,\r\n        ),\r\n        FileInput(\r\n            name=\"service_account_json\",\r\n            display_name=\"GCP Credentials JSON File\",\r\n            file_types=[\"json\"],\r\n            info=\"Upload your Google Cloud Platform service account JSON key.\",\r\n            required=True,\r\n            advanced=True,\r\n            show=False,\r\n        ),\r\n        MessageInput(\r\n            name=\"folder_id\",\r\n            display_name=\"Folder ID\",\r\n            info=\"Google Drive folder ID to read documents from.\",\r\n            required=True,\r\n            tool_mode=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"export_mime_type\",\r\n            display_name=\"Export As\",\r\n            info=\"Export Google Docs/Slides/Sheets to a specific format.\",\r\n            options=[\"text/plain\", \"application/pdf\"],\r\n            value=\"text/plain\",\r\n        ),\r\n        DropdownInput(\r\n            name=\"include_non_google_docs\",\r\n            display_name=\"Include Non-Google Docs\",\r\n            info=\"When true, download non-Google files too.\",\r\n            options=[\"false\", \"true\"],\r\n            value=\"false\",\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(name=\"documents\", display_name=\"Documents\", method=\"read_folder\"),\r\n    ]\r\n\r\n    def update_build_config(self, build_config, field_value, field_name=None):\r\n        \"\"\"Update build configuration to show/hide fields based on authentication type selection.\"\"\"\r\n        if field_name != \"auth_type\":\r\n            return build_config\r\n\r\n        auth_type = str(field_value) if field_value else \"secret\"\r\n        if auth_type not in [\"secret\", \"file\"]:\r\n            auth_type = \"secret\"\r\n\r\n        if \"service_account_key\" in build_config:\r\n            build_config[\"service_account_key\"][\"show\"] = False\r\n        if \"service_account_json\" in build_config:\r\n            build_config[\"service_account_json\"][\"show\"] = False\r\n\r\n        if auth_type == \"secret\":\r\n            if \"service_account_key\" in build_config:\r\n                build_config[\"service_account_key\"][\"show\"] = True\r\n        elif auth_type == \"file\":\r\n            if \"service_account_json\" in build_config:\r\n                build_config[\"service_account_json\"][\"show\"] = True\r\n\r\n        return build_config\r\n\r\n    def _extract_message_text(self, value):\r\n        if hasattr(value, \"content\"):\r\n            return value.content\r\n        if hasattr(value, \"text\"):\r\n            return value.text\r\n        if hasattr(value, \"message\"):\r\n            return value.message\r\n        return str(value)\r\n\r\n    def _load_credentials(self):\r\n        auth_type = getattr(self, \"auth_type\", \"secret\")\r\n        auth_type = str(auth_type) if auth_type else \"secret\"\r\n        if auth_type not in [\"secret\", \"file\"]:\r\n            auth_type = \"secret\"\r\n\r\n        if auth_type == \"file\":\r\n            if not hasattr(self, \"service_account_json\") or not self.service_account_json:\r\n                raise ValueError(\"Service account JSON file is required when using file authentication.\")\r\n            try:\r\n                with open(self.service_account_json, \"r\", encoding=\"utf-8\") as f:\r\n                    credentials_dict = json.load(f)\r\n            except FileNotFoundError:\r\n                raise ValueError(f\"Service account JSON file not found: {self.service_account_json}\")\r\n            except json.JSONDecodeError as e:\r\n                raise ValueError(f\"Invalid JSON in service account file: {str(e)}\")\r\n        else:\r\n            if not hasattr(self, \"service_account_key\") or not self.service_account_key:\r\n                raise ValueError(\"Service account key is required when using secret string authentication.\")\r\n            try:\r\n                credentials_dict = json.loads(self.service_account_key)\r\n            except json.JSONDecodeError as e:\r\n                raise ValueError(f\"Invalid JSON in service account key: {str(e)}\")\r\n\r\n        return service_account.Credentials.from_service_account_info(\r\n            credentials_dict,\r\n            scopes=[\"https://www.googleapis.com/auth/drive.readonly\"],\r\n        )\r\n\r\n    def _execute_download(self, request):\r\n        fh = io.BytesIO()\r\n        downloader = MediaIoBaseDownload(fh, request)\r\n        done = False\r\n        while not done:\r\n            _, done = downloader.next_chunk()\r\n        return fh.getvalue()\r\n\r\n    def _fetch_file_content(self, service, file_id, mime_type, export_mime_type):\r\n        if mime_type.startswith(\"application/vnd.google-apps\"):\r\n            request = service.files().export_media(fileId=file_id, mimeType=export_mime_type)\r\n            output_mime_type = export_mime_type\r\n        else:\r\n            request = service.files().get_media(fileId=file_id)\r\n            output_mime_type = mime_type\r\n\r\n        file_bytes = self._execute_download(request)\r\n        try:\r\n            text_content = file_bytes.decode(\"utf-8\")\r\n        except Exception:\r\n            text_content = None\r\n        return file_bytes, text_content, output_mime_type\r\n\r\n    def read_folder(self) -> DataFrame:\r\n        try:\r\n            credentials = self._load_credentials()\r\n            drive_service = build(\"drive\", \"v3\", credentials=credentials)\r\n\r\n            folder_id = self._extract_message_text(self.folder_id).strip()\r\n            if not folder_id:\r\n                raise ValueError(\"Folder ID cannot be empty.\")\r\n\r\n            include_non_google_docs = str(getattr(self, \"include_non_google_docs\", \"false\")).lower() == \"true\"\r\n            export_mime_type = getattr(self, \"export_mime_type\", \"text/plain\") or \"text/plain\"\r\n\r\n            query = f\"'{folder_id}' in parents and trashed = false\"\r\n            page_token = None\r\n            files = []\r\n\r\n            while True:\r\n                response = (\r\n                    drive_service.files()\r\n                    .list(\r\n                        q=query,\r\n                        fields=\"nextPageToken, files(id,name,mimeType,modifiedTime,size)\",\r\n                        pageToken=page_token,\r\n                    )\r\n                    .execute()\r\n                )\r\n                files.extend(response.get(\"files\", []))\r\n                page_token = response.get(\"nextPageToken\")\r\n                if not page_token:\r\n                    break\r\n\r\n            documents = []\r\n            for item in files:\r\n                mime_type = item.get(\"mimeType\", \"\")\r\n                if not include_non_google_docs and not mime_type.startswith(\"application/vnd.google-apps\"):\r\n                    continue\r\n\r\n                file_bytes, text_content, output_mime_type = self._fetch_file_content(\r\n                    drive_service,\r\n                    item.get(\"id\"),\r\n                    mime_type,\r\n                    export_mime_type,\r\n                )\r\n                documents.append(\r\n                    {\r\n                        \"folder_id\": folder_id,\r\n                        \"document_count\": 0,  # filled after list complete\r\n                        \"file_id\": item.get(\"id\"),\r\n                        \"file_name\": item.get(\"name\"),\r\n                        \"mime_type\": output_mime_type,\r\n                        \"modified_time\": item.get(\"modifiedTime\"),\r\n                        \"size\": item.get(\"size\"),\r\n                        \"text\": text_content,\r\n                        \"bytes\": file_bytes,\r\n                    }\r\n                )\r\n\r\n            total_documents = len(documents)\r\n            for doc in documents:\r\n                doc[\"document_count\"] = total_documents\r\n\r\n            data_rows = [Data(data=doc) for doc in documents]\r\n            return DataFrame(data_rows)\r\n        except Exception as e:\r\n            self.log(f\"Error reading folder: {e}\")\r\n            return DataFrame([Data(data={\"error\": str(e)})])\r\n"
              },
              "export_mime_type": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Export As",
                "dynamic": false,
                "external_options": {},
                "info": "Export Google Docs/Slides/Sheets to a specific format.",
                "name": "export_mime_type",
                "options": [
                  "text/plain",
                  "application/pdf"
                ],
                "options_metadata": [],
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "str",
                "value": "text/plain"
              },
              "folder_id": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Folder ID",
                "dynamic": false,
                "info": "Google Drive folder ID to read documents from.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "folder_id",
                "override_skip": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "1FCkhUiNYiaBJrc979ovLWLnPaaCP-tAB"
              },
              "include_non_google_docs": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Include Non-Google Docs",
                "dynamic": false,
                "external_options": {},
                "info": "When true, download non-Google files too.",
                "load_from_db": false,
                "name": "include_non_google_docs",
                "options": [
                  "false",
                  "true"
                ],
                "options_metadata": [],
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "str",
                "value": "true"
              },
              "service_account_json": {
                "_input_type": "FileInput",
                "advanced": true,
                "display_name": "GCP Credentials JSON File",
                "dynamic": false,
                "fileTypes": [
                  "json"
                ],
                "file_path": "",
                "info": "Upload your Google Cloud Platform service account JSON key.",
                "list": false,
                "list_add_label": "Add More",
                "name": "service_account_json",
                "override_skip": false,
                "placeholder": "",
                "required": true,
                "show": false,
                "temp_file": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "file",
                "value": ""
              },
              "service_account_key": {
                "_input_type": "SecretStrInput",
                "advanced": true,
                "display_name": "GCP Credentials Secret Key",
                "dynamic": false,
                "info": "Your Google Cloud Platform service account JSON key as a secret string (complete JSON content).",
                "input_types": [],
                "load_from_db": true,
                "name": "service_account_key",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "GoogleDriveFolderReader"
        },
        "dragging": false,
        "id": "CustomComponent-hZVAg",
        "measured": {
          "height": 447,
          "width": 320
        },
        "position": {
          "x": 48.336269181945994,
          "y": 547.079352261862
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "SplitText-bhJsI",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Split text into chunks based on specified criteria.",
            "display_name": "Split Text",
            "documentation": "https://docs.langflow.org/split-text",
            "edited": false,
            "field_order": [
              "data_inputs",
              "chunk_overlap",
              "chunk_size",
              "separator",
              "text_key",
              "keep_separator"
            ],
            "frozen": false,
            "icon": "scissors-line-dashed",
            "legacy": false,
            "lf_version": "1.7.1",
            "metadata": {
              "code_hash": "b9d63ae59e8a",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "langchain_text_splitters",
                    "version": "0.3.11"
                  },
                  {
                    "name": "lfx",
                    "version": "0.2.1"
                  }
                ],
                "total_dependencies": 2
              },
              "module": "lfx.components.processing.split_text.SplitTextComponent"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Chunks",
                "group_outputs": false,
                "method": "split_text",
                "name": "dataframe",
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "chunk_overlap": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Chunk Overlap",
                "dynamic": false,
                "info": "Number of characters to overlap between chunks.",
                "list": false,
                "list_add_label": "Add More",
                "name": "chunk_overlap",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "int",
                "value": 200
              },
              "chunk_size": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Chunk Size",
                "dynamic": false,
                "info": "The maximum length of each chunk. Text is first split by separator, then chunks are merged up to this size. Individual splits larger than this won't be further divided.",
                "list": false,
                "list_add_label": "Add More",
                "name": "chunk_size",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "int",
                "value": 1000
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langchain_text_splitters import CharacterTextSplitter\n\nfrom lfx.custom.custom_component.component import Component\nfrom lfx.io import DropdownInput, HandleInput, IntInput, MessageTextInput, Output\nfrom lfx.schema.data import Data\nfrom lfx.schema.dataframe import DataFrame\nfrom lfx.schema.message import Message\nfrom lfx.utils.util import unescape_string\n\n\nclass SplitTextComponent(Component):\n    display_name: str = \"Split Text\"\n    description: str = \"Split text into chunks based on specified criteria.\"\n    documentation: str = \"https://docs.langflow.org/split-text\"\n    icon = \"scissors-line-dashed\"\n    name = \"SplitText\"\n\n    inputs = [\n        HandleInput(\n            name=\"data_inputs\",\n            display_name=\"Input\",\n            info=\"The data with texts to split in chunks.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        IntInput(\n            name=\"chunk_overlap\",\n            display_name=\"Chunk Overlap\",\n            info=\"Number of characters to overlap between chunks.\",\n            value=200,\n        ),\n        IntInput(\n            name=\"chunk_size\",\n            display_name=\"Chunk Size\",\n            info=(\n                \"The maximum length of each chunk. Text is first split by separator, \"\n                \"then chunks are merged up to this size. \"\n                \"Individual splits larger than this won't be further divided.\"\n            ),\n            value=1000,\n        ),\n        MessageTextInput(\n            name=\"separator\",\n            display_name=\"Separator\",\n            info=(\n                \"The character to split on. Use \\\\n for newline. \"\n                \"Examples: \\\\n\\\\n for paragraphs, \\\\n for lines, . for sentences\"\n            ),\n            value=\"\\n\",\n        ),\n        MessageTextInput(\n            name=\"text_key\",\n            display_name=\"Text Key\",\n            info=\"The key to use for the text column.\",\n            value=\"text\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"keep_separator\",\n            display_name=\"Keep Separator\",\n            info=\"Whether to keep the separator in the output chunks and where to place it.\",\n            options=[\"False\", \"True\", \"Start\", \"End\"],\n            value=\"False\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Chunks\", name=\"dataframe\", method=\"split_text\"),\n    ]\n\n    def _docs_to_data(self, docs) -> list[Data]:\n        return [Data(text=doc.page_content, data=doc.metadata) for doc in docs]\n\n    def _fix_separator(self, separator: str) -> str:\n        \"\"\"Fix common separator issues and convert to proper format.\"\"\"\n        if separator == \"/n\":\n            return \"\\n\"\n        if separator == \"/t\":\n            return \"\\t\"\n        return separator\n\n    def split_text_base(self):\n        separator = self._fix_separator(self.separator)\n        separator = unescape_string(separator)\n\n        if isinstance(self.data_inputs, DataFrame):\n            if not len(self.data_inputs):\n                msg = \"DataFrame is empty\"\n                raise TypeError(msg)\n\n            self.data_inputs.text_key = self.text_key\n            try:\n                documents = self.data_inputs.to_lc_documents()\n            except Exception as e:\n                msg = f\"Error converting DataFrame to documents: {e}\"\n                raise TypeError(msg) from e\n        elif isinstance(self.data_inputs, Message):\n            self.data_inputs = [self.data_inputs.to_data()]\n            return self.split_text_base()\n        else:\n            if not self.data_inputs:\n                msg = \"No data inputs provided\"\n                raise TypeError(msg)\n\n            documents = []\n            if isinstance(self.data_inputs, Data):\n                self.data_inputs.text_key = self.text_key\n                documents = [self.data_inputs.to_lc_document()]\n            else:\n                try:\n                    documents = [input_.to_lc_document() for input_ in self.data_inputs if isinstance(input_, Data)]\n                    if not documents:\n                        msg = f\"No valid Data inputs found in {type(self.data_inputs)}\"\n                        raise TypeError(msg)\n                except AttributeError as e:\n                    msg = f\"Invalid input type in collection: {e}\"\n                    raise TypeError(msg) from e\n        try:\n            # Convert string 'False'/'True' to boolean\n            keep_sep = self.keep_separator\n            if isinstance(keep_sep, str):\n                if keep_sep.lower() == \"false\":\n                    keep_sep = False\n                elif keep_sep.lower() == \"true\":\n                    keep_sep = True\n                # 'start' and 'end' are kept as strings\n\n            splitter = CharacterTextSplitter(\n                chunk_overlap=self.chunk_overlap,\n                chunk_size=self.chunk_size,\n                separator=separator,\n                keep_separator=keep_sep,\n            )\n            return splitter.split_documents(documents)\n        except Exception as e:\n            msg = f\"Error splitting text: {e}\"\n            raise TypeError(msg) from e\n\n    def split_text(self) -> DataFrame:\n        return DataFrame(self._docs_to_data(self.split_text_base()))\n"
              },
              "data_inputs": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "The data with texts to split in chunks.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "data_inputs",
                "override_skip": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "other",
                "value": ""
              },
              "keep_separator": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Keep Separator",
                "dynamic": false,
                "external_options": {},
                "info": "Whether to keep the separator in the output chunks and where to place it.",
                "name": "keep_separator",
                "options": [
                  "False",
                  "True",
                  "Start",
                  "End"
                ],
                "options_metadata": [],
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "str",
                "value": "False"
              },
              "separator": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Separator",
                "dynamic": false,
                "info": "The character to split on. Use \\n for newline. Examples: \\n\\n for paragraphs, \\n for lines, . for sentences",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "separator",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "\n"
              },
              "text_key": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Key",
                "dynamic": false,
                "info": "The key to use for the text column.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_key",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "text"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "SplitText"
        },
        "dragging": false,
        "id": "SplitText-bhJsI",
        "measured": {
          "height": 411,
          "width": 320
        },
        "position": {
          "x": 432.4810780932343,
          "y": 547.079352261862
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "EmbeddingModel-K3FqD",
          "node": {
            "base_classes": [
              "Embeddings"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generate embeddings using a specified provider.",
            "display_name": "Embedding Model",
            "documentation": "https://docs.langflow.org/components-embedding-models",
            "edited": false,
            "field_order": [
              "provider",
              "api_base",
              "ollama_base_url",
              "base_url_ibm_watsonx",
              "model",
              "api_key",
              "project_id",
              "dimensions",
              "chunk_size",
              "request_timeout",
              "max_retries",
              "show_progress_bar",
              "model_kwargs",
              "truncate_input_tokens",
              "input_text"
            ],
            "frozen": false,
            "icon": "binary",
            "last_updated": "2026-01-27T13:44:59.396Z",
            "legacy": false,
            "metadata": {
              "code_hash": "c5e0a4535a27",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "requests",
                    "version": "2.32.5"
                  },
                  {
                    "name": "ibm_watsonx_ai",
                    "version": "1.4.11"
                  },
                  {
                    "name": "langchain_openai",
                    "version": "0.3.35"
                  },
                  {
                    "name": "lfx",
                    "version": "0.2.1"
                  },
                  {
                    "name": "langchain_ollama",
                    "version": "0.3.10"
                  },
                  {
                    "name": "langchain_community",
                    "version": "0.3.21"
                  },
                  {
                    "name": "langchain_ibm",
                    "version": "0.3.20"
                  }
                ],
                "total_dependencies": 7
              },
              "module": "lfx.components.models_and_agents.embedding_model.EmbeddingModelComponent"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Embedding Model",
                "group_outputs": false,
                "loop_types": null,
                "method": "build_embeddings",
                "name": "embeddings",
                "options": null,
                "required_inputs": null,
                "selected": "Embeddings",
                "tool_mode": true,
                "types": [
                  "Embeddings"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_frontend_node_flow_id": {
                "value": "bb806354-6312-47bb-ab99-c042fd9a7518"
              },
              "_frontend_node_folder_id": {
                "value": "3f1d0bf7-bd50-4fa9-a5d3-0974cfa99642"
              },
              "_type": "Component",
              "api_base": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "API Base URL",
                "dynamic": false,
                "info": "Base URL for the API. Leave empty for default.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "api_base",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "OpenAI API Key",
                "dynamic": false,
                "info": "Model Provider API key",
                "input_types": [],
                "load_from_db": false,
                "name": "api_key",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "base_url_ibm_watsonx": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "watsonx API Endpoint",
                "dynamic": false,
                "external_options": {},
                "info": "The base URL of the API (IBM watsonx.ai only)",
                "name": "base_url_ibm_watsonx",
                "options": [
                  "https://us-south.ml.cloud.ibm.com",
                  "https://eu-de.ml.cloud.ibm.com",
                  "https://eu-gb.ml.cloud.ibm.com",
                  "https://au-syd.ml.cloud.ibm.com",
                  "https://jp-tok.ml.cloud.ibm.com",
                  "https://ca-tor.ml.cloud.ibm.com"
                ],
                "options_metadata": [],
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "str",
                "value": "https://us-south.ml.cloud.ibm.com"
              },
              "chunk_size": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Chunk Size",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "chunk_size",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "int",
                "value": 1000
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nimport requests\nfrom ibm_watsonx_ai.metanames import EmbedTextParamsMetaNames\nfrom langchain_openai import OpenAIEmbeddings\n\nfrom lfx.base.embeddings.model import LCEmbeddingsModel\nfrom lfx.base.models.model_utils import get_ollama_models, is_valid_ollama_url\nfrom lfx.base.models.openai_constants import OPENAI_EMBEDDING_MODEL_NAMES\nfrom lfx.base.models.watsonx_constants import (\n    IBM_WATSONX_URLS,\n    WATSONX_EMBEDDING_MODEL_NAMES,\n)\nfrom lfx.field_typing import Embeddings\nfrom lfx.io import (\n    BoolInput,\n    DictInput,\n    DropdownInput,\n    FloatInput,\n    IntInput,\n    MessageTextInput,\n    SecretStrInput,\n)\nfrom lfx.log.logger import logger\nfrom lfx.schema.dotdict import dotdict\nfrom lfx.utils.util import transform_localhost_url\n\n# Ollama API constants\nHTTP_STATUS_OK = 200\nJSON_MODELS_KEY = \"models\"\nJSON_NAME_KEY = \"name\"\nJSON_CAPABILITIES_KEY = \"capabilities\"\nDESIRED_CAPABILITY = \"embedding\"\nDEFAULT_OLLAMA_URL = \"http://localhost:11434\"\n\n\nclass EmbeddingModelComponent(LCEmbeddingsModel):\n    display_name = \"Embedding Model\"\n    description = \"Generate embeddings using a specified provider.\"\n    documentation: str = \"https://docs.langflow.org/components-embedding-models\"\n    icon = \"binary\"\n    name = \"EmbeddingModel\"\n    category = \"models\"\n\n    inputs = [\n        DropdownInput(\n            name=\"provider\",\n            display_name=\"Model Provider\",\n            options=[\"OpenAI\", \"Ollama\", \"IBM watsonx.ai\"],\n            value=\"OpenAI\",\n            info=\"Select the embedding model provider\",\n            real_time_refresh=True,\n            options_metadata=[{\"icon\": \"OpenAI\"}, {\"icon\": \"Ollama\"}, {\"icon\": \"WatsonxAI\"}],\n        ),\n        MessageTextInput(\n            name=\"api_base\",\n            display_name=\"API Base URL\",\n            info=\"Base URL for the API. Leave empty for default.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"ollama_base_url\",\n            display_name=\"Ollama API URL\",\n            info=f\"Endpoint of the Ollama API (Ollama only). Defaults to {DEFAULT_OLLAMA_URL}\",\n            value=DEFAULT_OLLAMA_URL,\n            show=False,\n            real_time_refresh=True,\n            load_from_db=True,\n        ),\n        DropdownInput(\n            name=\"base_url_ibm_watsonx\",\n            display_name=\"watsonx API Endpoint\",\n            info=\"The base URL of the API (IBM watsonx.ai only)\",\n            options=IBM_WATSONX_URLS,\n            value=IBM_WATSONX_URLS[0],\n            show=False,\n            real_time_refresh=True,\n        ),\n        DropdownInput(\n            name=\"model\",\n            display_name=\"Model Name\",\n            options=OPENAI_EMBEDDING_MODEL_NAMES,\n            value=OPENAI_EMBEDDING_MODEL_NAMES[0],\n            info=\"Select the embedding model to use\",\n            real_time_refresh=True,\n            refresh_button=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"OpenAI API Key\",\n            info=\"Model Provider API key\",\n            required=True,\n            show=True,\n            real_time_refresh=True,\n        ),\n        # Watson-specific inputs\n        MessageTextInput(\n            name=\"project_id\",\n            display_name=\"Project ID\",\n            info=\"IBM watsonx.ai Project ID (required for IBM watsonx.ai)\",\n            show=False,\n        ),\n        IntInput(\n            name=\"dimensions\",\n            display_name=\"Dimensions\",\n            info=\"The number of dimensions the resulting output embeddings should have. \"\n            \"Only supported by certain models.\",\n            advanced=True,\n        ),\n        IntInput(name=\"chunk_size\", display_name=\"Chunk Size\", advanced=True, value=1000),\n        FloatInput(name=\"request_timeout\", display_name=\"Request Timeout\", advanced=True),\n        IntInput(name=\"max_retries\", display_name=\"Max Retries\", advanced=True, value=3),\n        BoolInput(name=\"show_progress_bar\", display_name=\"Show Progress Bar\", advanced=True),\n        DictInput(\n            name=\"model_kwargs\",\n            display_name=\"Model Kwargs\",\n            advanced=True,\n            info=\"Additional keyword arguments to pass to the model.\",\n        ),\n        IntInput(\n            name=\"truncate_input_tokens\",\n            display_name=\"Truncate Input Tokens\",\n            advanced=True,\n            value=200,\n            show=False,\n        ),\n        BoolInput(\n            name=\"input_text\",\n            display_name=\"Include the original text in the output\",\n            value=True,\n            advanced=True,\n            show=False,\n        ),\n    ]\n\n    @staticmethod\n    def fetch_ibm_models(base_url: str) -> list[str]:\n        \"\"\"Fetch available models from the watsonx.ai API.\"\"\"\n        try:\n            endpoint = f\"{base_url}/ml/v1/foundation_model_specs\"\n            params = {\n                \"version\": \"2024-09-16\",\n                \"filters\": \"function_embedding,!lifecycle_withdrawn:and\",\n            }\n            response = requests.get(endpoint, params=params, timeout=10)\n            response.raise_for_status()\n            data = response.json()\n            models = [model[\"model_id\"] for model in data.get(\"resources\", [])]\n            return sorted(models)\n        except Exception:  # noqa: BLE001\n            logger.exception(\"Error fetching models\")\n            return WATSONX_EMBEDDING_MODEL_NAMES\n\n    def build_embeddings(self) -> Embeddings:\n        provider = self.provider\n        model = self.model\n        api_key = self.api_key\n        api_base = self.api_base\n        base_url_ibm_watsonx = self.base_url_ibm_watsonx\n        ollama_base_url = self.ollama_base_url\n        dimensions = self.dimensions\n        chunk_size = self.chunk_size\n        request_timeout = self.request_timeout\n        max_retries = self.max_retries\n        show_progress_bar = self.show_progress_bar\n        model_kwargs = self.model_kwargs or {}\n\n        if provider == \"OpenAI\":\n            if not api_key:\n                msg = \"OpenAI API key is required when using OpenAI provider\"\n                raise ValueError(msg)\n            return OpenAIEmbeddings(\n                model=model,\n                dimensions=dimensions or None,\n                base_url=api_base or None,\n                api_key=api_key,\n                chunk_size=chunk_size,\n                max_retries=max_retries,\n                timeout=request_timeout or None,\n                show_progress_bar=show_progress_bar,\n                model_kwargs=model_kwargs,\n            )\n\n        if provider == \"Ollama\":\n            try:\n                from langchain_ollama import OllamaEmbeddings\n            except ImportError:\n                try:\n                    from langchain_community.embeddings import OllamaEmbeddings\n                except ImportError:\n                    msg = \"Please install langchain-ollama: pip install langchain-ollama\"\n                    raise ImportError(msg) from None\n\n            transformed_base_url = transform_localhost_url(ollama_base_url)\n\n            # Check if URL contains /v1 suffix (OpenAI-compatible mode)\n            if transformed_base_url and transformed_base_url.rstrip(\"/\").endswith(\"/v1\"):\n                # Strip /v1 suffix and log warning\n                transformed_base_url = transformed_base_url.rstrip(\"/\").removesuffix(\"/v1\")\n                logger.warning(\n                    \"Detected '/v1' suffix in base URL. The Ollama component uses the native Ollama API, \"\n                    \"not the OpenAI-compatible API. The '/v1' suffix has been automatically removed. \"\n                    \"If you want to use the OpenAI-compatible API, please use the OpenAI component instead. \"\n                    \"Learn more at https://docs.ollama.com/openai#openai-compatibility\"\n                )\n\n            return OllamaEmbeddings(\n                model=model,\n                base_url=transformed_base_url or \"http://localhost:11434\",\n                **model_kwargs,\n            )\n\n        if provider == \"IBM watsonx.ai\":\n            try:\n                from langchain_ibm import WatsonxEmbeddings\n            except ImportError:\n                msg = \"Please install langchain-ibm: pip install langchain-ibm\"\n                raise ImportError(msg) from None\n\n            if not api_key:\n                msg = \"IBM watsonx.ai API key is required when using IBM watsonx.ai provider\"\n                raise ValueError(msg)\n\n            project_id = self.project_id\n\n            if not project_id:\n                msg = \"Project ID is required for IBM watsonx.ai provider\"\n                raise ValueError(msg)\n\n            from ibm_watsonx_ai import APIClient, Credentials\n\n            credentials = Credentials(\n                api_key=self.api_key,\n                url=base_url_ibm_watsonx or \"https://us-south.ml.cloud.ibm.com\",\n            )\n\n            api_client = APIClient(credentials)\n\n            params = {\n                EmbedTextParamsMetaNames.TRUNCATE_INPUT_TOKENS: self.truncate_input_tokens,\n                EmbedTextParamsMetaNames.RETURN_OPTIONS: {\"input_text\": self.input_text},\n            }\n\n            return WatsonxEmbeddings(\n                model_id=model,\n                params=params,\n                watsonx_client=api_client,\n                project_id=project_id,\n            )\n\n        msg = f\"Unknown provider: {provider}\"\n        raise ValueError(msg)\n\n    async def update_build_config(\n        self, build_config: dotdict, field_value: Any, field_name: str | None = None\n    ) -> dotdict:\n        if field_name == \"provider\":\n            if field_value == \"OpenAI\":\n                build_config[\"model\"][\"options\"] = OPENAI_EMBEDDING_MODEL_NAMES\n                build_config[\"model\"][\"value\"] = OPENAI_EMBEDDING_MODEL_NAMES[0]\n                build_config[\"api_key\"][\"display_name\"] = \"OpenAI API Key\"\n                build_config[\"api_key\"][\"required\"] = True\n                build_config[\"api_key\"][\"show\"] = True\n                build_config[\"api_base\"][\"display_name\"] = \"OpenAI API Base URL\"\n                build_config[\"api_base\"][\"advanced\"] = True\n                build_config[\"api_base\"][\"show\"] = True\n                build_config[\"ollama_base_url\"][\"show\"] = False\n                build_config[\"project_id\"][\"show\"] = False\n                build_config[\"base_url_ibm_watsonx\"][\"show\"] = False\n                build_config[\"truncate_input_tokens\"][\"show\"] = False\n                build_config[\"input_text\"][\"show\"] = False\n            elif field_value == \"Ollama\":\n                build_config[\"ollama_base_url\"][\"show\"] = True\n\n                if await is_valid_ollama_url(url=self.ollama_base_url):\n                    try:\n                        models = await get_ollama_models(\n                            base_url_value=self.ollama_base_url,\n                            desired_capability=DESIRED_CAPABILITY,\n                            json_models_key=JSON_MODELS_KEY,\n                            json_name_key=JSON_NAME_KEY,\n                            json_capabilities_key=JSON_CAPABILITIES_KEY,\n                        )\n                        build_config[\"model\"][\"options\"] = models\n                        build_config[\"model\"][\"value\"] = models[0] if models else \"\"\n                    except ValueError:\n                        build_config[\"model\"][\"options\"] = []\n                        build_config[\"model\"][\"value\"] = \"\"\n                else:\n                    build_config[\"model\"][\"options\"] = []\n                    build_config[\"model\"][\"value\"] = \"\"\n                build_config[\"truncate_input_tokens\"][\"show\"] = False\n                build_config[\"input_text\"][\"show\"] = False\n                build_config[\"api_key\"][\"display_name\"] = \"API Key (Optional)\"\n                build_config[\"api_key\"][\"required\"] = False\n                build_config[\"api_key\"][\"show\"] = False\n                build_config[\"api_base\"][\"show\"] = False\n                build_config[\"project_id\"][\"show\"] = False\n                build_config[\"base_url_ibm_watsonx\"][\"show\"] = False\n\n            elif field_value == \"IBM watsonx.ai\":\n                build_config[\"model\"][\"options\"] = self.fetch_ibm_models(base_url=self.base_url_ibm_watsonx)\n                build_config[\"model\"][\"value\"] = self.fetch_ibm_models(base_url=self.base_url_ibm_watsonx)[0]\n                build_config[\"api_key\"][\"display_name\"] = \"IBM watsonx.ai API Key\"\n                build_config[\"api_key\"][\"required\"] = True\n                build_config[\"api_key\"][\"show\"] = True\n                build_config[\"api_base\"][\"show\"] = False\n                build_config[\"ollama_base_url\"][\"show\"] = False\n                build_config[\"base_url_ibm_watsonx\"][\"show\"] = True\n                build_config[\"project_id\"][\"show\"] = True\n                build_config[\"truncate_input_tokens\"][\"show\"] = True\n                build_config[\"input_text\"][\"show\"] = True\n        elif field_name == \"base_url_ibm_watsonx\":\n            build_config[\"model\"][\"options\"] = self.fetch_ibm_models(base_url=field_value)\n            build_config[\"model\"][\"value\"] = self.fetch_ibm_models(base_url=field_value)[0]\n        elif field_name == \"ollama_base_url\":\n            # # Refresh Ollama models when base URL changes\n            # if hasattr(self, \"provider\") and self.provider == \"Ollama\":\n            # Use field_value if provided, otherwise fall back to instance attribute\n            ollama_url = self.ollama_base_url\n            if await is_valid_ollama_url(url=ollama_url):\n                try:\n                    models = await get_ollama_models(\n                        base_url_value=ollama_url,\n                        desired_capability=DESIRED_CAPABILITY,\n                        json_models_key=JSON_MODELS_KEY,\n                        json_name_key=JSON_NAME_KEY,\n                        json_capabilities_key=JSON_CAPABILITIES_KEY,\n                    )\n                    build_config[\"model\"][\"options\"] = models\n                    build_config[\"model\"][\"value\"] = models[0] if models else \"\"\n                except ValueError:\n                    await logger.awarning(\"Failed to fetch Ollama embedding models.\")\n                    build_config[\"model\"][\"options\"] = []\n                    build_config[\"model\"][\"value\"] = \"\"\n\n        elif field_name == \"model\" and self.provider == \"Ollama\":\n            ollama_url = self.ollama_base_url\n            if await is_valid_ollama_url(url=ollama_url):\n                try:\n                    models = await get_ollama_models(\n                        base_url_value=ollama_url,\n                        desired_capability=DESIRED_CAPABILITY,\n                        json_models_key=JSON_MODELS_KEY,\n                        json_name_key=JSON_NAME_KEY,\n                        json_capabilities_key=JSON_CAPABILITIES_KEY,\n                    )\n                    build_config[\"model\"][\"options\"] = models\n                except ValueError:\n                    await logger.awarning(\"Failed to refresh Ollama embedding models.\")\n                    build_config[\"model\"][\"options\"] = []\n\n        return build_config\n"
              },
              "dimensions": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Dimensions",
                "dynamic": false,
                "info": "The number of dimensions the resulting output embeddings should have. Only supported by certain models.",
                "list": false,
                "list_add_label": "Add More",
                "name": "dimensions",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "int",
                "value": ""
              },
              "input_text": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Include the original text in the output",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "input_text",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": true
              },
              "is_refresh": false,
              "max_retries": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Retries",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_retries",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "int",
                "value": 3
              },
              "model": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Model Name",
                "dynamic": false,
                "external_options": {},
                "info": "Select the embedding model to use",
                "name": "model",
                "options": [
                  "text-embedding-3-small",
                  "text-embedding-3-large",
                  "text-embedding-ada-002"
                ],
                "options_metadata": [],
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "refresh_button": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "str",
                "value": "text-embedding-3-small"
              },
              "model_kwargs": {
                "_input_type": "DictInput",
                "advanced": true,
                "display_name": "Model Kwargs",
                "dynamic": false,
                "info": "Additional keyword arguments to pass to the model.",
                "list": false,
                "list_add_label": "Add More",
                "name": "model_kwargs",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "track_in_telemetry": false,
                "type": "dict",
                "value": {}
              },
              "ollama_base_url": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Ollama API URL",
                "dynamic": false,
                "info": "Endpoint of the Ollama API (Ollama only). Defaults to http://localhost:11434",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "ollama_base_url",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "project_id": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Project ID",
                "dynamic": false,
                "info": "IBM watsonx.ai Project ID (required for IBM watsonx.ai)",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "project_id",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "provider": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Model Provider",
                "dynamic": false,
                "external_options": {},
                "info": "Select the embedding model provider",
                "name": "provider",
                "options": [
                  "OpenAI",
                  "Ollama",
                  "IBM watsonx.ai"
                ],
                "options_metadata": [
                  {
                    "icon": "OpenAI"
                  },
                  {
                    "icon": "Ollama"
                  },
                  {
                    "icon": "WatsonxAI"
                  }
                ],
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "str",
                "value": "OpenAI"
              },
              "request_timeout": {
                "_input_type": "FloatInput",
                "advanced": true,
                "display_name": "Request Timeout",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "request_timeout",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "float",
                "value": ""
              },
              "show_progress_bar": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Show Progress Bar",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "show_progress_bar",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": false
              },
              "truncate_input_tokens": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Truncate Input Tokens",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "truncate_input_tokens",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "int",
                "value": 200
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "EmbeddingModel"
        },
        "dragging": false,
        "id": "EmbeddingModel-K3FqD",
        "measured": {
          "height": 367,
          "width": 320
        },
        "position": {
          "x": 432.4810780932344,
          "y": 1052.2528015055968
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "note-c5n9X",
          "node": {
            "description": "Google Drive authentication can be done using a JSON key or a physical key file.",
            "display_name": "",
            "documentation": "",
            "template": {}
          },
          "type": "note"
        },
        "dragging": true,
        "height": 324,
        "id": "note-c5n9X",
        "measured": {
          "height": 324,
          "width": 324
        },
        "position": {
          "x": -354.24552521511305,
          "y": 547.079352261862
        },
        "resizing": false,
        "selected": false,
        "type": "noteNode",
        "width": 324
      }
    ],
    "viewport": {
      "x": 348.97304617481615,
      "y": -401.3183083008871,
      "zoom": 0.7957132845556928
    }
  },
  "description": "Language Engineering Excellence.",
  "endpoint_name": null,
  "id": "bb806354-6312-47bb-ab99-c042fd9a7518",
  "is_component": false,
  "last_tested_version": "1.7.1",
  "name": "rag_document_ingestion_from_google_drive",
  "tags": []
}