{
  "data": {
    "edges": [
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ComposioYoutubeAPIComponent",
            "id": "ComposioYoutubeAPIComponent-qxDPM",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-fo305",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__ComposioYoutubeAPIComponent-qxDPM{œdataTypeœ:œComposioYoutubeAPIComponentœ,œidœ:œComposioYoutubeAPIComponent-qxDPMœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}-Agent-fo305{œfieldNameœ:œtoolsœ,œidœ:œAgent-fo305œ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "ComposioYoutubeAPIComponent-qxDPM",
        "sourceHandle": "{œdataTypeœ:œComposioYoutubeAPIComponentœ,œidœ:œComposioYoutubeAPIComponent-qxDPMœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-fo305",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-fo305œ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ComposioRedditAPIComponent",
            "id": "ComposioRedditAPIComponent-9G8UX",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-XqPFn",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__ComposioRedditAPIComponent-9G8UX{œdataTypeœ:œComposioRedditAPIComponentœ,œidœ:œComposioRedditAPIComponent-9G8UXœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}-Agent-XqPFn{œfieldNameœ:œtoolsœ,œidœ:œAgent-XqPFnœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "ComposioRedditAPIComponent-9G8UX",
        "sourceHandle": "{œdataTypeœ:œComposioRedditAPIComponentœ,œidœ:œComposioRedditAPIComponent-9G8UXœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-XqPFn",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-XqPFnœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt Template",
            "id": "Prompt Template-VqFpy",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "system_prompt",
            "id": "Agent-XqPFn",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Prompt Template-VqFpy{œdataTypeœ:œPrompt Templateœ,œidœ:œPrompt Template-VqFpyœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-Agent-XqPFn{œfieldNameœ:œsystem_promptœ,œidœ:œAgent-XqPFnœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Prompt Template-VqFpy",
        "sourceHandle": "{œdataTypeœ:œPrompt Templateœ,œidœ:œPrompt Template-VqFpyœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Agent-XqPFn",
        "targetHandle": "{œfieldNameœ:œsystem_promptœ,œidœ:œAgent-XqPFnœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt Template",
            "id": "Prompt Template-EzpCN",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "system_prompt",
            "id": "Agent-fo305",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Prompt Template-EzpCN{œdataTypeœ:œPrompt Templateœ,œidœ:œPrompt Template-EzpCNœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-Agent-fo305{œfieldNameœ:œsystem_promptœ,œidœ:œAgent-fo305œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Prompt Template-EzpCN",
        "sourceHandle": "{œdataTypeœ:œPrompt Templateœ,œidœ:œPrompt Template-EzpCNœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Agent-fo305",
        "targetHandle": "{œfieldNameœ:œsystem_promptœ,œidœ:œAgent-fo305œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt Template",
            "id": "Prompt Template-59kLB",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "system_prompt",
            "id": "Agent-mPPC2",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Prompt Template-59kLB{œdataTypeœ:œPrompt Templateœ,œidœ:œPrompt Template-59kLBœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-Agent-mPPC2{œfieldNameœ:œsystem_promptœ,œidœ:œAgent-mPPC2œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Prompt Template-59kLB",
        "sourceHandle": "{œdataTypeœ:œPrompt Templateœ,œidœ:œPrompt Template-59kLBœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Agent-mPPC2",
        "targetHandle": "{œfieldNameœ:œsystem_promptœ,œidœ:œAgent-mPPC2œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-yH61g",
            "name": "text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "days",
            "id": "Prompt Template-59kLB",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__TextInput-yH61g{œdataTypeœ:œTextInputœ,œidœ:œTextInput-yH61gœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-59kLB{œfieldNameœ:œdaysœ,œidœ:œPrompt Template-59kLBœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "TextInput-yH61g",
        "sourceHandle": "{œdataTypeœ:œTextInputœ,œidœ:œTextInput-yH61gœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-59kLB",
        "targetHandle": "{œfieldNameœ:œdaysœ,œidœ:œPrompt Template-59kLBœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-gl8uw",
            "name": "text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "product-brand-topic",
            "id": "Prompt Template-59kLB",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__TextInput-gl8uw{œdataTypeœ:œTextInputœ,œidœ:œTextInput-gl8uwœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-59kLB{œfieldNameœ:œproduct-brand-topicœ,œidœ:œPrompt Template-59kLBœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "TextInput-gl8uw",
        "sourceHandle": "{œdataTypeœ:œTextInputœ,œidœ:œTextInput-gl8uwœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-59kLB",
        "targetHandle": "{œfieldNameœ:œproduct-brand-topicœ,œidœ:œPrompt Template-59kLBœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Agent",
            "id": "Agent-fo305",
            "name": "response",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "youtube_agent_response",
            "id": "Prompt Template-59kLB",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Agent-fo305{œdataTypeœ:œAgentœ,œidœ:œAgent-fo305œ,œnameœ:œresponseœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-59kLB{œfieldNameœ:œyoutube_agent_responseœ,œidœ:œPrompt Template-59kLBœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Agent-fo305",
        "sourceHandle": "{œdataTypeœ:œAgentœ,œidœ:œAgent-fo305œ,œnameœ:œresponseœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-59kLB",
        "targetHandle": "{œfieldNameœ:œyoutube_agent_responseœ,œidœ:œPrompt Template-59kLBœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Agent",
            "id": "Agent-XqPFn",
            "name": "response",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "reddit_agent_response",
            "id": "Prompt Template-59kLB",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Agent-XqPFn{œdataTypeœ:œAgentœ,œidœ:œAgent-XqPFnœ,œnameœ:œresponseœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-59kLB{œfieldNameœ:œreddit_agent_responseœ,œidœ:œPrompt Template-59kLBœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Agent-XqPFn",
        "sourceHandle": "{œdataTypeœ:œAgentœ,œidœ:œAgent-XqPFnœ,œnameœ:œresponseœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-59kLB",
        "targetHandle": "{œfieldNameœ:œreddit_agent_responseœ,œidœ:œPrompt Template-59kLBœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-yH61g",
            "name": "text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "days",
            "id": "Prompt Template-EzpCN",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__TextInput-yH61g{œdataTypeœ:œTextInputœ,œidœ:œTextInput-yH61gœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-EzpCN{œfieldNameœ:œdaysœ,œidœ:œPrompt Template-EzpCNœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "TextInput-yH61g",
        "sourceHandle": "{œdataTypeœ:œTextInputœ,œidœ:œTextInput-yH61gœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-EzpCN",
        "targetHandle": "{œfieldNameœ:œdaysœ,œidœ:œPrompt Template-EzpCNœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-gl8uw",
            "name": "text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "product-brand-topic",
            "id": "Prompt Template-EzpCN",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__TextInput-gl8uw{œdataTypeœ:œTextInputœ,œidœ:œTextInput-gl8uwœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-EzpCN{œfieldNameœ:œproduct-brand-topicœ,œidœ:œPrompt Template-EzpCNœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "TextInput-gl8uw",
        "sourceHandle": "{œdataTypeœ:œTextInputœ,œidœ:œTextInput-gl8uwœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-EzpCN",
        "targetHandle": "{œfieldNameœ:œproduct-brand-topicœ,œidœ:œPrompt Template-EzpCNœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-yH61g",
            "name": "text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "days",
            "id": "Prompt Template-VqFpy",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__TextInput-yH61g{œdataTypeœ:œTextInputœ,œidœ:œTextInput-yH61gœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-VqFpy{œfieldNameœ:œdaysœ,œidœ:œPrompt Template-VqFpyœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "TextInput-yH61g",
        "sourceHandle": "{œdataTypeœ:œTextInputœ,œidœ:œTextInput-yH61gœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-VqFpy",
        "targetHandle": "{œfieldNameœ:œdaysœ,œidœ:œPrompt Template-VqFpyœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-gl8uw",
            "name": "text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "product-brand-topic",
            "id": "Prompt Template-VqFpy",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__TextInput-gl8uw{œdataTypeœ:œTextInputœ,œidœ:œTextInput-gl8uwœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-VqFpy{œfieldNameœ:œproduct-brand-topicœ,œidœ:œPrompt Template-VqFpyœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "TextInput-gl8uw",
        "sourceHandle": "{œdataTypeœ:œTextInputœ,œidœ:œTextInput-gl8uwœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-VqFpy",
        "targetHandle": "{œfieldNameœ:œproduct-brand-topicœ,œidœ:œPrompt Template-VqFpyœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Agent",
            "id": "Agent-mPPC2",
            "name": "response",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-4Nrbb",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__Agent-mPPC2{œdataTypeœ:œAgentœ,œidœ:œAgent-mPPC2œ,œnameœ:œresponseœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-4Nrbb{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-4Nrbbœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "Agent-mPPC2",
        "sourceHandle": "{œdataTypeœ:œAgentœ,œidœ:œAgent-mPPC2œ,œnameœ:œresponseœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ChatOutput-4Nrbb",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-4Nrbbœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}"
      }
    ],
    "nodes": [
      {
        "data": {
          "id": "Agent-fo305",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Define the agent's instructions, then enter a task to complete using tools.",
            "display_name": "Agent",
            "documentation": "https://docs.langflow.org/agents",
            "edited": false,
            "field_order": [
              "model",
              "api_key",
              "system_prompt",
              "context_id",
              "n_messages",
              "format_instructions",
              "output_schema",
              "tools",
              "input_value",
              "handle_parsing_errors",
              "verbose",
              "max_iterations",
              "agent_description",
              "add_current_date_tool"
            ],
            "frozen": false,
            "icon": "bot",
            "last_updated": "2026-01-29T00:38:21.288Z",
            "legacy": false,
            "lf_version": "1.8.0",
            "metadata": {
              "code_hash": "b60d28d2784f",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "pydantic",
                    "version": "2.11.10"
                  },
                  {
                    "name": "lfx",
                    "version": null
                  },
                  {
                    "name": "langchain_core",
                    "version": "0.3.83"
                  }
                ],
                "total_dependencies": 3
              },
              "module": "custom_components.agent"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Response",
                "group_outputs": false,
                "hidden": null,
                "loop_types": null,
                "method": "message_response",
                "name": "response",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_frontend_node_flow_id": {
                "input_types": [],
                "value": "3fd2a061-6f21-4b25-8a3c-0bbb1e47fc6c"
              },
              "_frontend_node_folder_id": {
                "input_types": [],
                "value": "a265ce36-7e1f-43cb-9964-16a87b09def2"
              },
              "_type": "Component",
              "add_current_date_tool": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Current Date",
                "dynamic": false,
                "info": "If true, will add a tool to the agent that returns the current date.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "add_current_date_tool",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": true
              },
              "agent_description": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "ai_enabled": false,
                "copy_field": false,
                "display_name": "Agent Description [Deprecated]",
                "dynamic": false,
                "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "agent_description",
                "override_skip": false,
                "password": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "A helpful assistant with access to the following tools:"
              },
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": true,
                "display_name": "API Key",
                "dynamic": false,
                "info": "Model Provider API key",
                "input_types": [],
                "load_from_db": true,
                "name": "api_key",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from __future__ import annotations\n\nimport json\nimport re\nfrom typing import TYPE_CHECKING\n\nfrom pydantic import ValidationError\n\nfrom lfx.components.models_and_agents.memory import MemoryComponent\n\nif TYPE_CHECKING:\n    from langchain_core.tools import Tool\n\nfrom lfx.base.agents.agent import LCToolsAgentComponent\nfrom lfx.base.agents.events import ExceptionWithMessageError\nfrom lfx.base.models.unified_models import (\n    get_language_model_options,\n    get_llm,\n    update_model_options_in_build_config,\n)\nfrom lfx.components.helpers import CurrentDateComponent\nfrom lfx.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\nfrom lfx.custom.custom_component.component import get_component_toolkit\nfrom lfx.helpers.base_model import build_model_from_schema\nfrom lfx.inputs.inputs import BoolInput, ModelInput\nfrom lfx.io import IntInput, MessageTextInput, MultilineInput, Output, SecretStrInput, TableInput\nfrom lfx.log.logger import logger\nfrom lfx.schema.data import Data\nfrom lfx.schema.dotdict import dotdict\nfrom lfx.schema.message import Message\nfrom lfx.schema.table import EditMode\n\n\ndef set_advanced_true(component_input):\n    component_input.advanced = True\n    return component_input\n\n\nclass AgentComponent(ToolCallingAgentComponent):\n    display_name: str = \"Agent\"\n    description: str = \"Define the agent's instructions, then enter a task to complete using tools.\"\n    documentation: str = \"https://docs.langflow.org/agents\"\n    icon = \"bot\"\n    beta = False\n    name = \"Agent\"\n\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\n\n    inputs = [\n        ModelInput(\n            name=\"model\",\n            display_name=\"Language Model\",\n            info=\"Select your model provider\",\n            real_time_refresh=True,\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"API Key\",\n            info=\"Model Provider API key\",\n            real_time_refresh=True,\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"system_prompt\",\n            display_name=\"Agent Instructions\",\n            info=\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\",\n            value=\"You are a helpful assistant that can use tools to answer questions and perform tasks.\",\n            advanced=False,\n        ),\n        MessageTextInput(\n            name=\"context_id\",\n            display_name=\"Context ID\",\n            info=\"The context ID of the chat. Adds an extra layer to the local memory.\",\n            value=\"\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"n_messages\",\n            display_name=\"Number of Chat History Messages\",\n            value=100,\n            info=\"Number of chat history messages to retrieve.\",\n            advanced=True,\n            show=True,\n        ),\n        MultilineInput(\n            name=\"format_instructions\",\n            display_name=\"Output Format Instructions\",\n            info=\"Generic Template for structured output formatting. Valid only with Structured response.\",\n            value=(\n                \"You are an AI that extracts structured JSON objects from unstructured text. \"\n                \"Use a predefined schema with expected types (str, int, float, bool, dict). \"\n                \"Extract ALL relevant instances that match the schema - if multiple patterns exist, capture them all. \"\n                \"Fill missing or ambiguous values with defaults: null for missing values. \"\n                \"Remove exact duplicates but keep variations that have different field values. \"\n                \"Always return valid JSON in the expected format, never throw errors. \"\n                \"If multiple objects can be extracted, return them all in the structured format.\"\n            ),\n            advanced=True,\n        ),\n        TableInput(\n            name=\"output_schema\",\n            display_name=\"Output Schema\",\n            info=(\n                \"Schema Validation: Define the structure and data types for structured output. \"\n                \"No validation if no output schema.\"\n            ),\n            advanced=True,\n            required=False,\n            value=[],\n            table_schema=[\n                {\n                    \"name\": \"name\",\n                    \"display_name\": \"Name\",\n                    \"type\": \"str\",\n                    \"description\": \"Specify the name of the output field.\",\n                    \"default\": \"field\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n                {\n                    \"name\": \"description\",\n                    \"display_name\": \"Description\",\n                    \"type\": \"str\",\n                    \"description\": \"Describe the purpose of the output field.\",\n                    \"default\": \"description of field\",\n                    \"edit_mode\": EditMode.POPOVER,\n                },\n                {\n                    \"name\": \"type\",\n                    \"display_name\": \"Type\",\n                    \"type\": \"str\",\n                    \"edit_mode\": EditMode.INLINE,\n                    \"description\": (\"Indicate the data type of the output field (e.g., str, int, float, bool, dict).\"),\n                    \"options\": [\"str\", \"int\", \"float\", \"bool\", \"dict\"],\n                    \"default\": \"str\",\n                },\n                {\n                    \"name\": \"multiple\",\n                    \"display_name\": \"As List\",\n                    \"type\": \"boolean\",\n                    \"description\": \"Set to True if this output field should be a list of the specified type.\",\n                    \"default\": \"False\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n            ],\n        ),\n        *LCToolsAgentComponent.get_base_inputs(),\n        # removed memory inputs from agent component\n        # *memory_inputs,\n        BoolInput(\n            name=\"add_current_date_tool\",\n            display_name=\"Current Date\",\n            advanced=True,\n            info=\"If true, will add a tool to the agent that returns the current date.\",\n            value=True,\n        ),\n    ]\n    outputs = [\n        Output(name=\"response\", display_name=\"Response\", method=\"message_response\"),\n    ]\n\n    async def get_agent_requirements(self):\n        \"\"\"Get the agent requirements for the agent.\"\"\"\n        from langchain_core.tools import StructuredTool\n\n        llm_model = get_llm(\n            model=self.model,\n            user_id=self.user_id,\n            api_key=self.api_key,\n        )\n        if llm_model is None:\n            msg = \"No language model selected. Please choose a model to proceed.\"\n            raise ValueError(msg)\n\n        # Get memory data\n        self.chat_history = await self.get_memory_data()\n        await logger.adebug(f\"Retrieved {len(self.chat_history)} chat history messages\")\n        if isinstance(self.chat_history, Message):\n            self.chat_history = [self.chat_history]\n\n        # Add current date tool if enabled\n        if self.add_current_date_tool:\n            if not isinstance(self.tools, list):  # type: ignore[has-type]\n                self.tools = []\n            current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\n\n            if not isinstance(current_date_tool, StructuredTool):\n                msg = \"CurrentDateComponent must be converted to a StructuredTool\"\n                raise TypeError(msg)\n            self.tools.append(current_date_tool)\n\n        # Set shared callbacks for tracing the tools used by the agent\n        self.set_tools_callbacks(self.tools, self._get_shared_callbacks())\n\n        return llm_model, self.chat_history, self.tools\n\n    async def message_response(self) -> Message:\n        try:\n            llm_model, self.chat_history, self.tools = await self.get_agent_requirements()\n            # Set up and run agent\n            self.set(\n                llm=llm_model,\n                tools=self.tools or [],\n                chat_history=self.chat_history,\n                input_value=self.input_value,\n                system_prompt=self.system_prompt,\n            )\n            agent = self.create_agent_runnable()\n            result = await self.run_agent(agent)\n\n            # Store result for potential JSON output\n            self._agent_result = result\n\n        except (ValueError, TypeError, KeyError) as e:\n            await logger.aerror(f\"{type(e).__name__}: {e!s}\")\n            raise\n        except ExceptionWithMessageError as e:\n            await logger.aerror(f\"ExceptionWithMessageError occurred: {e}\")\n            raise\n        # Avoid catching blind Exception; let truly unexpected exceptions propagate\n        except Exception as e:\n            await logger.aerror(f\"Unexpected error: {e!s}\")\n            raise\n        else:\n            return result\n\n    def _preprocess_schema(self, schema):\n        \"\"\"Preprocess schema to ensure correct data types for build_model_from_schema.\"\"\"\n        processed_schema = []\n        for field in schema:\n            processed_field = {\n                \"name\": str(field.get(\"name\", \"field\")),\n                \"type\": str(field.get(\"type\", \"str\")),\n                \"description\": str(field.get(\"description\", \"\")),\n                \"multiple\": field.get(\"multiple\", False),\n            }\n            # Ensure multiple is handled correctly\n            if isinstance(processed_field[\"multiple\"], str):\n                processed_field[\"multiple\"] = processed_field[\"multiple\"].lower() in [\n                    \"true\",\n                    \"1\",\n                    \"t\",\n                    \"y\",\n                    \"yes\",\n                ]\n            processed_schema.append(processed_field)\n        return processed_schema\n\n    async def build_structured_output_base(self, content: str):\n        \"\"\"Build structured output with optional BaseModel validation.\"\"\"\n        json_pattern = r\"\\{.*\\}\"\n        schema_error_msg = \"Try setting an output schema\"\n\n        # Try to parse content as JSON first\n        json_data = None\n        try:\n            json_data = json.loads(content)\n        except json.JSONDecodeError:\n            json_match = re.search(json_pattern, content, re.DOTALL)\n            if json_match:\n                try:\n                    json_data = json.loads(json_match.group())\n                except json.JSONDecodeError:\n                    return {\"content\": content, \"error\": schema_error_msg}\n            else:\n                return {\"content\": content, \"error\": schema_error_msg}\n\n        # If no output schema provided, return parsed JSON without validation\n        if not hasattr(self, \"output_schema\") or not self.output_schema or len(self.output_schema) == 0:\n            return json_data\n\n        # Use BaseModel validation with schema\n        try:\n            processed_schema = self._preprocess_schema(self.output_schema)\n            output_model = build_model_from_schema(processed_schema)\n\n            # Validate against the schema\n            if isinstance(json_data, list):\n                # Multiple objects\n                validated_objects = []\n                for item in json_data:\n                    try:\n                        validated_obj = output_model.model_validate(item)\n                        validated_objects.append(validated_obj.model_dump())\n                    except ValidationError as e:\n                        await logger.aerror(f\"Validation error for item: {e}\")\n                        # Include invalid items with error info\n                        validated_objects.append({\"data\": item, \"validation_error\": str(e)})\n                return validated_objects\n\n            # Single object\n            try:\n                validated_obj = output_model.model_validate(json_data)\n                return [validated_obj.model_dump()]  # Return as list for consistency\n            except ValidationError as e:\n                await logger.aerror(f\"Validation error: {e}\")\n                return [{\"data\": json_data, \"validation_error\": str(e)}]\n\n        except (TypeError, ValueError) as e:\n            await logger.aerror(f\"Error building structured output: {e}\")\n            # Fallback to parsed JSON without validation\n            return json_data\n\n    async def json_response(self) -> Data:\n        \"\"\"Convert agent response to structured JSON Data output with schema validation.\"\"\"\n        # Always use structured chat agent for JSON response mode for better JSON formatting\n        try:\n            system_components = []\n\n            # 1. Agent Instructions (system_prompt)\n            agent_instructions = getattr(self, \"system_prompt\", \"\") or \"\"\n            if agent_instructions:\n                system_components.append(f\"{agent_instructions}\")\n\n            # 2. Format Instructions\n            format_instructions = getattr(self, \"format_instructions\", \"\") or \"\"\n            if format_instructions:\n                system_components.append(f\"Format instructions: {format_instructions}\")\n\n            # 3. Schema Information from BaseModel\n            if hasattr(self, \"output_schema\") and self.output_schema and len(self.output_schema) > 0:\n                try:\n                    processed_schema = self._preprocess_schema(self.output_schema)\n                    output_model = build_model_from_schema(processed_schema)\n                    schema_dict = output_model.model_json_schema()\n                    schema_info = (\n                        \"You are given some text that may include format instructions, \"\n                        \"explanations, or other content alongside a JSON schema.\\n\\n\"\n                        \"Your task:\\n\"\n                        \"- Extract only the JSON schema.\\n\"\n                        \"- Return it as valid JSON.\\n\"\n                        \"- Do not include format instructions, explanations, or extra text.\\n\\n\"\n                        \"Input:\\n\"\n                        f\"{json.dumps(schema_dict, indent=2)}\\n\\n\"\n                        \"Output (only JSON schema):\"\n                    )\n                    system_components.append(schema_info)\n                except (ValidationError, ValueError, TypeError, KeyError) as e:\n                    await logger.aerror(f\"Could not build schema for prompt: {e}\", exc_info=True)\n\n            # Combine all components\n            combined_instructions = \"\\n\\n\".join(system_components) if system_components else \"\"\n            llm_model, self.chat_history, self.tools = await self.get_agent_requirements()\n            self.set(\n                llm=llm_model,\n                tools=self.tools or [],\n                chat_history=self.chat_history,\n                input_value=self.input_value,\n                system_prompt=combined_instructions,\n            )\n\n            # Create and run structured chat agent\n            try:\n                structured_agent = self.create_agent_runnable()\n            except (NotImplementedError, ValueError, TypeError) as e:\n                await logger.aerror(f\"Error with structured chat agent: {e}\")\n                raise\n            try:\n                result = await self.run_agent(structured_agent)\n            except (\n                ExceptionWithMessageError,\n                ValueError,\n                TypeError,\n                RuntimeError,\n            ) as e:\n                await logger.aerror(f\"Error with structured agent result: {e}\")\n                raise\n            # Extract content from structured agent result\n            if hasattr(result, \"content\"):\n                content = result.content\n            elif hasattr(result, \"text\"):\n                content = result.text\n            else:\n                content = str(result)\n\n        except (\n            ExceptionWithMessageError,\n            ValueError,\n            TypeError,\n            NotImplementedError,\n            AttributeError,\n        ) as e:\n            await logger.aerror(f\"Error with structured chat agent: {e}\")\n            # Fallback to regular agent\n            content_str = \"No content returned from agent\"\n            return Data(data={\"content\": content_str, \"error\": str(e)})\n\n        # Process with structured output validation\n        try:\n            structured_output = await self.build_structured_output_base(content)\n\n            # Handle different output formats\n            if isinstance(structured_output, list) and structured_output:\n                if len(structured_output) == 1:\n                    return Data(data=structured_output[0])\n                return Data(data={\"results\": structured_output})\n            if isinstance(structured_output, dict):\n                return Data(data=structured_output)\n            return Data(data={\"content\": content})\n\n        except (ValueError, TypeError) as e:\n            await logger.aerror(f\"Error in structured output processing: {e}\")\n            return Data(data={\"content\": content, \"error\": str(e)})\n\n    async def get_memory_data(self):\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\n        messages = (\n            await MemoryComponent(**self.get_base_args())\n            .set(\n                session_id=self.graph.session_id,\n                context_id=self.context_id,\n                order=\"Ascending\",\n                n_messages=self.n_messages,\n            )\n            .retrieve_messages()\n        )\n        return [\n            message for message in messages if getattr(message, \"id\", None) != getattr(self.input_value, \"id\", None)\n        ]\n\n    def update_input_types(self, build_config: dotdict) -> dotdict:\n        \"\"\"Update input types for all fields in build_config.\"\"\"\n        for key, value in build_config.items():\n            if isinstance(value, dict):\n                if value.get(\"input_types\") is None:\n                    build_config[key][\"input_types\"] = []\n            elif hasattr(value, \"input_types\") and value.input_types is None:\n                value.input_types = []\n        return build_config\n\n    async def update_build_config(\n        self,\n        build_config: dotdict,\n        field_value: list[dict],\n        field_name: str | None = None,\n    ) -> dotdict:\n        # Update model options with caching (for all field changes)\n        # Agents require tool calling, so filter for only tool-calling capable models\n        def get_tool_calling_model_options(user_id=None):\n            return get_language_model_options(user_id=user_id, tool_calling=True)\n\n        build_config = update_model_options_in_build_config(\n            component=self,\n            build_config=dict(build_config),\n            cache_key_prefix=\"language_model_options_tool_calling\",\n            get_options_func=get_tool_calling_model_options,\n            field_name=field_name,\n            field_value=field_value,\n        )\n        build_config = dotdict(build_config)\n\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\n        if field_name == \"model\":\n            # Update input types for all fields\n            build_config = self.update_input_types(build_config)\n\n            # Validate required keys\n            default_keys = [\n                \"code\",\n                \"_type\",\n                \"model\",\n                \"tools\",\n                \"input_value\",\n                \"add_current_date_tool\",\n                \"system_prompt\",\n                \"agent_description\",\n                \"max_iterations\",\n                \"handle_parsing_errors\",\n                \"verbose\",\n            ]\n            missing_keys = [key for key in default_keys if key not in build_config]\n            if missing_keys:\n                msg = f\"Missing required keys in build_config: {missing_keys}\"\n                raise ValueError(msg)\n        return dotdict({k: v.to_dict() if hasattr(v, \"to_dict\") else v for k, v in build_config.items()})\n\n    async def _get_tools(self) -> list[Tool]:\n        component_toolkit = get_component_toolkit()\n        tools_names = self._build_tools_names()\n        agent_description = self.get_tool_description()\n        # TODO: Agent Description Depreciated Feature to be removed\n        description = f\"{agent_description}{tools_names}\"\n\n        tools = component_toolkit(component=self).get_tools(\n            tool_name=\"Call_Agent\",\n            tool_description=description,\n            # here we do not use the shared callbacks as we are exposing the agent as a tool\n            callbacks=self.get_langchain_callbacks(),\n        )\n        if hasattr(self, \"tools_metadata\"):\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\n\n        return tools\n"
              },
              "context_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Context ID",
                "dynamic": false,
                "info": "The context ID of the chat. Adds an extra layer to the local memory.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "context_id",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "format_instructions": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "ai_enabled": false,
                "copy_field": false,
                "display_name": "Output Format Instructions",
                "dynamic": false,
                "info": "Generic Template for structured output formatting. Valid only with Structured response.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "format_instructions",
                "override_skip": false,
                "password": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "You are an AI that extracts structured JSON objects from unstructured text. Use a predefined schema with expected types (str, int, float, bool, dict). Extract ALL relevant instances that match the schema - if multiple patterns exist, capture them all. Fill missing or ambiguous values with defaults: null for missing values. Remove exact duplicates but keep variations that have different field values. Always return valid JSON in the expected format, never throw errors. If multiple objects can be extracted, return them all in the structured format."
              },
              "handle_parsing_errors": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Handle Parse Errors",
                "dynamic": false,
                "info": "Should the Agent fix errors when reading user input for better processing?",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "handle_parsing_errors",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": true
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "The input provided by the user for the agent to process.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "is_refresh": false,
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "int",
                "value": 15
              },
              "model": {
                "_input_type": "ModelInput",
                "advanced": false,
                "display_name": "Language Model",
                "dynamic": false,
                "external_options": {
                  "fields": {
                    "data": {
                      "node": {
                        "display_name": "Connect other models",
                        "icon": "CornerDownLeft",
                        "name": "connect_other_models"
                      }
                    }
                  }
                },
                "info": "Select your model provider",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "model_type": "language",
                "name": "model",
                "options": [
                  {
                    "category": "Anthropic",
                    "icon": "Anthropic",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatAnthropic",
                      "model_name_param": "model"
                    },
                    "name": "claude-opus-4-5-20251101",
                    "provider": "Anthropic"
                  },
                  {
                    "category": "Anthropic",
                    "icon": "Anthropic",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatAnthropic",
                      "model_name_param": "model"
                    },
                    "name": "claude-haiku-4-5-20251001",
                    "provider": "Anthropic"
                  },
                  {
                    "category": "Anthropic",
                    "icon": "Anthropic",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatAnthropic",
                      "model_name_param": "model"
                    },
                    "name": "claude-sonnet-4-5-20250929",
                    "provider": "Anthropic"
                  },
                  {
                    "category": "Anthropic",
                    "icon": "Anthropic",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatAnthropic",
                      "model_name_param": "model"
                    },
                    "name": "claude-opus-4-1-20250805",
                    "provider": "Anthropic"
                  },
                  {
                    "category": "Anthropic",
                    "icon": "Anthropic",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatAnthropic",
                      "model_name_param": "model"
                    },
                    "name": "claude-opus-4-20250514",
                    "provider": "Anthropic"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model",
                      "reasoning_models": [
                        "gpt-5.1"
                      ]
                    },
                    "name": "gpt-5.1",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model",
                      "reasoning_models": [
                        "gpt-5"
                      ]
                    },
                    "name": "gpt-5",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model",
                      "reasoning_models": [
                        "gpt-5-mini"
                      ]
                    },
                    "name": "gpt-5-mini",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model",
                      "reasoning_models": [
                        "gpt-5-nano"
                      ]
                    },
                    "name": "gpt-5-nano",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model"
                    },
                    "name": "gpt-4o-mini",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model"
                    },
                    "name": "gpt-4o",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model"
                    },
                    "name": "gpt-4-turbo",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model"
                    },
                    "name": "gpt-4",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model"
                    },
                    "name": "gpt-4o-mini-search-preview",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model"
                    },
                    "name": "gpt-4o-search-preview",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "Google Generative AI",
                    "icon": "GoogleGenerativeAI",
                    "metadata": {
                      "api_key_param": "google_api_key",
                      "context_length": 128000,
                      "model_class": "ChatGoogleGenerativeAIFixed",
                      "model_name_param": "model"
                    },
                    "name": "gemini-1.5-pro",
                    "provider": "Google Generative AI"
                  },
                  {
                    "category": "Google Generative AI",
                    "icon": "GoogleGenerativeAI",
                    "metadata": {
                      "api_key_param": "google_api_key",
                      "context_length": 128000,
                      "model_class": "ChatGoogleGenerativeAIFixed",
                      "model_name_param": "model"
                    },
                    "name": "gemini-1.5-flash",
                    "provider": "Google Generative AI"
                  },
                  {
                    "category": "Google Generative AI",
                    "icon": "GoogleGenerativeAI",
                    "metadata": {
                      "api_key_param": "google_api_key",
                      "context_length": 128000,
                      "model_class": "ChatGoogleGenerativeAIFixed",
                      "model_name_param": "model"
                    },
                    "name": "gemini-1.5-flash-8b",
                    "provider": "Google Generative AI"
                  },
                  {
                    "category": "Google Generative AI",
                    "icon": "GoogleGenerativeAI",
                    "metadata": {
                      "api_key_param": "google_api_key",
                      "context_length": 128000,
                      "model_class": "ChatGoogleGenerativeAIFixed",
                      "model_name_param": "model"
                    },
                    "name": "gemini-2.0-flash-lite",
                    "provider": "Google Generative AI"
                  },
                  {
                    "category": "Google Generative AI",
                    "icon": "GoogleGenerativeAI",
                    "metadata": {
                      "api_key_param": "google_api_key",
                      "context_length": 128000,
                      "model_class": "ChatGoogleGenerativeAIFixed",
                      "model_name_param": "model"
                    },
                    "name": "gemini-2.0-flash",
                    "provider": "Google Generative AI"
                  },
                  {
                    "category": "Ollama",
                    "icon": "Ollama",
                    "metadata": {
                      "api_key_param": "base_url",
                      "base_url_param": "base_url",
                      "context_length": 128000,
                      "model_class": "ChatOllama",
                      "model_name_param": "model"
                    },
                    "name": "llama3.3",
                    "provider": "Ollama"
                  },
                  {
                    "category": "Ollama",
                    "icon": "Ollama",
                    "metadata": {
                      "api_key_param": "base_url",
                      "base_url_param": "base_url",
                      "context_length": 128000,
                      "model_class": "ChatOllama",
                      "model_name_param": "model"
                    },
                    "name": "qwq",
                    "provider": "Ollama"
                  },
                  {
                    "category": "Ollama",
                    "icon": "Ollama",
                    "metadata": {
                      "api_key_param": "base_url",
                      "base_url_param": "base_url",
                      "context_length": 128000,
                      "model_class": "ChatOllama",
                      "model_name_param": "model"
                    },
                    "name": "llama3.2",
                    "provider": "Ollama"
                  },
                  {
                    "category": "Ollama",
                    "icon": "Ollama",
                    "metadata": {
                      "api_key_param": "base_url",
                      "base_url_param": "base_url",
                      "context_length": 128000,
                      "model_class": "ChatOllama",
                      "model_name_param": "model"
                    },
                    "name": "llama3.1",
                    "provider": "Ollama"
                  },
                  {
                    "category": "Ollama",
                    "icon": "Ollama",
                    "metadata": {
                      "api_key_param": "base_url",
                      "base_url_param": "base_url",
                      "context_length": 128000,
                      "model_class": "ChatOllama",
                      "model_name_param": "model"
                    },
                    "name": "mistral",
                    "provider": "Ollama"
                  },
                  {
                    "category": "IBM WatsonX",
                    "icon": "IBM",
                    "metadata": {
                      "api_key_param": "apikey",
                      "context_length": 128000,
                      "model_class": "ChatWatsonx",
                      "model_name_param": "model_id",
                      "project_id_param": "project_id",
                      "url_param": "url"
                    },
                    "name": "ibm/granite-3-2b-instruct",
                    "provider": "IBM WatsonX"
                  },
                  {
                    "category": "IBM WatsonX",
                    "icon": "IBM",
                    "metadata": {
                      "api_key_param": "apikey",
                      "context_length": 128000,
                      "model_class": "ChatWatsonx",
                      "model_name_param": "model_id",
                      "project_id_param": "project_id",
                      "url_param": "url"
                    },
                    "name": "ibm/granite-3-8b-instruct",
                    "provider": "IBM WatsonX"
                  },
                  {
                    "category": "IBM WatsonX",
                    "icon": "IBM",
                    "metadata": {
                      "api_key_param": "apikey",
                      "context_length": 128000,
                      "model_class": "ChatWatsonx",
                      "model_name_param": "model_id",
                      "project_id_param": "project_id",
                      "url_param": "url"
                    },
                    "name": "ibm/granite-13b-instruct-v2",
                    "provider": "IBM WatsonX"
                  }
                ],
                "override_skip": false,
                "placeholder": "Setup Provider",
                "real_time_refresh": true,
                "refresh_button": true,
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "track_in_telemetry": false,
                "type": "model",
                "value": [
                  {
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model",
                      "reasoning_models": [
                        "gpt-5-mini"
                      ]
                    },
                    "name": "gpt-5-mini",
                    "provider": "OpenAI"
                  }
                ]
              },
              "n_messages": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Chat History Messages",
                "dynamic": false,
                "info": "Number of chat history messages to retrieve.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "n_messages",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "int",
                "value": 100
              },
              "output_schema": {
                "_input_type": "TableInput",
                "advanced": true,
                "display_name": "Output Schema",
                "dynamic": false,
                "info": "Schema Validation: Define the structure and data types for structured output. No validation if no output schema.",
                "input_types": [],
                "is_list": true,
                "list_add_label": "Add More",
                "name": "output_schema",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "table_icon": "Table",
                "table_schema": [
                  {
                    "default": "field",
                    "description": "Specify the name of the output field.",
                    "display_name": "Name",
                    "edit_mode": "inline",
                    "name": "name",
                    "type": "str"
                  },
                  {
                    "default": "description of field",
                    "description": "Describe the purpose of the output field.",
                    "display_name": "Description",
                    "edit_mode": "popover",
                    "name": "description",
                    "type": "str"
                  },
                  {
                    "default": "str",
                    "description": "Indicate the data type of the output field (e.g., str, int, float, bool, dict).",
                    "display_name": "Type",
                    "edit_mode": "inline",
                    "name": "type",
                    "options": [
                      "str",
                      "int",
                      "float",
                      "bool",
                      "dict"
                    ],
                    "type": "str"
                  },
                  {
                    "default": "False",
                    "description": "Set to True if this output field should be a list of the specified type.",
                    "display_name": "As List",
                    "edit_mode": "inline",
                    "name": "multiple",
                    "type": "boolean"
                  }
                ],
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "trigger_icon": "Table",
                "trigger_text": "Open table",
                "type": "table",
                "value": []
              },
              "system_prompt": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "ai_enabled": false,
                "copy_field": false,
                "display_name": "Agent Instructions",
                "dynamic": false,
                "info": "System Prompt: Initial instructions and context provided to guide the agent's behavior.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_prompt",
                "override_skip": false,
                "password": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "You are a helpful assistant that can use tools to answer questions and perform tasks."
              },
              "tools": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Tools",
                "dynamic": false,
                "info": "These are the tools that the agent can use to help with tasks.",
                "input_types": [
                  "Tool"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "tools",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "other",
                "value": ""
              },
              "verbose": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Verbose",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "verbose",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Agent"
        },
        "dragging": false,
        "id": "Agent-fo305",
        "measured": {
          "height": 429,
          "width": 320
        },
        "position": {
          "x": -585.0696727581068,
          "y": 664.269150614968
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ComposioYoutubeAPIComponent-qxDPM",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "display_name": "YouTube",
            "documentation": "https://docs.composio.dev",
            "edited": false,
            "field_order": [
              "entity_id",
              "api_key",
              "auth_mode",
              "auth_link",
              "client_id",
              "client_secret",
              "verification_token",
              "redirect_uri",
              "authorization_url",
              "token_url",
              "api_key_field",
              "generic_api_key",
              "token",
              "access_token",
              "refresh_token",
              "username",
              "password",
              "domain",
              "base_url",
              "bearer_token",
              "authorization_code",
              "scopes",
              "subdomain",
              "instance_url",
              "tenant_id",
              "action_button"
            ],
            "frozen": false,
            "icon": "YouTube",
            "last_updated": "2026-01-29T00:35:51.000Z",
            "legacy": false,
            "lf_version": "1.8.0",
            "metadata": {
              "code_hash": "d1af2ea00e8b",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "lfx",
                    "version": null
                  }
                ],
                "total_dependencies": 1
              },
              "module": "lfx.components.composio.youtube_composio.ComposioYoutubeAPIComponent"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "group_outputs": false,
                "hidden": null,
                "loop_types": null,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_frontend_node_flow_id": {
                "input_types": [],
                "value": "3fd2a061-6f21-4b25-8a3c-0bbb1e47fc6c"
              },
              "_frontend_node_folder_id": {
                "input_types": [],
                "value": "a265ce36-7e1f-43cb-9964-16a87b09def2"
              },
              "_type": "Component",
              "access_token": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Access Token",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": false,
                "name": "access_token",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "action_button": {
                "_input_type": "SortableListInput",
                "advanced": false,
                "display_name": "Action",
                "dynamic": false,
                "helper_text": "",
                "helper_text_metadata": {},
                "info": "",
                "input_types": [],
                "limit": 1,
                "name": "action_button",
                "options": [
                  {
                    "metadata": "YOUTUBE_ADD_VIDEO_TO_PLAYLIST",
                    "name": "Add Video to Playlist"
                  },
                  {
                    "metadata": "YOUTUBE_CREATE_PLAYLIST",
                    "name": "Create Playlist"
                  },
                  {
                    "metadata": "YOUTUBE_DELETE_VIDEO",
                    "name": "Delete Video"
                  },
                  {
                    "metadata": "YOUTUBE_GET_CHANNEL_ACTIVITIES",
                    "name": "Get Channel Activities"
                  },
                  {
                    "metadata": "YOUTUBE_GET_CHANNEL_ID_BY_HANDLE",
                    "name": "Get channel ID by handle"
                  },
                  {
                    "metadata": "YOUTUBE_GET_CHANNEL_STATISTICS",
                    "name": "Get Channel Statistics"
                  },
                  {
                    "metadata": "YOUTUBE_GET_VIDEO_DETAILS_BATCH",
                    "name": "Video Details Batch"
                  },
                  {
                    "metadata": "YOUTUBE_LIST_CAPTION_TRACK",
                    "name": "List captions"
                  },
                  {
                    "metadata": "YOUTUBE_LIST_CHANNEL_VIDEOS",
                    "name": "List channel videos"
                  },
                  {
                    "metadata": "YOUTUBE_LIST_COMMENT_THREADS",
                    "name": "List Comment Threads"
                  },
                  {
                    "metadata": "YOUTUBE_LIST_MOST_POPULAR_VIDEOS",
                    "name": "List Most Popular Videos"
                  },
                  {
                    "metadata": "YOUTUBE_LIST_PLAYLIST_ITEMS",
                    "name": "List Playlist Items"
                  },
                  {
                    "metadata": "YOUTUBE_LIST_USER_PLAYLISTS",
                    "name": "List user playlists"
                  },
                  {
                    "metadata": "YOUTUBE_LIST_USER_SUBSCRIPTIONS",
                    "name": "List user subscriptions"
                  },
                  {
                    "metadata": "YOUTUBE_LOAD_CAPTIONS",
                    "name": "Download YouTube caption track"
                  },
                  {
                    "metadata": "YOUTUBE_POST_COMMENT",
                    "name": "Post Comment on Video"
                  },
                  {
                    "metadata": "YOUTUBE_SEARCH_YOU_TUBE",
                    "name": "Search YouTube"
                  },
                  {
                    "metadata": "YOUTUBE_SUBSCRIBE_CHANNEL",
                    "name": "Subscribe to channel"
                  },
                  {
                    "metadata": "YOUTUBE_UNSUBSCRIBE_CHANNEL",
                    "name": "Unsubscribe from channel"
                  },
                  {
                    "metadata": "YOUTUBE_UPDATE_THUMBNAIL",
                    "name": "Update thumbnail"
                  },
                  {
                    "metadata": "YOUTUBE_UPDATE_VIDEO",
                    "name": "Update video"
                  },
                  {
                    "metadata": "YOUTUBE_UPLOAD_VIDEO",
                    "name": "Upload video"
                  },
                  {
                    "metadata": "YOUTUBE_VIDEO_DETAILS",
                    "name": "Video details"
                  }
                ],
                "override_skip": false,
                "placeholder": "Select action",
                "real_time_refresh": true,
                "required": false,
                "search_category": [],
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "sortableList",
                "value": [
                  {
                    "chosen": false,
                    "name": "List Comment Threads",
                    "selected": false
                  }
                ]
              },
              "allThreadsRelatedToChannelId": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Allthreadsrelatedtochannelid",
                "dynamic": false,
                "info": "Returns all comment threads associated with the specified channel ID (comments on the channel page itself, not video comments). Mutually exclusive with 'videoId' and 'id'. Requires OAuth authorization.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "allThreadsRelatedToChannelId",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Composio API Key",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": false,
                "name": "api_key",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "api_key_field": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "API Key",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": false,
                "name": "api_key_field",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "auth_link": {
                "_input_type": "AuthInput",
                "advanced": false,
                "auth_scheme": "OAUTH2",
                "auth_tooltip": "Disconnect",
                "connection_id": "ca_cZ_q67i4MUzg",
                "display_name": "",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "name": "auth_link",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "auth",
                "value": "validated"
              },
              "auth_mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Auth Mode",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "name": "auth_mode",
                "options": [
                  "OAUTH2"
                ],
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "tab",
                "value": "OAUTH2"
              },
              "authorization_code": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Authorization Code",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": false,
                "name": "authorization_code",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "authorization_url": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Authorization URL",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "authorization_url",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "base_url": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Base URL",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "base_url",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "bearer_token": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Bearer Token",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": false,
                "name": "bearer_token",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "client_id": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Client id",
                "dynamic": false,
                "info": "Client id of the app",
                "input_types": [],
                "load_from_db": false,
                "name": "client_id",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "client_secret": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Client secret",
                "dynamic": false,
                "info": "Client secret of the app",
                "input_types": [],
                "load_from_db": false,
                "name": "client_secret",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": false,
                "title_case": false,
                "type": "code",
                "value": "from lfx.base.composio.composio_base import ComposioBaseComponent\n\n\nclass ComposioYoutubeAPIComponent(ComposioBaseComponent):\n    display_name: str = \"YouTube\"\n    icon = \"YouTube\"\n    documentation: str = \"https://docs.composio.dev\"\n    app_name = \"youtube\"\n\n    def set_default_tools(self):\n        \"\"\"Set the default tools for Youtube component.\"\"\"\n"
              },
              "create_auth_config": {
                "input_types": [],
                "show": false
              },
              "domain": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Domain",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "domain",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "entity_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Entity ID",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "entity_id",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "default"
              },
              "generic_api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "API Key",
                "dynamic": false,
                "info": "Enter API key on Composio page",
                "input_types": [],
                "load_from_db": false,
                "name": "generic_api_key",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "instance_url": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Instance URL",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "instance_url",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "is_refresh": false,
              "maxResults": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Maxresults",
                "dynamic": false,
                "info": "Maximum number of comment threads to return per page. Must be between 1 and 100.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "maxResults",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "int",
                "value": ""
              },
              "order": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Order",
                "dynamic": false,
                "info": "Sorting order for comment threads. 'time' returns newest first (default). 'relevance' returns most relevant first (based on popularity and engagement).",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "order",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "pageToken": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Pagetoken",
                "dynamic": false,
                "info": "Token for pagination; use nextPageToken from a previous response to retrieve the next page of results.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "pageToken",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "part": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Part",
                "dynamic": false,
                "info": "Comma-separated list of commentThread resource parts. 'snippet' includes top-level comment metadata (authorDisplayName, textDisplay, likeCount, publishedAt, etc.). 'replies' includes up to 5 reply comments if present. Valid parts: snippet, replies, id.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "part",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "password": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Password",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": false,
                "name": "password",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "redirect_uri": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Redirect URI",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "redirect_uri",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "refresh_token": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Refresh Token",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": false,
                "name": "refresh_token",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "scopes": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Scopes",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "scopes",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "searchTerms": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Searchterms",
                "dynamic": false,
                "info": "Filter comment threads to only those matching the search query. Only works with 'allThreadsRelatedToChannelId' parameter.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "searchTerms",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "subdomain": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Subdomain",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "subdomain",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "tenant_id": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Tenant ID",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tenant_id",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "textFormat": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Textformat",
                "dynamic": false,
                "info": "Format for text fields in the response. 'html' preserves HTML formatting (default). 'plainText' returns plain text without formatting.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "textFormat",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "token": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Token",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": false,
                "name": "token",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "token_url": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Token URL",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "token_url",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "tool_mode": {
                "input_types": [],
                "value": true
              },
              "tools_metadata": {
                "_input_type": "ToolsInput",
                "advanced": false,
                "display_name": "Actions",
                "dynamic": false,
                "info": "Modify tool names and descriptions to help agents understand when to use each tool.",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "tools",
                "value": [
                  {
                    "_uniqueId": "YOUTUBE_ADD_VIDEO_TO_PLAYLIST_Add Video to Playlist_0",
                    "args": {
                      "playlistId": {
                        "description": "The ID of the playlist to add the video to. You can retrieve playlist IDs using the YOUTUBE_LIST_USER_PLAYLISTS action. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "PLrAXtmErZgOeiKm4sgNOknGvNjby9efdf"
                        ],
                        "title": "Playlistid",
                        "type": "string"
                      },
                      "position": {
                        "default": null,
                        "description": "The position (zero-based index) where the video should be inserted in the playlist. If not specified, the video is added to the end of the playlist.",
                        "examples": [
                          0,
                          5
                        ],
                        "title": "Position",
                        "type": "string"
                      },
                      "videoId": {
                        "description": "The YouTube video ID to add to the playlist (typically an 11-character string). Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "dQw4w9WgXcQ",
                          "M7lc1UVf-VE"
                        ],
                        "title": "Videoid",
                        "type": "string"
                      }
                    },
                    "description": "Tool to add a video to a playlist by inserting a playlist item. Use when organizing videos into playlists or building curated collections.",
                    "display_description": "Tool to add a video to a playlist by inserting a playlist item. Use when organizing videos into playlists or building curated collections.",
                    "display_name": "Add Video to Playlist",
                    "name": "youtube_add_video_to_playlist",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_ADD_VIDEO_TO_PLAYLIST"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_CREATE_PLAYLIST_Create Playlist_1",
                    "args": {
                      "description": {
                        "default": null,
                        "description": "The playlist's description. Provides additional context about the playlist content.",
                        "examples": [
                          "A collection of my favorite cooking tutorials",
                          "Videos to watch during the weekend"
                        ],
                        "title": "Description",
                        "type": "string"
                      },
                      "privacyStatus": {
                        "default": null,
                        "description": "The playlist's privacy status. 'public' makes it visible to everyone, 'private' restricts access to the owner and specified users, 'unlisted' makes it accessible via link but not publicly listed. If not specified, defaults to YouTube's default setting.",
                        "examples": [
                          "public",
                          "private",
                          "unlisted"
                        ],
                        "title": "Privacystatus",
                        "type": "string"
                      },
                      "title": {
                        "description": "The title of the new playlist. This is a required field. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "My Favorite Videos",
                          "Watch Later Collection"
                        ],
                        "title": "Title",
                        "type": "string"
                      }
                    },
                    "description": "Tool to create a new YouTube playlist on the authenticated user's channel. Use when organizing videos into collections or building curated playlists.",
                    "display_description": "Tool to create a new YouTube playlist on the authenticated user's channel. Use when organizing videos into collections or building curated playlists.",
                    "display_name": "Create Playlist",
                    "name": "youtube_create_playlist",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_CREATE_PLAYLIST"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_DELETE_VIDEO_Delete Video_2",
                    "args": {
                      "confirmDelete": {
                        "description": "Explicit boolean confirmation required to execute the deletion. Must be set to `true` to proceed with deletion. This is a safety measure to prevent accidental video deletions. Please provide a value of type boolean. This parameter is required.",
                        "examples": [
                          true
                        ],
                        "title": "Confirmdelete",
                        "type": "boolean"
                      },
                      "onBehalfOfContentOwner": {
                        "default": null,
                        "description": "Optional parameter used by YouTube content partners to indicate the request is being made on behalf of a content owner whose content is being managed. This parameter is intended for YouTube content partners that own and manage many different YouTube channels.",
                        "examples": [
                          "contentOwnerName"
                        ],
                        "title": "Onbehalfofcontentowner",
                        "type": "string"
                      },
                      "videoId": {
                        "description": "The YouTube video ID (typically an 11-character string) to be deleted. The video must be owned by the authenticated user/channel. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "dQw4w9WgXcQ",
                          "jNQXAC9IVRw"
                        ],
                        "title": "Videoid",
                        "type": "string"
                      }
                    },
                    "description": "Tool to delete a YouTube video owned by the authenticated user/channel. Use when you need to permanently remove a video from YouTube. Requires explicit confirmation via `confirmDelete: true` to prevent accidental deletions. The video must exist and be owned by the authenticated channel.",
                    "display_description": "Tool to delete a YouTube video owned by the authenticated user/channel. Use when you need to permanently remove a video from YouTube. Requires explicit confirmation via `confirmDelete: true` to prevent accidental deletions. The video must exist and be owned by the authenticated channel.",
                    "display_name": "Delete Video",
                    "name": "youtube_delete_video",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_DELETE_VIDEO"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_GET_CHANNEL_ACTIVITIES_Get Channel Activities_3",
                    "args": {
                      "channelId": {
                        "description": "The YouTube channel ID to retrieve activities for. Channel IDs typically start with 'UC'. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "UCBJycsmduvYEL83R_U4JriQ"
                        ],
                        "title": "Channelid",
                        "type": "string"
                      },
                      "maxResults": {
                        "default": 25,
                        "description": "Maximum number of activities to return. Please provide a value of type integer.",
                        "examples": [
                          25
                        ],
                        "title": "Maxresults",
                        "type": "integer"
                      },
                      "pageToken": {
                        "default": null,
                        "description": "Pagination token from a previous response to get the next page of results. Please provide a value of type string.",
                        "examples": [
                          "CAUQAA"
                        ],
                        "title": "Pagetoken",
                        "type": "string"
                      },
                      "part": {
                        "default": "snippet,contentDetails",
                        "description": "Comma-separated list of activity resource properties to include (e.g., 'snippet', 'contentDetails', 'id'). Please provide a value of type string.",
                        "examples": [
                          "snippet,contentDetails"
                        ],
                        "title": "Part",
                        "type": "string"
                      },
                      "publishedAfter": {
                        "default": null,
                        "description": "Return activities published after this date-time (RFC 3339 format: YYYY-MM-DDTHH:MM:SSZ). Please provide a value of type string.",
                        "examples": [
                          "2024-01-01T00:00:00Z"
                        ],
                        "title": "Publishedafter",
                        "type": "string"
                      },
                      "publishedBefore": {
                        "default": null,
                        "description": "Return activities published before this date-time (RFC 3339 format: YYYY-MM-DDTHH:MM:SSZ). Please provide a value of type string.",
                        "examples": [
                          "2024-12-31T23:59:59Z"
                        ],
                        "title": "Publishedbefore",
                        "type": "string"
                      }
                    },
                    "description": "Gets recent activities from a YouTube channel including video uploads, playlist additions, likes, and other channel events.",
                    "display_description": "Gets recent activities from a YouTube channel including video uploads, playlist additions, likes, and other channel events.",
                    "display_name": "Get Channel Activities",
                    "name": "youtube_get_channel_activities",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_GET_CHANNEL_ACTIVITIES"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_GET_CHANNEL_ID_BY_HANDLE_Get channel ID by handle_4",
                    "args": {
                      "channel_handle": {
                        "description": "The YouTube channel handle (e.g., '@Google' or 'Google'). Accepts handles with or without the '@' prefix. Also accepts full YouTube channel URLs (e.g., 'https://www.youtube.com/@Google'), from which the handle will be automatically extracted. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "@Google",
                          "Google",
                          "@YouTubeCreators",
                          "https://www.youtube.com/@Google"
                        ],
                        "title": "Channel Handle",
                        "type": "string"
                      }
                    },
                    "description": "Retrieves the YouTube Channel ID for a specific YouTube channel handle.",
                    "display_description": "Retrieves the YouTube Channel ID for a specific YouTube channel handle.",
                    "display_name": "Get channel ID by handle",
                    "name": "youtube_get_channel_id_by_handle",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_GET_CHANNEL_ID_BY_HANDLE"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_GET_CHANNEL_STATISTICS_Get Channel Statistics_5",
                    "args": {
                      "forHandle": {
                        "default": null,
                        "description": "YouTube channel handle (e.g., '@Google' or 'GoogleDevelopers'). The '@' symbol is optional. Use this parameter when you know the channel's handle but not its ID. At least one of 'id', 'forHandle', 'forUsername', or 'mine' must be provided.",
                        "examples": [
                          "@Google",
                          "GoogleDevelopers"
                        ],
                        "title": "Forhandle",
                        "type": "string"
                      },
                      "forUsername": {
                        "default": null,
                        "description": "YouTube username to identify the channel. Use this parameter when you know the channel's legacy username but not its ID. At least one of 'id', 'forHandle', 'forUsername', or 'mine' must be provided.",
                        "examples": [
                          "Google"
                        ],
                        "title": "Forusername",
                        "type": "string"
                      },
                      "id": {
                        "default": null,
                        "description": "Comma-separated list of YouTube channel IDs (e.g., 'UCddiUEpeqJcYeBxX1IVBKvQ'). Channel IDs typically start with 'UC'. Use this parameter when you already have the channel ID. At least one of 'id', 'forHandle', 'forUsername', or 'mine' must be provided. Do NOT pass 'mine' as the value for this parameter - use the 'mine' boolean parameter instead to fetch the authenticated user's channel.",
                        "examples": [
                          "UCddiUEpeqJcYeBxX1IVBKvQ",
                          "UCddiUEpeqJcYeBxX1IVBKvQ,UCK8sQmJBp8GCxrOtXWBpyEA"
                        ],
                        "title": "Id",
                        "type": "string"
                      },
                      "mine": {
                        "default": null,
                        "description": "Set to true to retrieve the channel owned by the authenticated user. This is a boolean filter parameter. At least one of 'id', 'forHandle', 'forUsername', or 'mine' must be provided. Cannot be combined with other filter parameters.",
                        "examples": [
                          true
                        ],
                        "title": "Mine",
                        "type": "string"
                      },
                      "part": {
                        "default": "statistics",
                        "description": "Comma-separated list of channel resource properties to include. Use 'statistics' for subscriber count. Please provide a value of type string.",
                        "examples": [
                          "statistics",
                          "snippet,statistics"
                        ],
                        "title": "Part",
                        "type": "string"
                      }
                    },
                    "description": "Gets detailed statistics for YouTube channels including subscriber counts, view counts, and video counts. Channels can be identified using their ID, handle (e.g., @Google), or username.",
                    "display_description": "Gets detailed statistics for YouTube channels including subscriber counts, view counts, and video counts. Channels can be identified using their ID, handle (e.g., @Google), or username.",
                    "display_name": "Get Channel Statistics",
                    "name": "youtube_get_channel_statistics",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_GET_CHANNEL_STATISTICS"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_GET_VIDEO_DETAILS_BATCH_Video Details Batch_6",
                    "args": {
                      "hl": {
                        "default": null,
                        "description": "Language for localized metadata (snippet.localized); IETF language tag, e.g., 'en'.",
                        "examples": [
                          "en"
                        ],
                        "title": "Hl",
                        "type": "string"
                      },
                      "id": {
                        "description": "List of YouTube video IDs to retrieve. Accepts a list or comma-separated string. Also accepts 'videoIds' as an alias. This parameter is required.",
                        "examples": [
                          [
                            "dQw4w9WgXcQ",
                            "eX2qFMC8cFo"
                          ]
                        ],
                        "items": {
                          "type": "string"
                        },
                        "title": "Id",
                        "type": "array"
                      },
                      "parts": {
                        "default": [
                          "snippet",
                          "statistics"
                        ],
                        "description": "Video resource properties to include. Accepts a list of parts or a comma-separated string. Also accepts 'part' (singular) as an alias. Valid parts: snippet, contentDetails, statistics, status, player, topicDetails, recordingDetails, fileDetails, processingDetails, suggestions, liveStreamingDetails, localizations, paidProductPlacementDetails, id. Defaults to ['snippet', 'statistics'] if not specified.",
                        "examples": [
                          [
                            "snippet",
                            "statistics"
                          ],
                          [
                            "snippet",
                            "contentDetails",
                            "statistics"
                          ]
                        ],
                        "items": {
                          "type": "string"
                        },
                        "title": "Parts",
                        "type": "array"
                      }
                    },
                    "description": "Retrieves multiple YouTube video resource parts in a single batch call. Use when you need cohort-level metrics for many videos to reduce quota usage and latency.",
                    "display_description": "Retrieves multiple YouTube video resource parts in a single batch call. Use when you need cohort-level metrics for many videos to reduce quota usage and latency.",
                    "display_name": "Video Details Batch",
                    "name": "youtube_get_video_details_batch",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_GET_VIDEO_DETAILS_BATCH"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_LIST_CAPTION_TRACK_List captions_7",
                    "args": {
                      "part": {
                        "default": "snippet",
                        "description": "Specifies a comma-separated list of one or more caption resource parts that the API response will include. Valid parts are 'id' and 'snippet'. Please provide a value of type string.",
                        "examples": [
                          "snippet",
                          "id",
                          "id,snippet"
                        ],
                        "title": "Part",
                        "type": "string"
                      },
                      "video_id": {
                        "description": "The YouTube video ID for which the API should return caption tracks. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "dQw4w9WgXcQ",
                          "L_jWHffIx5E"
                        ],
                        "title": "Video Id",
                        "type": "string"
                      }
                    },
                    "description": "Retrieves a list of caption tracks for a YouTube video. Returns an empty items list if no captions are available. Raises ExecutionFailed if the video ID is invalid or not found.",
                    "display_description": "Retrieves a list of caption tracks for a YouTube video. Returns an empty items list if no captions are available. Raises ExecutionFailed if the video ID is invalid or not found.",
                    "display_name": "List captions",
                    "name": "youtube_list_caption_track",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_LIST_CAPTION_TRACK"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_LIST_CHANNEL_VIDEOS_List channel videos_8",
                    "args": {
                      "channelId": {
                        "description": "The YouTube channel identifier (exactly 24 characters for UC IDs). Accepts: (1) channel ID starting with 'UC' followed by 22 characters (e.g., 'UC_x5XG1OV2P6uZZ5FSM9Ttw'), (2) channel handle starting with '@' (e.g., '@Google'), (3) 'me' for the authenticated user's channel, or (4) YouTube channel URLs with /@handle or /channel/UC... format. Do NOT pass OAuth tokens, API keys, or other credentials here - only channel identifiers. Legacy /user/username URLs are supported but legacy /c/ custom URLs are not. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "UC_x5XG1OV2P6uZZ5FSM9Ttw",
                          "@Google",
                          "me",
                          "https://www.youtube.com/@Google"
                        ],
                        "title": "Channelid",
                        "type": "string"
                      },
                      "maxResults": {
                        "default": 5,
                        "description": "The maximum number of videos to return per page. Please provide a value of type integer.",
                        "examples": [
                          "5"
                        ],
                        "title": "Maxresults",
                        "type": "integer"
                      },
                      "pageToken": {
                        "default": null,
                        "description": "Token for pagination; use `nextPageToken` from a previous response for the next page, or `prevPageToken` for the previous page.",
                        "examples": [
                          "CAUQAA"
                        ],
                        "title": "Pagetoken",
                        "type": "string"
                      },
                      "part": {
                        "default": "snippet",
                        "description": "This parameter specifies which parts of the playlist item resource to return. The snippet includes basic video details like ID, title, description, and thumbnails. Please provide a value of type string.",
                        "examples": [
                          "snippet"
                        ],
                        "title": "Part",
                        "type": "string"
                      }
                    },
                    "description": "Lists videos from a specified YouTube channel. This action primarily uses the playlistItems.list endpoint with the channel's uploads playlist, which is the recommended approach by YouTube. The uploads playlist ID is obtained by fetching the channel resource via the Channels API and extracting the playlist ID from contentDetails.relatedPlaylists.uploads field. If the uploads playlist returns a 404 error (which can happen due to a known YouTube API bug where the returned playlist ID doesn't actually exist), the action automatically falls back to the search.list endpoint to retrieve channel videos. Note that the search fallback has higher quota cost (100 units vs 1 unit) and is limited to 500 results. If a channel exists but has no uploads playlist (e.g., brand accounts, channels with all videos deleted, or channels that haven't uploaded any public content), an empty result set is returned instead of an error.",
                    "display_description": "Lists videos from a specified YouTube channel. This action primarily uses the playlistItems.list endpoint with the channel's uploads playlist, which is the recommended approach by YouTube. The uploads playlist ID is obtained by fetching the channel resource via the Channels API and extracting the playlist ID from contentDetails.relatedPlaylists.uploads field. If the uploads playlist returns a 404 error (which can happen due to a known YouTube API bug where the returned playlist ID doesn't actually exist), the action automatically falls back to the search.list endpoint to retrieve channel videos. Note that the search fallback has higher quota cost (100 units vs 1 unit) and is limited to 500 results. If a channel exists but has no uploads playlist (e.g., brand accounts, channels with all videos deleted, or channels that haven't uploaded any public content), an empty result set is returned instead of an error.",
                    "display_name": "List channel videos",
                    "name": "youtube_list_channel_videos",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_LIST_CHANNEL_VIDEOS"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_LIST_COMMENT_THREADS_List Comment Threads_9",
                    "args": {
                      "allThreadsRelatedToChannelId": {
                        "default": null,
                        "description": "Returns all comment threads associated with the specified channel ID (comments on the channel page itself, not video comments). Mutually exclusive with 'videoId' and 'id'. Requires OAuth authorization.",
                        "examples": [
                          "UC_x5XG1OV2P6uZZ5FSM9Ttw"
                        ],
                        "title": "Allthreadsrelatedtochannelid",
                        "type": "string"
                      },
                      "id": {
                        "default": null,
                        "description": "Comma-separated list of comment thread IDs to retrieve. Mutually exclusive with 'videoId' and 'allThreadsRelatedToChannelId'. Use when you have specific comment thread IDs to fetch.",
                        "examples": [
                          "UgwQjKq3x6PmG9K7Vlp4AaABAg",
                          "UgzqZPqT8dFOBkYj5AB4AaABAg"
                        ],
                        "title": "Id",
                        "type": "string"
                      },
                      "maxResults": {
                        "default": 20,
                        "description": "Maximum number of comment threads to return per page. Must be between 1 and 100. Please provide a value of type integer.",
                        "examples": [
                          20,
                          50,
                          100
                        ],
                        "title": "Maxresults",
                        "type": "integer"
                      },
                      "order": {
                        "default": "time",
                        "description": "Sorting order for comment threads. 'time' returns newest first (default). 'relevance' returns most relevant first (based on popularity and engagement). Please provide a value of type string.",
                        "examples": [
                          "time",
                          "relevance"
                        ],
                        "title": "Order",
                        "type": "string"
                      },
                      "pageToken": {
                        "default": null,
                        "description": "Token for pagination; use nextPageToken from a previous response to retrieve the next page of results.",
                        "examples": [
                          "CAUQAA"
                        ],
                        "title": "Pagetoken",
                        "type": "string"
                      },
                      "part": {
                        "default": "snippet,replies",
                        "description": "Comma-separated list of commentThread resource parts. 'snippet' includes top-level comment metadata (authorDisplayName, textDisplay, likeCount, publishedAt, etc.). 'replies' includes up to 5 reply comments if present. Valid parts: snippet, replies, id. Please provide a value of type string.",
                        "examples": [
                          "snippet,replies",
                          "snippet",
                          "id"
                        ],
                        "title": "Part",
                        "type": "string"
                      },
                      "searchTerms": {
                        "default": null,
                        "description": "Filter comment threads to only those matching the search query. Only works with 'allThreadsRelatedToChannelId' parameter.",
                        "examples": [
                          "awesome video",
                          "great content"
                        ],
                        "title": "Searchterms",
                        "type": "string"
                      },
                      "textFormat": {
                        "default": "html",
                        "description": "Format for text fields in the response. 'html' preserves HTML formatting (default). 'plainText' returns plain text without formatting. Please provide a value of type string.",
                        "examples": [
                          "html",
                          "plainText"
                        ],
                        "title": "Textformat",
                        "type": "string"
                      },
                      "videoId": {
                        "default": null,
                        "description": "Returns comment threads associated with the specified video ID. Mutually exclusive with 'id' and 'allThreadsRelatedToChannelId'. This is the primary use case for retrieving comments on a specific video.",
                        "examples": [
                          "dQw4w9WgXcQ",
                          "jNQXAC9IVRw"
                        ],
                        "title": "Videoid",
                        "type": "string"
                      }
                    },
                    "description": "List comment threads from YouTube videos or channels for qualitative analysis and reporting. Returns top-level comments with optional replies (up to 5 per thread). Use the 'videoId' parameter to retrieve comments on a specific video (most common use case).",
                    "display_description": "List comment threads from YouTube videos or channels for qualitative analysis and reporting. Returns top-level comments with optional replies (up to 5 per thread). Use the 'videoId' parameter to retrieve comments on a specific video (most common use case).",
                    "display_name": "List Comment Threads",
                    "name": "youtube_list_comment_threads",
                    "readonly": true,
                    "status": true,
                    "tags": [
                      "YOUTUBE_LIST_COMMENT_THREADS"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_LIST_MOST_POPULAR_VIDEOS_List Most Popular Videos_10",
                    "args": {
                      "chart": {
                        "default": "mostPopular",
                        "description": "Identifies the chart to retrieve. The only supported value is 'mostPopular', which returns the most popular videos on YouTube. Please provide a value of type string.",
                        "examples": [
                          "mostPopular"
                        ],
                        "title": "Chart",
                        "type": "string"
                      },
                      "maxResults": {
                        "default": 10,
                        "description": "Maximum number of items to return per page. Must be between 1 and 50. Please provide a value of type integer.",
                        "examples": [
                          10,
                          25,
                          50
                        ],
                        "title": "Maxresults",
                        "type": "integer"
                      },
                      "pageToken": {
                        "default": null,
                        "description": "Token for pagination; use 'nextPageToken' from a previous response to retrieve the next page of results.",
                        "examples": [
                          "CAUQAA"
                        ],
                        "title": "Pagetoken",
                        "type": "string"
                      },
                      "part": {
                        "default": "snippet,contentDetails,statistics",
                        "description": "Comma-separated list of video resource parts that the API response will include. Valid parts: 'id', 'snippet' (title, description, thumbnails), 'contentDetails' (duration, definition, dimension), 'statistics' (view count, like count, comment count), 'status' (upload status, privacy status), 'player' (embed HTML), 'topicDetails' (associated topics), 'recordingDetails' (recording location and date), 'liveStreamingDetails' (live broadcast details), 'localizations' (localized metadata), 'fileDetails' (file metadata, streams, bitrate), 'processingDetails' (processing status and progress), 'suggestions' (processing errors, warnings, tag suggestions), and 'paidProductPlacementDetails' (paid placement information). Please provide a value of type string.",
                        "examples": [
                          "snippet,contentDetails,statistics",
                          "snippet,statistics",
                          "id,snippet"
                        ],
                        "title": "Part",
                        "type": "string"
                      },
                      "regionCode": {
                        "default": null,
                        "description": "ISO 3166-1 alpha-2 country code (e.g., 'US', 'GB', 'JP') for regional chart selection. Returns trending videos specific to that region. If not specified, uses the default region based on the API key or user location.",
                        "examples": [
                          "US",
                          "GB",
                          "JP",
                          "IN"
                        ],
                        "title": "Regioncode",
                        "type": "string"
                      },
                      "videoCategoryId": {
                        "default": null,
                        "description": "YouTube video category ID to restrict the chart to a specific category. Not all categories support mostPopular charts - the API returns 404 for unsupported categories. Known working IDs include: 1 (Film & Animation), 10 (Music), 20 (Gaming), 24 (Entertainment), 25 (News & Politics), 28 (Science & Technology). Omit this parameter to retrieve videos from all categories.",
                        "examples": [
                          "10",
                          "20",
                          "24"
                        ],
                        "title": "Videocategoryid",
                        "type": "string"
                      }
                    },
                    "description": "Tool to list the current most-popular (charts/trending) YouTube videos for a region and/or category via videos.list(chart=mostPopular). Use when you need to retrieve YouTube's official trending or most popular videos, not keyword-search approximations.",
                    "display_description": "Tool to list the current most-popular (charts/trending) YouTube videos for a region and/or category via videos.list(chart=mostPopular). Use when you need to retrieve YouTube's official trending or most popular videos, not keyword-search approximations.",
                    "display_name": "List Most Popular Videos",
                    "name": "youtube_list_most_popular_videos",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_LIST_MOST_POPULAR_VIDEOS"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_LIST_PLAYLIST_ITEMS_List Playlist Items_11",
                    "args": {
                      "fields": {
                        "default": null,
                        "description": "Selector specifying which fields to include in a partial response.",
                        "examples": [
                          "items(id,snippet/title),nextPageToken,pageInfo"
                        ],
                        "title": "Fields",
                        "type": "string"
                      },
                      "maxResults": {
                        "default": 50,
                        "description": "The maximum number of items to return per page. Must be between 0 and 50. Please provide a value of type integer.",
                        "examples": [
                          25,
                          50
                        ],
                        "title": "Maxresults",
                        "type": "integer"
                      },
                      "onBehalfOfContentOwner": {
                        "default": null,
                        "description": "Note: For YouTube content partners. Authorize using a properly scoped account.",
                        "examples": [],
                        "title": "Onbehalfofcontentowner",
                        "type": "string"
                      },
                      "pageToken": {
                        "default": null,
                        "description": "The token for the page of results to retrieve. Obtained from a previous call's nextPageToken.",
                        "examples": [
                          "CAoQAA"
                        ],
                        "title": "Pagetoken",
                        "type": "string"
                      },
                      "part": {
                        "default": "snippet,contentDetails",
                        "description": "Comma-separated list of playlistItem resource parts to include in the response. Valid values: 'snippet', 'contentDetails', 'id', 'status'. Please provide a value of type string.",
                        "examples": [
                          "snippet,contentDetails",
                          "snippet,id"
                        ],
                        "title": "Part",
                        "type": "string"
                      },
                      "playlistId": {
                        "description": "The unique playlist ID. Common formats: 'PL...' for user-created playlists, 'UU...' for channel uploads (derived from channel ID by replacing 'UC' with 'UU'). Do NOT pass channel IDs (starting with 'UC') directly. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "PLFs4vir_WsTwEd-nJgVJCZPNL3HALHHpF",
                          "UU_x5XG1OV2P6uZZ5FSM9Ttw"
                        ],
                        "title": "Playlistid",
                        "type": "string"
                      },
                      "videoId": {
                        "default": null,
                        "description": "Filter results to only those containing the specified video ID.",
                        "examples": [
                          "dQw4w9WgXcQ"
                        ],
                        "title": "Videoid",
                        "type": "string"
                      }
                    },
                    "description": "Tool to list videos in a playlist, with pagination support. Use when walking through a channel's uploads playlist to enumerate all videos.",
                    "display_description": "Tool to list videos in a playlist, with pagination support. Use when walking through a channel's uploads playlist to enumerate all videos.",
                    "display_name": "List Playlist Items",
                    "name": "youtube_list_playlist_items",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_LIST_PLAYLIST_ITEMS"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_LIST_USER_PLAYLISTS_List user playlists_12",
                    "args": {
                      "maxResults": {
                        "default": 5,
                        "description": "Maximum number of playlists to return. Please provide a value of type integer.",
                        "examples": [
                          50
                        ],
                        "title": "Maxresults",
                        "type": "integer"
                      },
                      "pageToken": {
                        "default": null,
                        "description": "Token for pagination to retrieve a specific page of results.",
                        "examples": [
                          "CAUQAA"
                        ],
                        "title": "Pagetoken",
                        "type": "string"
                      },
                      "part": {
                        "default": "snippet",
                        "description": "Specifies a comma-separated list of one or more playlist resource properties to include in the response. Common values are 'snippet', 'id', and 'contentDetails'. Please provide a value of type string.",
                        "examples": [
                          "snippet",
                          "id",
                          "contentDetails"
                        ],
                        "title": "Part",
                        "type": "string"
                      }
                    },
                    "description": "Retrieves playlists owned by the authenticated user, implicitly using mine=True.",
                    "display_description": "Retrieves playlists owned by the authenticated user, implicitly using mine=True.",
                    "display_name": "List user playlists",
                    "name": "youtube_list_user_playlists",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_LIST_USER_PLAYLISTS"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_LIST_USER_SUBSCRIPTIONS_List user subscriptions_13",
                    "args": {
                      "maxResults": {
                        "default": 5,
                        "description": "Maximum number of subscription items to return per page. Please provide a value of type integer.",
                        "examples": [
                          "5",
                          "25",
                          "50"
                        ],
                        "title": "Maxresults",
                        "type": "integer"
                      },
                      "pageToken": {
                        "default": null,
                        "description": "Token for a specific page of results, obtained from a previous response. Omit for the first page. Please provide a value of type string.",
                        "examples": [
                          "CAUQAA",
                          "CBkQAA"
                        ],
                        "title": "Pagetoken",
                        "type": "string"
                      },
                      "part": {
                        "default": "snippet,contentDetails",
                        "description": "Specifies the comma-separated subscription resource parts to include. Valid parts are `id`, `snippet`, `contentDetails`, and `subscriberSnippet`. Please provide a value of type string.",
                        "examples": [
                          "snippet",
                          "contentDetails",
                          "snippet,contentDetails",
                          "id,subscriberSnippet"
                        ],
                        "title": "Part",
                        "type": "string"
                      }
                    },
                    "description": "Retrieves the authenticated user's YouTube channel subscriptions, allowing specification of response parts and pagination.",
                    "display_description": "Retrieves the authenticated user's YouTube channel subscriptions, allowing specification of response parts and pagination.",
                    "display_name": "List user subscriptions",
                    "name": "youtube_list_user_subscriptions",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_LIST_USER_SUBSCRIPTIONS"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_LOAD_CAPTIONS_Download YouTube caption track_14",
                    "args": {
                      "id": {
                        "description": "The unique caption track ID assigned by YouTube. This is NOT the video ID. To obtain this ID, first call YOUTUBE_LIST_CAPTION_TRACK with a video_id to get the list of available caption tracks and their IDs. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "AUieDaaVe61MICLHDlfBO_KrRjXbEn-0300ZTS8rfdkY"
                        ],
                        "title": "Id",
                        "type": "string"
                      },
                      "tfmt": {
                        "default": "srt",
                        "description": "Desired format for the caption track. Supported formats: 'srt' (SubRip), 'sbv' (SubViewer), 'vtt' (WebVTT). Please provide a value of type string.",
                        "examples": [
                          "srt",
                          "sbv",
                          "vtt"
                        ],
                        "title": "Tfmt",
                        "type": "string"
                      }
                    },
                    "description": "Downloads a specific YouTube caption track, which must be owned by the authenticated user, and returns its content as text. Note: This action requires you to own the video (YouTube Data API v3 restriction). Non-owned videos will return 403 Forbidden errors, including many auto-generated caption tracks.",
                    "display_description": "Downloads a specific YouTube caption track, which must be owned by the authenticated user, and returns its content as text. Note: This action requires you to own the video (YouTube Data API v3 restriction). Non-owned videos will return 403 Forbidden errors, including many auto-generated caption tracks.",
                    "display_name": "Download YouTube caption track",
                    "name": "youtube_load_captions",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_LOAD_CAPTIONS"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_POST_COMMENT_Post Comment on Video_15",
                    "args": {
                      "channelId": {
                        "description": "The ID of the channel that uploaded the video. This is required for creating comments. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "UC_x5XG1OV2P6uZZ5FSM9Ttw"
                        ],
                        "title": "Channelid",
                        "type": "string"
                      },
                      "textOriginal": {
                        "description": "The text content of the comment. This is the actual comment message that will be posted on the video. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "Great video!",
                          "Thanks for sharing this tutorial!"
                        ],
                        "title": "Textoriginal",
                        "type": "string"
                      },
                      "videoId": {
                        "description": "The ID of the video to comment on. This is required to create a top-level comment on a video. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "dQw4w9WgXcQ",
                          "jNQXAC9IVRw"
                        ],
                        "title": "Videoid",
                        "type": "string"
                      }
                    },
                    "description": "Tool to post a new top-level comment on a YouTube video. Use when creating comments to engage with video content or respond to user requests.",
                    "display_description": "Tool to post a new top-level comment on a YouTube video. Use when creating comments to engage with video content or respond to user requests.",
                    "display_name": "Post Comment on Video",
                    "name": "youtube_post_comment",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_POST_COMMENT"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_SEARCH_YOU_TUBE_Search YouTube_16",
                    "args": {
                      "maxResults": {
                        "default": 5,
                        "description": "Maximum number of items to return per page. Please provide a value of type integer.",
                        "examples": [
                          "5"
                        ],
                        "title": "Maxresults",
                        "type": "integer"
                      },
                      "pageToken": {
                        "default": null,
                        "description": "Pagination token from a previous response's 'nextPageToken' or 'prevPageToken', used to retrieve a specific page of results.",
                        "examples": [
                          "CAUQAA"
                        ],
                        "title": "Pagetoken",
                        "type": "string"
                      },
                      "part": {
                        "default": "snippet",
                        "description": "The part parameter specifies properties to include in the response. For the search.list endpoint, only 'snippet' is a valid value. The 'id' object is always returned automatically with every search result (no quota cost). Note: 'statistics', 'contentDetails', etc. are only available on the videos.list endpoint, not search.list. Please provide a value of type string.",
                        "examples": [
                          "snippet"
                        ],
                        "title": "Part",
                        "type": "string"
                      },
                      "q": {
                        "description": "Search query term. Supports: - Basic text: 'machine learning' - Exact phrases: '\"exact phrase\"' - Exclusions: 'python -snake' - Multiple terms: 'AI OR ML' - Channel search: '@channelhandle' or channel name. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "OpenAI",
                          "machine learning tutorial",
                          "\"exact phrase\"",
                          "@mkbhd"
                        ],
                        "title": "Q",
                        "type": "string"
                      },
                      "type": {
                        "default": "video",
                        "description": "Restricts search to 'video', 'channel', or 'playlist'; comma-separate for multiple types (e.g., 'video,channel'). Please provide a value of type string.",
                        "examples": [
                          "video"
                        ],
                        "title": "Type",
                        "type": "string"
                      }
                    },
                    "description": "Searches YouTube for videos, channels, or playlists using a query term, returning the raw API response.",
                    "display_description": "Searches YouTube for videos, channels, or playlists using a query term, returning the raw API response.",
                    "display_name": "Search YouTube",
                    "name": "youtube_search_you_tube",
                    "readonly": true,
                    "status": true,
                    "tags": [
                      "YOUTUBE_SEARCH_YOU_TUBE"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_SUBSCRIBE_CHANNEL_Subscribe to channel_17",
                    "args": {
                      "channelId": {
                        "description": "Unique identifier (ID) of the YouTube channel to subscribe to (typically starts with 'UC'). Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "UCXUPKJO5MZQN11PqgIvyuvQ"
                        ],
                        "title": "Channelid",
                        "type": "string"
                      }
                    },
                    "description": "Subscribes the authenticated user to a specified YouTube channel, identified by its unique `channelId` which must be valid and existing.",
                    "display_description": "Subscribes the authenticated user to a specified YouTube channel, identified by its unique `channelId` which must be valid and existing.",
                    "display_name": "Subscribe to channel",
                    "name": "youtube_subscribe_channel",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_SUBSCRIBE_CHANNEL"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_UNSUBSCRIBE_CHANNEL_Unsubscribe from channel_18",
                    "args": {
                      "subscriptionId": {
                        "description": "The unique subscription ID to delete. This ID can be obtained from the `YOUTUBE_LIST_USER_SUBSCRIPTIONS` tool. The subscription must belong to the authenticated user. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "UCxAbc123DefGhi456Jkl789"
                        ],
                        "title": "Subscriptionid",
                        "type": "string"
                      }
                    },
                    "description": "Tool to unsubscribe the authenticated user from a YouTube channel by deleting a subscription. Use when you need to remove an existing subscription. The subscription ID can be obtained from the `YOUTUBE_LIST_USER_SUBSCRIPTIONS` tool.",
                    "display_description": "Tool to unsubscribe the authenticated user from a YouTube channel by deleting a subscription. Use when you need to remove an existing subscription. The subscription ID can be obtained from the `YOUTUBE_LIST_USER_SUBSCRIPTIONS` tool.",
                    "display_name": "Unsubscribe from channel",
                    "name": "youtube_unsubscribe_channel",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_UNSUBSCRIBE_CHANNEL"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_UPDATE_THUMBNAIL_Update thumbnail_19",
                    "args": {
                      "thumbnailUrl": {
                        "description": "Publicly accessible URL of the new thumbnail image. Must be JPG, GIF, or PNG; under 2MB. Recommended: 16:9 aspect ratio, 1280x720 resolution (minimum 640px width). Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "https://example.com/thumbnail.jpg"
                        ],
                        "title": "Thumbnailurl",
                        "type": "string"
                      },
                      "videoId": {
                        "description": "Identifier of the YouTube video for which to update the thumbnail. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "dQw4w9WgXcQ"
                        ],
                        "title": "Videoid",
                        "type": "string"
                      }
                    },
                    "description": "Sets the custom thumbnail for a YouTube video using an image from a URL. Requirements: - The authenticated user must own the video or have permission to edit it - The YouTube channel must be verified (phone verification required) to upload custom thumbnails - Image must be JPG, PNG, or GIF; under 2MB; recommended 1280x720 resolution (16:9 aspect ratio)",
                    "display_description": "Sets the custom thumbnail for a YouTube video using an image from a URL. Requirements: - The authenticated user must own the video or have permission to edit it - The YouTube channel must be verified (phone verification required) to upload custom thumbnails - Image must be JPG, PNG, or GIF; under 2MB; recommended 1280x720 resolution (16:9 aspect ratio)",
                    "display_name": "Update thumbnail",
                    "name": "youtube_update_thumbnail",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_UPDATE_THUMBNAIL"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_UPDATE_VIDEO_Update video_20",
                    "args": {
                      "categoryId": {
                        "default": null,
                        "description": "New YouTube category ID as a string. No change if omitted or `None`. Numeric values will be converted to strings.",
                        "examples": [
                          "22"
                        ],
                        "title": "Categoryid",
                        "type": "string"
                      },
                      "composio_execution_message": {
                        "default": null,
                        "description": "Internal field for execution messages about input processing.",
                        "examples": [],
                        "title": "Composio Execution Message",
                        "type": "string"
                      },
                      "description": {
                        "default": null,
                        "description": "New video description as a string. Maximum 5000 bytes (not characters). Multibyte UTF-8 characters like emojis (4 bytes each) and accented letters (2 bytes each) count more than ASCII characters. No change if omitted or `None`.",
                        "examples": [
                          "This is an updated description of my awesome video."
                        ],
                        "title": "Description",
                        "type": "string"
                      },
                      "privacy_status": {
                        "default": null,
                        "description": "New privacy status. Must be one of: 'public', 'private', or 'unlisted'. No change if omitted or `None`.",
                        "examples": [
                          "public"
                        ],
                        "title": "Privacy Status",
                        "type": "string"
                      },
                      "tags": {
                        "default": null,
                        "description": "New tags as a list of strings. Must be an actual list/array like ['tag1', 'tag2'], NOT a JSON string. Replaces all existing tags. An empty list removes all tags. No change if omitted or `None`. YouTube restrictions: (1) Angle brackets < > are forbidden and will be removed automatically. (2) Total characters across all tags must not exceed 500 (spaces in tags add 2 extra characters due to internal quoting, and commas between tags count toward the limit).",
                        "examples": [
                          [
                            "updatedTag1",
                            "updatedTag2"
                          ]
                        ],
                        "title": "Tags",
                        "type": "string"
                      },
                      "title": {
                        "default": null,
                        "description": "New video title as a string. Must be a text string, not a number. Maximum 100 characters. No change if omitted or `None`.",
                        "examples": [
                          "My Updated Awesome Video"
                        ],
                        "title": "Title",
                        "type": "string"
                      },
                      "video_id": {
                        "description": "The video's unique YouTube ID (string). Typically an 11-character alphanumeric string found in the video URL (e.g., 'dQw4w9WgXcQ'). Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "dQw4w9WgXcQ"
                        ],
                        "title": "Video Id",
                        "type": "string"
                      }
                    },
                    "description": "Updates metadata for a YouTube video identified by videoId, which must exist; an empty list for tags removes all existing tags.",
                    "display_description": "Updates metadata for a YouTube video identified by videoId, which must exist; an empty list for tags removes all existing tags.",
                    "display_name": "Update video",
                    "name": "youtube_update_video",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_UPDATE_VIDEO"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_UPLOAD_VIDEO_Upload video_21",
                    "args": {
                      "categoryId": {
                        "description": "YouTube category ID (e.g., '22' for People & Blogs). Can be provided as a string or integer. See YouTube Data API docs for a full list of category IDs. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "22"
                        ],
                        "title": "Categoryid",
                        "type": "string"
                      },
                      "description": {
                        "description": "Detailed description of the video content, optionally including keywords and context. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "A detailed walkthrough of my latest project, showcasing all its features."
                        ],
                        "title": "Description",
                        "type": "string"
                      },
                      "privacyStatus": {
                        "description": "Privacy status: 'public', 'private' (uploader/specified users only), or 'unlisted' (link accessible, not publicly listed). Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "public"
                        ],
                        "title": "Privacystatus",
                        "type": "string"
                      },
                      "tags": {
                        "description": "List of keyword tags (strings) for the video, used to improve discoverability. This parameter is required.",
                        "examples": [
                          "['educational', 'python', 'coding tutorial']"
                        ],
                        "items": {
                          "type": "string"
                        },
                        "title": "Tags",
                        "type": "array"
                      },
                      "title": {
                        "description": "The title for the video. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "My Awesome Video Adventure"
                        ],
                        "title": "Title",
                        "type": "string"
                      },
                      "videoFilePath": {
                        "description": "Video file to upload. This must be a FileUploadable object (dictionary) with three required fields: 'name' (the destination filename, e.g., 'my_video.mp4'), 'mimetype' (the MIME type, e.g., 'video/mp4'), and 's3key' (an S3 key referencing an already-uploaded file, typically obtained from a previous file download action). Do NOT pass raw file paths, URLs, or base64 data URIs directly - those formats are not supported. Example: {\"name\": \"video.mp4\", \"mimetype\": \"video/mp4\", \"s3key\": \"47563/youtube/UPLOAD_VIDEO/request/12345\"}",
                        "examples": [],
                        "title": "Videofilepath",
                        "type": "string"
                      }
                    },
                    "description": "Uploads a video from a local file path to a YouTube channel; the video file must be in a YouTube-supported format.",
                    "display_description": "Uploads a video from a local file path to a YouTube channel; the video file must be in a YouTube-supported format.",
                    "display_name": "Upload video",
                    "name": "youtube_upload_video",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_UPLOAD_VIDEO"
                    ]
                  },
                  {
                    "_uniqueId": "YOUTUBE_VIDEO_DETAILS_Video details_22",
                    "args": {
                      "id": {
                        "description": "The YouTube video ID (typically an 11-character string) for which details are to be retrieved. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "dQw4w9WgXcQ",
                          "jNQXAC9IVRw"
                        ],
                        "title": "Id",
                        "type": "string"
                      },
                      "part": {
                        "default": "snippet,contentDetails,statistics",
                        "description": "Comma-separated list of video resource parts that the API response will include. Valid parts: 'snippet' (title, description, thumbnails), 'contentDetails' (duration, definition, dimension), 'statistics' (view count, like count, comment count), 'status' (upload status, privacy status), 'player' (embed HTML), 'topicDetails' (associated topics), 'recordingDetails' (recording location and date), 'liveStreamingDetails' (live broadcast details), and 'localizations' (localized metadata). Please provide a value of type string.",
                        "examples": [
                          "snippet,contentDetails,statistics",
                          "snippet,statistics",
                          "player"
                        ],
                        "title": "Part",
                        "type": "string"
                      }
                    },
                    "description": "Retrieves specified information parts (e.g., snippet, contentDetails, statistics) for a YouTube video, identified by its ID.",
                    "display_description": "Retrieves specified information parts (e.g., snippet, contentDetails, statistics) for a YouTube video, identified by its ID.",
                    "display_name": "Video details",
                    "name": "youtube_video_details",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "YOUTUBE_VIDEO_DETAILS"
                    ]
                  }
                ]
              },
              "username": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Username",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "username",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "verification_token": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Verification Token",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "verification_token",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "videoId": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Videoid",
                "dynamic": false,
                "info": "Returns comment threads associated with the specified video ID. Mutually exclusive with 'id' and 'allThreadsRelatedToChannelId'. This is the primary use case for retrieving comments on a specific video.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "videoId",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "youtube_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Youtube Id",
                "dynamic": false,
                "info": "Id for Youtube: Comma-separated list of comment thread IDs to retrieve. Mutually exclusive with 'videoId' and 'allThreadsRelatedToChannelId'. Use when you have specific comment thread IDs to fetch.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "youtube_id",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": true
          },
          "showNode": true,
          "type": "ComposioYoutubeAPIComponent"
        },
        "dragging": false,
        "id": "ComposioYoutubeAPIComponent-qxDPM",
        "measured": {
          "height": 365,
          "width": 320
        },
        "position": {
          "x": -1053.3716726943426,
          "y": 663.4551857659798
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ComposioRedditAPIComponent-9G8UX",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "display_name": "Reddit",
            "documentation": "https://docs.composio.dev",
            "edited": false,
            "field_order": [
              "entity_id",
              "api_key",
              "auth_mode",
              "auth_link",
              "client_id",
              "client_secret",
              "verification_token",
              "redirect_uri",
              "authorization_url",
              "token_url",
              "api_key_field",
              "generic_api_key",
              "token",
              "access_token",
              "refresh_token",
              "username",
              "password",
              "domain",
              "base_url",
              "bearer_token",
              "authorization_code",
              "scopes",
              "subdomain",
              "instance_url",
              "tenant_id",
              "action_button"
            ],
            "frozen": false,
            "icon": "Reddit",
            "last_updated": "2026-01-29T00:35:51.002Z",
            "legacy": false,
            "lf_version": "1.8.0",
            "metadata": {
              "code_hash": "a86794073c22",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "lfx",
                    "version": null
                  }
                ],
                "total_dependencies": 1
              },
              "module": "lfx.components.composio.reddit_composio.ComposioRedditAPIComponent"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "group_outputs": false,
                "hidden": null,
                "loop_types": null,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_frontend_node_flow_id": {
                "input_types": [],
                "value": "3fd2a061-6f21-4b25-8a3c-0bbb1e47fc6c"
              },
              "_frontend_node_folder_id": {
                "input_types": [],
                "value": "a265ce36-7e1f-43cb-9964-16a87b09def2"
              },
              "_type": "Component",
              "access_token": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Access Token",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": false,
                "name": "access_token",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "action_button": {
                "_input_type": "SortableListInput",
                "advanced": false,
                "display_name": "Action",
                "dynamic": false,
                "helper_text": "",
                "helper_text_metadata": {},
                "info": "",
                "input_types": [],
                "limit": 1,
                "name": "action_button",
                "options": [
                  {
                    "metadata": "REDDIT_CREATE_REDDIT_POST",
                    "name": "Create a Reddit post"
                  },
                  {
                    "metadata": "REDDIT_DELETE_REDDIT_COMMENT",
                    "name": "Delete Reddit comment"
                  },
                  {
                    "metadata": "REDDIT_DELETE_REDDIT_POST",
                    "name": "Delete a Reddit post"
                  },
                  {
                    "metadata": "REDDIT_EDIT_REDDIT_COMMENT_OR_POST",
                    "name": "Edit comment or post"
                  },
                  {
                    "metadata": "REDDIT_GET",
                    "name": "Get Reddit listing by sort"
                  },
                  {
                    "metadata": "REDDIT_GET_ME_PREFS",
                    "name": "Get user preferences"
                  },
                  {
                    "metadata": "REDDIT_GET_RANDOM",
                    "name": "Get random Reddit post"
                  },
                  {
                    "metadata": "REDDIT_GET_REDDIT_USER_ABOUT",
                    "name": "Get user information"
                  },
                  {
                    "metadata": "REDDIT_GET_R_SUBREDDIT_LINK_FLAIR_V2",
                    "name": "Get link flair templates v2"
                  },
                  {
                    "metadata": "REDDIT_GET_R_TOP",
                    "name": "Get top posts from subreddit"
                  },
                  {
                    "metadata": "REDDIT_GET_SUBREDDIT_RULES",
                    "name": "Get subreddit rules"
                  },
                  {
                    "metadata": "REDDIT_GET_SUBREDDITS_SEARCH",
                    "name": "Search subreddits"
                  },
                  {
                    "metadata": "REDDIT_GET_USER_FLAIR",
                    "name": "Get user flair"
                  },
                  {
                    "metadata": "REDDIT_GET_USERNAME_AVAILABLE",
                    "name": "Check username availability"
                  },
                  {
                    "metadata": "REDDIT_LIST_SUBREDDIT_POST_FLAIRS",
                    "name": "List subreddit post flairs"
                  },
                  {
                    "metadata": "REDDIT_POST_REDDIT_COMMENT",
                    "name": "Post a comment"
                  },
                  {
                    "metadata": "REDDIT_RETRIEVE_POST_COMMENTS",
                    "name": "Retrieve Comments for a Post"
                  },
                  {
                    "metadata": "REDDIT_RETRIEVE_REDDIT_POST",
                    "name": "Retrieve posts from subreddit"
                  },
                  {
                    "metadata": "REDDIT_RETRIEVE_SPECIFIC_COMMENT",
                    "name": "Retrieve specific comment or post"
                  },
                  {
                    "metadata": "REDDIT_SEARCH_ACROSS_SUBREDDITS",
                    "name": "Search across subreddits"
                  }
                ],
                "override_skip": false,
                "placeholder": "Select action",
                "real_time_refresh": true,
                "required": false,
                "search_category": [],
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "sortableList",
                "value": [
                  {
                    "chosen": false,
                    "name": "Retrieve Comments for a Post",
                    "selected": false
                  }
                ]
              },
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Composio API Key",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": false,
                "name": "api_key",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "api_key_field": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "API Key",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": false,
                "name": "api_key_field",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "article": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Article",
                "dynamic": false,
                "info": "Base-36 ID of the Reddit post (e.g., 'q5u7q5'), typically found in the post's URL and not including the 't3_' prefix.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "article",
                "override_skip": false,
                "placeholder": "",
                "required": true,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "auth_link": {
                "_input_type": "AuthInput",
                "advanced": false,
                "auth_scheme": "OAUTH2",
                "auth_tooltip": "Disconnect",
                "connection_id": "ca_AakfPdgkSmRD",
                "display_name": "",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "name": "auth_link",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "auth",
                "value": "validated"
              },
              "auth_mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Auth Mode",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "name": "auth_mode",
                "options": [
                  "OAUTH2"
                ],
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "tab",
                "value": "OAUTH2"
              },
              "authorization_code": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Authorization Code",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": false,
                "name": "authorization_code",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "authorization_url": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Authorization URL",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "authorization_url",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "base_url": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Base URL",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "base_url",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "bearer_token": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Bearer Token",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": false,
                "name": "bearer_token",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "client_id": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Client id",
                "dynamic": false,
                "info": "Client id of the app",
                "input_types": [],
                "load_from_db": false,
                "name": "client_id",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "client_secret": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Client secret",
                "dynamic": false,
                "info": "Client secret of the app",
                "input_types": [],
                "load_from_db": false,
                "name": "client_secret",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": false,
                "title_case": false,
                "type": "code",
                "value": "from lfx.base.composio.composio_base import ComposioBaseComponent\n\n\nclass ComposioRedditAPIComponent(ComposioBaseComponent):\n    display_name: str = \"Reddit\"\n    icon = \"Reddit\"\n    documentation: str = \"https://docs.composio.dev\"\n    app_name = \"reddit\"\n\n    def set_default_tools(self):\n        \"\"\"Set the default tools for Reddit component.\"\"\"\n"
              },
              "create_auth_config": {
                "input_types": [],
                "show": false
              },
              "domain": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Domain",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "domain",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "entity_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Entity ID",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "entity_id",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "default"
              },
              "generic_api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "API Key",
                "dynamic": false,
                "info": "Enter API key on Composio page",
                "input_types": [],
                "load_from_db": false,
                "name": "generic_api_key",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "instance_url": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Instance URL",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "instance_url",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "is_refresh": false,
              "password": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Password",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": false,
                "name": "password",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "redirect_uri": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Redirect URI",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "redirect_uri",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "refresh_token": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Refresh Token",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": false,
                "name": "refresh_token",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "scopes": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Scopes",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "scopes",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "subdomain": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Subdomain",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "subdomain",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "tenant_id": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Tenant ID",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tenant_id",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "token": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Token",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": false,
                "name": "token",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "token_url": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Token URL",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "token_url",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "tool_mode": {
                "input_types": [],
                "value": true
              },
              "tools_metadata": {
                "_input_type": "ToolsInput",
                "advanced": false,
                "display_name": "Actions",
                "dynamic": false,
                "info": "Modify tool names and descriptions to help agents understand when to use each tool.",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "tools",
                "value": [
                  {
                    "_uniqueId": "REDDIT_CREATE_REDDIT_POST_Create a Reddit post_0",
                    "args": {
                      "flair_id": {
                        "default": null,
                        "description": "ID of the post flair to apply. IMPORTANT: Some subreddits require post flair - if you get a flair required error, you must first fetch available flairs for the subreddit using the Reddit API endpoint GET /r/{subreddit}/api/link_flair_v2, then retry with a valid flair_id from that list.",
                        "examples": [
                          "a1b2c3d4-e5f6-7890-1234-567890abcdef"
                        ],
                        "title": "Flair Id",
                        "type": "string"
                      },
                      "kind": {
                        "default": null,
                        "description": "The type of the post. Use 'self' for a text-based post (when providing 'text') or 'link' for a post that links to an external URL (when providing 'url'). If omitted, it is automatically inferred: 'self' when 'text' is provided, 'link' when 'url' is provided.",
                        "examples": [
                          "self",
                          "link"
                        ],
                        "title": "Kind",
                        "type": "string"
                      },
                      "subreddit": {
                        "description": "The name of the subreddit (without the 'r/' prefix) where the post will be submitted. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "learnpython",
                          "AskReddit"
                        ],
                        "title": "Subreddit",
                        "type": "string"
                      },
                      "text": {
                        "default": null,
                        "description": "The markdown-formatted text content for a 'self' post. Required if `kind` is 'self'.",
                        "examples": [
                          "This is the body of my text post. It can include **markdown** formatting."
                        ],
                        "title": "Text",
                        "type": "string"
                      },
                      "title": {
                        "description": "The title of the post. Must be 300 characters or less. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "My New Project!",
                          "Interesting Article I Found"
                        ],
                        "title": "Title",
                        "type": "string"
                      },
                      "url": {
                        "default": null,
                        "description": "The URL for a 'link' post. Required if `kind` is 'link'.",
                        "examples": [
                          "https://www.example.com/news/article.html"
                        ],
                        "title": "Url",
                        "type": "string"
                      }
                    },
                    "description": "Creates a new text or link post on a specified, existing Reddit subreddit, optionally applying a flair.",
                    "display_description": "Creates a new text or link post on a specified, existing Reddit subreddit, optionally applying a flair.",
                    "display_name": "Create a Reddit post",
                    "name": "reddit_create_reddit_post",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "REDDIT_CREATE_REDDIT_POST"
                    ]
                  },
                  {
                    "_uniqueId": "REDDIT_DELETE_REDDIT_COMMENT_Delete Reddit comment_1",
                    "args": {
                      "id": {
                        "description": "The full 'thing ID' (fullname, e.g., 't1_c0s4w1c') of the comment to delete; typically starts with 't1_'. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "t1_c0s4w1c"
                        ],
                        "title": "Id",
                        "type": "string"
                      }
                    },
                    "description": "Deletes a Reddit comment, identified by its fullname ID, if it was authored by the authenticated user.",
                    "display_description": "Deletes a Reddit comment, identified by its fullname ID, if it was authored by the authenticated user.",
                    "display_name": "Delete Reddit comment",
                    "name": "reddit_delete_reddit_comment",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "REDDIT_DELETE_REDDIT_COMMENT"
                    ]
                  },
                  {
                    "_uniqueId": "REDDIT_DELETE_REDDIT_POST_Delete a Reddit post_2",
                    "args": {
                      "id": {
                        "description": "The full name (fullname) of the Reddit post to be deleted. This ID must start with 't3_' followed by the post's unique base36 identifier. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "t3_1abcdef",
                          "t3_gfedcba"
                        ],
                        "title": "Id",
                        "type": "string"
                      }
                    },
                    "description": "Permanently deletes a Reddit post by its ID, provided the authenticated user has deletion permissions for that post.",
                    "display_description": "Permanently deletes a Reddit post by its ID, provided the authenticated user has deletion permissions for that post.",
                    "display_name": "Delete a Reddit post",
                    "name": "reddit_delete_reddit_post",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "REDDIT_DELETE_REDDIT_POST"
                    ]
                  },
                  {
                    "_uniqueId": "REDDIT_EDIT_REDDIT_COMMENT_OR_POST_Edit comment or post_3",
                    "args": {
                      "text": {
                        "description": "The new raw markdown text for the body of the comment or self-post. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "This is the *updated* content with **markdown** formatting."
                        ],
                        "title": "Text",
                        "type": "string"
                      },
                      "thing_id": {
                        "description": "The full name (fullname) of the comment or self-post to edit. This is a combination of a prefix (e.g., 't1_' for comment, 't3_' for post) and the item's ID. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "t1_c0c0c0c",
                          "t3_h0h0h0h"
                        ],
                        "title": "Thing Id",
                        "type": "string"
                      }
                    },
                    "description": "Edits the body text of the authenticated user's own existing comment or self-post on Reddit; cannot edit link posts or titles.",
                    "display_description": "Edits the body text of the authenticated user's own existing comment or self-post on Reddit; cannot edit link posts or titles.",
                    "display_name": "Edit comment or post",
                    "name": "reddit_edit_reddit_comment_or_post",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "REDDIT_EDIT_REDDIT_COMMENT_OR_POST"
                    ]
                  },
                  {
                    "_uniqueId": "REDDIT_GET_Get Reddit listing by sort_4",
                    "args": {
                      "after": {
                        "default": null,
                        "description": "Fullname of a thing for pagination (loads posts after this item).",
                        "examples": [],
                        "title": "After",
                        "type": "string"
                      },
                      "before": {
                        "default": null,
                        "description": "Fullname of a thing for pagination (loads posts before this item).",
                        "examples": [],
                        "title": "Before",
                        "type": "string"
                      },
                      "count": {
                        "default": null,
                        "description": "A positive integer representing the number of items already seen (default: 0).",
                        "examples": [],
                        "title": "Count",
                        "type": "string"
                      },
                      "limit": {
                        "default": null,
                        "description": "The maximum number of items desired (default: 25, maximum: 100).",
                        "examples": [
                          25,
                          50,
                          100
                        ],
                        "title": "Limit",
                        "type": "string"
                      },
                      "show": {
                        "default": null,
                        "description": "The string 'all' to show all posts including filtered ones.",
                        "examples": [],
                        "title": "Show",
                        "type": "string"
                      },
                      "sort": {
                        "description": "The sorting method for results. Valid values: hot, new, top, rising, controversial, best. Note: 'random' is NOT supported here - use the GET_RANDOM action instead. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "hot",
                          "new",
                          "top",
                          "rising",
                          "controversial",
                          "best"
                        ],
                        "title": "Sort",
                        "type": "string"
                      },
                      "time_filter": {
                        "default": null,
                        "description": "Time filter for 'top' and 'controversial' sorts. Valid values: hour, day, week, month, year, all.",
                        "examples": [
                          "hour",
                          "day",
                          "week",
                          "month",
                          "year",
                          "all"
                        ],
                        "title": "Time Filter",
                        "type": "string"
                      }
                    },
                    "description": "Tool to retrieve a listing of Reddit posts sorted by the specified criteria (hot, new, top, etc.). Use when you need to get posts from the Reddit front page or all of Reddit with a specific sort order. Supports pagination and time filtering for top/controversial sorts.",
                    "display_description": "Tool to retrieve a listing of Reddit posts sorted by the specified criteria (hot, new, top, etc.). Use when you need to get posts from the Reddit front page or all of Reddit with a specific sort order. Supports pagination and time filtering for top/controversial sorts.",
                    "display_name": "Get Reddit listing by sort",
                    "name": "reddit_get",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "REDDIT_GET"
                    ]
                  },
                  {
                    "_uniqueId": "REDDIT_GET_ME_PREFS_Get user preferences_5",
                    "args": {
                      "fields": {
                        "default": null,
                        "description": "A comma-separated list of preference fields to return. If not specified, all preference fields are returned. Supported fields include: threaded_messages, hide_downs, hide_ups, activity_relevant_ads, nightmode, compress, beta, media, media_preview, label_nsfw, over_18, search_include_over_18, hide_ads, email_messages, email_digests, monitor_mentions, hide_from_robots, profile_opt_out, public_votes, lang, theme_selector, min_comment_score, min_link_score, accept_pms, show_link_flair, show_trending, private_feeds, research, ignore_suggested_sort, domain_details, legacy_search, live_orangereds, highlight_controversial, no_profanity, email_unsubscribe_all, in_redesign_beta, allow_clicktracking, show_twitter, store_visits, threaded_modmail, enable_default_themes, geopopular, show_stylesheets, show_promote, organic, collapse_read_messages, show_flair, mark_messages_read, top_karma_subreddits, newwindow, video_autoplay, credit_autorenew, clickgadget, use_global_defaults, other_theme, num_comments, numsites, and g.",
                        "examples": [
                          "lang,theme_selector,nightmode",
                          "hide_ads,email_messages"
                        ],
                        "title": "Fields",
                        "type": "string"
                      }
                    },
                    "description": "Tool to retrieve preference settings of the logged in user. Use when you need to check user preferences or settings.",
                    "display_description": "Tool to retrieve preference settings of the logged in user. Use when you need to check user preferences or settings.",
                    "display_name": "Get user preferences",
                    "name": "reddit_get_me_prefs",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "REDDIT_GET_ME_PREFS"
                    ]
                  },
                  {
                    "_uniqueId": "REDDIT_GET_RANDOM_Get random Reddit post_6",
                    "args": {
                      "subreddit": {
                        "default": null,
                        "description": "Name of the subreddit to get a random post from. If not specified, returns a random post from all of Reddit. Do not include 'r/' prefix.",
                        "examples": [
                          "AskReddit",
                          "technology",
                          "programming"
                        ],
                        "title": "Subreddit",
                        "type": "string"
                      }
                    },
                    "description": "Tool to retrieve a random public Reddit post from any subreddit. Use when you want to discover serendipitous content or need a random post for testing or entertainment purposes.",
                    "display_description": "Tool to retrieve a random public Reddit post from any subreddit. Use when you want to discover serendipitous content or need a random post for testing or entertainment purposes.",
                    "display_name": "Get random Reddit post",
                    "name": "reddit_get_random",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "REDDIT_GET_RANDOM"
                    ]
                  },
                  {
                    "_uniqueId": "REDDIT_GET_REDDIT_USER_ABOUT_Get user information_7",
                    "args": {
                      "username": {
                        "description": "The name of an existing Reddit user to retrieve information about. Do not include 'u/' prefix. Use 'me' to get information about the currently authenticated user. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "spez",
                          "reddit",
                          "AutoModerator",
                          "me"
                        ],
                        "title": "Username",
                        "type": "string"
                      }
                    },
                    "description": "Retrieves information about a specified Reddit user account, including karma scores and gold status. Use when you need to get profile information for any public Reddit user.",
                    "display_description": "Retrieves information about a specified Reddit user account, including karma scores and gold status. Use when you need to get profile information for any public Reddit user.",
                    "display_name": "Get user information",
                    "name": "reddit_get_reddit_user_about",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "REDDIT_GET_REDDIT_USER_ABOUT"
                    ]
                  },
                  {
                    "_uniqueId": "REDDIT_GET_R_SUBREDDIT_LINK_FLAIR_V2_Get link flair templates v2_8",
                    "args": {
                      "subreddit": {
                        "description": "The name of the subreddit to retrieve link flair templates from (e.g., 'test', 'python'). Do not include 'r/' prefix. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "test",
                          "python",
                          "AskReddit"
                        ],
                        "title": "Subreddit",
                        "type": "string"
                      }
                    },
                    "description": "Returns available link flair templates for posts in a subreddit. Use when you need to retrieve the list of link flair options that can be applied to posts, including enhanced v2 properties like richtext formatting and editable status.",
                    "display_description": "Returns available link flair templates for posts in a subreddit. Use when you need to retrieve the list of link flair options that can be applied to posts, including enhanced v2 properties like richtext formatting and editable status.",
                    "display_name": "Get link flair templates v2",
                    "name": "reddit_get_r_subreddit_link_flair_v2",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "REDDIT_GET_R_SUBREDDIT_LINK_FLAIR_V2"
                    ]
                  },
                  {
                    "_uniqueId": "REDDIT_GET_R_TOP_Get top posts from subreddit_9",
                    "args": {
                      "after": {
                        "default": null,
                        "description": "Fullname of a thing to use as anchor for pagination. Returns results that occur after this fullname in the listing.",
                        "examples": [
                          "t3_abc123"
                        ],
                        "title": "After",
                        "type": "string"
                      },
                      "before": {
                        "default": null,
                        "description": "Fullname of a thing to use as anchor for pagination. Returns results that occur before this fullname in the listing.",
                        "examples": [
                          "t3_xyz789"
                        ],
                        "title": "Before",
                        "type": "string"
                      },
                      "count": {
                        "default": null,
                        "description": "Used by Reddit to number listings after the first page for pagination. Represents the number of items already seen.",
                        "examples": [
                          0,
                          25,
                          50
                        ],
                        "title": "Count",
                        "type": "string"
                      },
                      "limit": {
                        "default": 25,
                        "description": "Maximum number of top posts to return. Default is 25, maximum is 100. Please provide a value of type integer.",
                        "examples": [
                          10,
                          25,
                          50,
                          100
                        ],
                        "title": "Limit",
                        "type": "integer"
                      },
                      "show": {
                        "default": null,
                        "description": "Display filtering option. Use 'all' to return items that would normally be omitted (e.g., posts you have hidden).",
                        "examples": [
                          "all"
                        ],
                        "title": "Show",
                        "type": "string"
                      },
                      "sr_detail": {
                        "default": null,
                        "description": "Expand subreddits detail in response. Set to true to get more detailed subreddit information.",
                        "examples": [],
                        "title": "Sr Detail",
                        "type": "string"
                      },
                      "subreddit": {
                        "description": "The name of the subreddit to retrieve top posts from. Do not include 'r/' prefix. Subreddit names are case-insensitive but must be the actual subreddit name (not abbreviations or aliases). Use a subreddit search action first if unsure of the exact name. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "python",
                          "technology",
                          "programming",
                          "news"
                        ],
                        "title": "Subreddit",
                        "type": "string"
                      },
                      "t": {
                        "default": "all",
                        "description": "Time filter for ranking top posts. Specifies the time period for top posts: 'hour', 'day', 'week', 'month', 'year', or 'all' (default). Please provide a value of type string.",
                        "examples": [
                          "day",
                          "week",
                          "month",
                          "all"
                        ],
                        "title": "T",
                        "type": "string"
                      }
                    },
                    "description": "Tool to retrieve top-rated posts from a subreddit with time filters. Use when you need to find the most popular posts from a specific time period (hour, day, week, month, year, or all-time). Returns a paginated listing of posts ranked by score within the specified time frame.",
                    "display_description": "Tool to retrieve top-rated posts from a subreddit with time filters. Use when you need to find the most popular posts from a specific time period (hour, day, week, month, year, or all-time). Returns a paginated listing of posts ranked by score within the specified time frame.",
                    "display_name": "Get top posts from subreddit",
                    "name": "reddit_get_r_top",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "REDDIT_GET_R_TOP"
                    ]
                  },
                  {
                    "_uniqueId": "REDDIT_GET_SUBREDDIT_RULES_Get subreddit rules_10",
                    "args": {
                      "raw_json": {
                        "default": true,
                        "description": "If True, prevents HTML encoding of special characters in rule descriptions. Recommended to set to True for cleaner text output. Please provide a value of type boolean.",
                        "examples": [],
                        "title": "Raw Json",
                        "type": "boolean"
                      },
                      "subreddit": {
                        "description": "Name of the subreddit (without 'r/' prefix) for which to retrieve posting rules. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "python",
                          "AskReddit",
                          "technology"
                        ],
                        "title": "Subreddit",
                        "type": "string"
                      }
                    },
                    "description": "Fetch the explicit posting rules for a subreddit to ensure compliance before posting or commenting. Use when you need to verify content meets community guidelines or explain subreddit requirements to users.",
                    "display_description": "Fetch the explicit posting rules for a subreddit to ensure compliance before posting or commenting. Use when you need to verify content meets community guidelines or explain subreddit requirements to users.",
                    "display_name": "Get subreddit rules",
                    "name": "reddit_get_subreddit_rules",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "REDDIT_GET_SUBREDDIT_RULES"
                    ]
                  },
                  {
                    "_uniqueId": "REDDIT_GET_SUBREDDITS_SEARCH_Search subreddits_11",
                    "args": {
                      "after": {
                        "default": null,
                        "description": "Fullname of a thing - pagination cursor for the next page. Use the 'after' value from the previous response to get the next set of results.",
                        "examples": [
                          "t5_2qh1i"
                        ],
                        "title": "After",
                        "type": "string"
                      },
                      "before": {
                        "default": null,
                        "description": "Fullname of a thing - pagination cursor for the previous page. Use the 'before' value from the previous response to get the previous set of results.",
                        "examples": [
                          "t5_2qh1i"
                        ],
                        "title": "Before",
                        "type": "string"
                      },
                      "count": {
                        "default": null,
                        "description": "A positive integer (default: 0) representing the number of items already seen in previous pages. Used for pagination tracking.",
                        "examples": [
                          0,
                          10,
                          25
                        ],
                        "title": "Count",
                        "type": "string"
                      },
                      "limit": {
                        "default": 25,
                        "description": "The maximum number of subreddits to return. Default is 25. Maximum allowed value is 100. Please provide a value of type integer.",
                        "examples": [
                          10,
                          25,
                          50,
                          100
                        ],
                        "title": "Limit",
                        "type": "integer"
                      },
                      "q": {
                        "description": "A search query term to search subreddit titles and descriptions. Use specific keywords to find relevant subreddits. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "python",
                          "programming",
                          "artificial intelligence"
                        ],
                        "title": "Q",
                        "type": "string"
                      },
                      "show": {
                        "default": null,
                        "description": "The string 'all' to show all subreddits including those the user might have filtered.",
                        "examples": [
                          "all"
                        ],
                        "title": "Show",
                        "type": "string"
                      },
                      "show_users": {
                        "default": null,
                        "description": "Boolean value to include user results in the search. Set to true to include users matching the search query.",
                        "examples": [],
                        "title": "Show Users",
                        "type": "string"
                      },
                      "sort": {
                        "default": "relevance",
                        "description": "Sort order for the search results. 'relevance' sorts by relevance to the query (default). 'activity' sorts by subreddit activity. Please provide a value of type string.",
                        "examples": [
                          "relevance",
                          "activity"
                        ],
                        "title": "Sort",
                        "type": "string"
                      },
                      "sr_detail": {
                        "default": null,
                        "description": "Expand subreddits with additional details. Set to true to get more detailed information about each subreddit.",
                        "examples": [],
                        "title": "Sr Detail",
                        "type": "string"
                      }
                    },
                    "description": "Tool to search subreddits by title and description. Use when you need to find subreddits matching a specific topic or keyword. Returns a paginated listing of subreddits with their details including subscribers, descriptions, and other metadata.",
                    "display_description": "Tool to search subreddits by title and description. Use when you need to find subreddits matching a specific topic or keyword. Returns a paginated listing of subreddits with their details including subscribers, descriptions, and other metadata.",
                    "display_name": "Search subreddits",
                    "name": "reddit_get_subreddits_search",
                    "readonly": true,
                    "status": true,
                    "tags": [
                      "REDDIT_GET_SUBREDDITS_SEARCH"
                    ]
                  },
                  {
                    "_uniqueId": "REDDIT_GET_USER_FLAIR_Get user flair_12",
                    "args": {
                      "subreddit": {
                        "description": "Name of the subreddit (e.g., 'pics', 'gaming') for which to retrieve user flair assignments. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "learnpython",
                          "datascience",
                          "announcements"
                        ],
                        "title": "Subreddit",
                        "type": "string"
                      }
                    },
                    "description": "Fetches the list of user flair assignments for a given subreddit. Returns paginated results with user flair details.",
                    "display_description": "Fetches the list of user flair assignments for a given subreddit. Returns paginated results with user flair details.",
                    "display_name": "Get user flair",
                    "name": "reddit_get_user_flair",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "REDDIT_GET_USER_FLAIR"
                    ]
                  },
                  {
                    "_uniqueId": "REDDIT_GET_USERNAME_AVAILABLE_Check username availability_13",
                    "args": {
                      "user": {
                        "description": "The username to check for availability. Must be a valid, unused username string. Usernames are case-insensitive and must be between 3-20 characters. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "testuser123",
                          "example_username"
                        ],
                        "title": "User",
                        "type": "string"
                      }
                    },
                    "description": "Tool to check whether a username is available for registration on Reddit. Use when you need to verify if a username can be used to create a new account.",
                    "display_description": "Tool to check whether a username is available for registration on Reddit. Use when you need to verify if a username can be used to create a new account.",
                    "display_name": "Check username availability",
                    "name": "reddit_get_username_available",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "REDDIT_GET_USERNAME_AVAILABLE"
                    ]
                  },
                  {
                    "_uniqueId": "REDDIT_LIST_SUBREDDIT_POST_FLAIRS_List subreddit post flairs_14",
                    "args": {
                      "subreddit": {
                        "description": "The name of the subreddit (without 'r/' prefix) for which to retrieve available post/link flairs. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "learnpython",
                          "AskReddit",
                          "pics"
                        ],
                        "title": "Subreddit",
                        "type": "string"
                      }
                    },
                    "description": "List available link/post flairs for a subreddit (including flair_template_id) so posts can satisfy flair-required validation. Use when you need to discover valid flair IDs before creating a post in a subreddit that requires flair. Note: Reddit may return empty or deny access if the authenticated user cannot set link flair and is not a moderator.",
                    "display_description": "List available link/post flairs for a subreddit (including flair_template_id) so posts can satisfy flair-required validation. Use when you need to discover valid flair IDs before creating a post in a subreddit that requires flair. Note: Reddit may return empty or deny access if the authenticated user cannot set link flair and is not a moderator.",
                    "display_name": "List subreddit post flairs",
                    "name": "reddit_list_subreddit_post_flairs",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "REDDIT_LIST_SUBREDDIT_POST_FLAIRS"
                    ]
                  },
                  {
                    "_uniqueId": "REDDIT_POST_REDDIT_COMMENT_Post a comment_15",
                    "args": {
                      "text": {
                        "description": "REQUIRED. The raw Markdown text of the comment to be submitted. This field must be provided and cannot be empty. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "This is an insightful comment!",
                          "I agree completely."
                        ],
                        "title": "Text",
                        "type": "string"
                      },
                      "thing_id": {
                        "description": "REQUIRED. The ID of the parent post (link) or comment, prefixed with 't3_' for a post (e.g., 't3_10omtdx') or 't1_' for a comment (e.g., 't1_h2g9w8l'). This field must be provided. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "t3_10omtdx",
                          "t1_h2g9w8l"
                        ],
                        "title": "Thing Id",
                        "type": "string"
                      }
                    },
                    "description": "Posts a comment on Reddit, replying to an existing and accessible submission (post) or another comment.",
                    "display_description": "Posts a comment on Reddit, replying to an existing and accessible submission (post) or another comment.",
                    "display_name": "Post a comment",
                    "name": "reddit_post_reddit_comment",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "REDDIT_POST_REDDIT_COMMENT"
                    ]
                  },
                  {
                    "_uniqueId": "REDDIT_RETRIEVE_POST_COMMENTS_Retrieve Comments for a Post_16",
                    "args": {
                      "article": {
                        "description": "Base-36 ID of the Reddit post (e.g., 'q5u7q5'), typically found in the post's URL and not including the 't3_' prefix. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "q5u7q5",
                          "13a9zao"
                        ],
                        "title": "Article",
                        "type": "string"
                      }
                    },
                    "description": "Retrieves all comments for a Reddit post given its article ID (which must be for an existing, public post); nested replies within comments are returned as raw dictionaries requiring parsing.",
                    "display_description": "Retrieves all comments for a Reddit post given its article ID (which must be for an existing, public post); nested replies within comments are returned as raw dictionaries requiring parsing.",
                    "display_name": "Retrieve Comments for a Post",
                    "name": "reddit_retrieve_post_comments",
                    "readonly": true,
                    "status": true,
                    "tags": [
                      "REDDIT_RETRIEVE_POST_COMMENTS"
                    ]
                  },
                  {
                    "_uniqueId": "REDDIT_RETRIEVE_REDDIT_POST_Retrieve posts from subreddit_17",
                    "args": {
                      "size": {
                        "default": 5,
                        "description": "The maximum number of posts to return. Default is 5. Set to 0 to retrieve the maximum allowed by the Reddit API (100 posts). Valid range: 0-100.",
                        "examples": [
                          5,
                          10,
                          0,
                          25
                        ],
                        "title": "Size",
                        "type": "string"
                      },
                      "subreddit": {
                        "description": "The name of the subreddit from which to retrieve posts (e.g., 'popular', 'pics'). Do not include 'r/'. Subreddit names can only contain letters, numbers, and underscores, with no spaces or special characters. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "technology",
                          "python",
                          "news"
                        ],
                        "title": "Subreddit",
                        "type": "string"
                      }
                    },
                    "description": "Retrieves the current hot posts from a specified, publicly accessible subreddit.",
                    "display_description": "Retrieves the current hot posts from a specified, publicly accessible subreddit.",
                    "display_name": "Retrieve posts from subreddit",
                    "name": "reddit_retrieve_reddit_post",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "REDDIT_RETRIEVE_REDDIT_POST"
                    ]
                  },
                  {
                    "_uniqueId": "REDDIT_RETRIEVE_SPECIFIC_COMMENT_Retrieve specific comment or post_18",
                    "args": {
                      "id": {
                        "description": "Reddit fullname identifier. Format: type prefix (t1_ for comments, t3_ for posts) followed by a base36 ID. Examples: 't1_abc123', 't3_1abc2de'. Note: Share URL tokens from reddit.com/r/.../s/... links are NOT valid fullnames and cannot be used directly. Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "t1_abc123",
                          "t3_1abc2de"
                        ],
                        "title": "Id",
                        "type": "string"
                      }
                    },
                    "description": "Retrieves detailed information for a specific Reddit comment or post using its fullname.",
                    "display_description": "Retrieves detailed information for a specific Reddit comment or post using its fullname.",
                    "display_name": "Retrieve specific comment or post",
                    "name": "reddit_retrieve_specific_comment",
                    "readonly": true,
                    "status": true,
                    "tags": [
                      "REDDIT_RETRIEVE_SPECIFIC_COMMENT"
                    ]
                  },
                  {
                    "_uniqueId": "REDDIT_SEARCH_ACROSS_SUBREDDITS_Search across subreddits_19",
                    "args": {
                      "limit": {
                        "default": 5,
                        "description": "The maximum number of search results to return. Default is 5. Maximum allowed value is 100. Please provide a value of type integer.",
                        "examples": [
                          "5",
                          "10",
                          "25"
                        ],
                        "title": "Limit",
                        "type": "integer"
                      },
                      "restrict_sr": {
                        "default": true,
                        "description": "If True (default), confines the search to posts and comments within subreddits. If False, the search scope is broader and may include matching subreddit names or other Reddit entities. Please provide a value of type boolean.",
                        "examples": [
                          true,
                          false
                        ],
                        "title": "Restrict Sr",
                        "type": "boolean"
                      },
                      "search_query": {
                        "description": "The search query string. Supports Reddit search operators: 'title:', 'author:', 'subreddit:', 'url:', 'site:', 'flair:', 'self:yes/no', 'nsfw:yes/no', and boolean operators (AND, OR, NOT). Raw URLs (starting with http:// or https://) are not allowed - use the 'url:' or 'site:' operators instead (e.g., 'url:example.com' to find posts linking to that domain). Please provide a value of type string. This parameter is required.",
                        "examples": [
                          "latest AI research",
                          "funny cat videos",
                          "url:youtube.com",
                          "site:imgur.com"
                        ],
                        "title": "Search Query",
                        "type": "string"
                      },
                      "sort": {
                        "default": "relevance",
                        "description": "The criterion for sorting search results. 'relevance' (default) sorts by relevance to the query. 'hot' sorts by trending posts with recent upvotes and activity. 'new' sorts by newest first. 'top' sorts by highest score (typically all-time). 'comments' sorts by the number of comments. Please provide a value of type string.",
                        "examples": [
                          "relevance",
                          "hot",
                          "new",
                          "top",
                          "comments"
                        ],
                        "title": "Sort",
                        "type": "string"
                      }
                    },
                    "description": "Searches Reddit for content (e.g., posts, comments) using a query, with results typically confined to subreddits unless `restrict_sr` is set to False.",
                    "display_description": "Searches Reddit for content (e.g., posts, comments) using a query, with results typically confined to subreddits unless `restrict_sr` is set to False.",
                    "display_name": "Search across subreddits",
                    "name": "reddit_search_across_subreddits",
                    "readonly": true,
                    "status": false,
                    "tags": [
                      "REDDIT_SEARCH_ACROSS_SUBREDDITS"
                    ]
                  }
                ]
              },
              "verification_token": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Verification Token",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "verification_token",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": true
          },
          "showNode": true,
          "type": "ComposioRedditAPIComponent"
        },
        "dragging": false,
        "id": "ComposioRedditAPIComponent-9G8UX",
        "measured": {
          "height": 393,
          "width": 320
        },
        "position": {
          "x": -1075.1207885710587,
          "y": 1142.123709502638
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Agent-XqPFn",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Define the agent's instructions, then enter a task to complete using tools.",
            "display_name": "Agent",
            "documentation": "https://docs.langflow.org/agents",
            "edited": false,
            "field_order": [
              "model",
              "api_key",
              "system_prompt",
              "context_id",
              "n_messages",
              "format_instructions",
              "output_schema",
              "tools",
              "input_value",
              "handle_parsing_errors",
              "verbose",
              "max_iterations",
              "agent_description",
              "add_current_date_tool"
            ],
            "frozen": false,
            "icon": "bot",
            "last_updated": "2026-01-29T00:38:25.132Z",
            "legacy": false,
            "lf_version": "1.8.0",
            "metadata": {
              "code_hash": "b60d28d2784f",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "pydantic",
                    "version": "2.11.10"
                  },
                  {
                    "name": "lfx",
                    "version": null
                  },
                  {
                    "name": "langchain_core",
                    "version": "0.3.83"
                  }
                ],
                "total_dependencies": 3
              },
              "module": "custom_components.agent"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Response",
                "group_outputs": false,
                "hidden": null,
                "loop_types": null,
                "method": "message_response",
                "name": "response",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_frontend_node_flow_id": {
                "input_types": [],
                "value": "3fd2a061-6f21-4b25-8a3c-0bbb1e47fc6c"
              },
              "_frontend_node_folder_id": {
                "input_types": [],
                "value": "a265ce36-7e1f-43cb-9964-16a87b09def2"
              },
              "_type": "Component",
              "add_current_date_tool": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Current Date",
                "dynamic": false,
                "info": "If true, will add a tool to the agent that returns the current date.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "add_current_date_tool",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": true
              },
              "agent_description": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "ai_enabled": false,
                "copy_field": false,
                "display_name": "Agent Description [Deprecated]",
                "dynamic": false,
                "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "agent_description",
                "override_skip": false,
                "password": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "A helpful assistant with access to the following tools:"
              },
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": true,
                "display_name": "API Key",
                "dynamic": false,
                "info": "Model Provider API key",
                "input_types": [],
                "load_from_db": true,
                "name": "api_key",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from __future__ import annotations\n\nimport json\nimport re\nfrom typing import TYPE_CHECKING\n\nfrom pydantic import ValidationError\n\nfrom lfx.components.models_and_agents.memory import MemoryComponent\n\nif TYPE_CHECKING:\n    from langchain_core.tools import Tool\n\nfrom lfx.base.agents.agent import LCToolsAgentComponent\nfrom lfx.base.agents.events import ExceptionWithMessageError\nfrom lfx.base.models.unified_models import (\n    get_language_model_options,\n    get_llm,\n    update_model_options_in_build_config,\n)\nfrom lfx.components.helpers import CurrentDateComponent\nfrom lfx.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\nfrom lfx.custom.custom_component.component import get_component_toolkit\nfrom lfx.helpers.base_model import build_model_from_schema\nfrom lfx.inputs.inputs import BoolInput, ModelInput\nfrom lfx.io import IntInput, MessageTextInput, MultilineInput, Output, SecretStrInput, TableInput\nfrom lfx.log.logger import logger\nfrom lfx.schema.data import Data\nfrom lfx.schema.dotdict import dotdict\nfrom lfx.schema.message import Message\nfrom lfx.schema.table import EditMode\n\n\ndef set_advanced_true(component_input):\n    component_input.advanced = True\n    return component_input\n\n\nclass AgentComponent(ToolCallingAgentComponent):\n    display_name: str = \"Agent\"\n    description: str = \"Define the agent's instructions, then enter a task to complete using tools.\"\n    documentation: str = \"https://docs.langflow.org/agents\"\n    icon = \"bot\"\n    beta = False\n    name = \"Agent\"\n\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\n\n    inputs = [\n        ModelInput(\n            name=\"model\",\n            display_name=\"Language Model\",\n            info=\"Select your model provider\",\n            real_time_refresh=True,\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"API Key\",\n            info=\"Model Provider API key\",\n            real_time_refresh=True,\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"system_prompt\",\n            display_name=\"Agent Instructions\",\n            info=\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\",\n            value=\"You are a helpful assistant that can use tools to answer questions and perform tasks.\",\n            advanced=False,\n        ),\n        MessageTextInput(\n            name=\"context_id\",\n            display_name=\"Context ID\",\n            info=\"The context ID of the chat. Adds an extra layer to the local memory.\",\n            value=\"\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"n_messages\",\n            display_name=\"Number of Chat History Messages\",\n            value=100,\n            info=\"Number of chat history messages to retrieve.\",\n            advanced=True,\n            show=True,\n        ),\n        MultilineInput(\n            name=\"format_instructions\",\n            display_name=\"Output Format Instructions\",\n            info=\"Generic Template for structured output formatting. Valid only with Structured response.\",\n            value=(\n                \"You are an AI that extracts structured JSON objects from unstructured text. \"\n                \"Use a predefined schema with expected types (str, int, float, bool, dict). \"\n                \"Extract ALL relevant instances that match the schema - if multiple patterns exist, capture them all. \"\n                \"Fill missing or ambiguous values with defaults: null for missing values. \"\n                \"Remove exact duplicates but keep variations that have different field values. \"\n                \"Always return valid JSON in the expected format, never throw errors. \"\n                \"If multiple objects can be extracted, return them all in the structured format.\"\n            ),\n            advanced=True,\n        ),\n        TableInput(\n            name=\"output_schema\",\n            display_name=\"Output Schema\",\n            info=(\n                \"Schema Validation: Define the structure and data types for structured output. \"\n                \"No validation if no output schema.\"\n            ),\n            advanced=True,\n            required=False,\n            value=[],\n            table_schema=[\n                {\n                    \"name\": \"name\",\n                    \"display_name\": \"Name\",\n                    \"type\": \"str\",\n                    \"description\": \"Specify the name of the output field.\",\n                    \"default\": \"field\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n                {\n                    \"name\": \"description\",\n                    \"display_name\": \"Description\",\n                    \"type\": \"str\",\n                    \"description\": \"Describe the purpose of the output field.\",\n                    \"default\": \"description of field\",\n                    \"edit_mode\": EditMode.POPOVER,\n                },\n                {\n                    \"name\": \"type\",\n                    \"display_name\": \"Type\",\n                    \"type\": \"str\",\n                    \"edit_mode\": EditMode.INLINE,\n                    \"description\": (\"Indicate the data type of the output field (e.g., str, int, float, bool, dict).\"),\n                    \"options\": [\"str\", \"int\", \"float\", \"bool\", \"dict\"],\n                    \"default\": \"str\",\n                },\n                {\n                    \"name\": \"multiple\",\n                    \"display_name\": \"As List\",\n                    \"type\": \"boolean\",\n                    \"description\": \"Set to True if this output field should be a list of the specified type.\",\n                    \"default\": \"False\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n            ],\n        ),\n        *LCToolsAgentComponent.get_base_inputs(),\n        # removed memory inputs from agent component\n        # *memory_inputs,\n        BoolInput(\n            name=\"add_current_date_tool\",\n            display_name=\"Current Date\",\n            advanced=True,\n            info=\"If true, will add a tool to the agent that returns the current date.\",\n            value=True,\n        ),\n    ]\n    outputs = [\n        Output(name=\"response\", display_name=\"Response\", method=\"message_response\"),\n    ]\n\n    async def get_agent_requirements(self):\n        \"\"\"Get the agent requirements for the agent.\"\"\"\n        from langchain_core.tools import StructuredTool\n\n        llm_model = get_llm(\n            model=self.model,\n            user_id=self.user_id,\n            api_key=self.api_key,\n        )\n        if llm_model is None:\n            msg = \"No language model selected. Please choose a model to proceed.\"\n            raise ValueError(msg)\n\n        # Get memory data\n        self.chat_history = await self.get_memory_data()\n        await logger.adebug(f\"Retrieved {len(self.chat_history)} chat history messages\")\n        if isinstance(self.chat_history, Message):\n            self.chat_history = [self.chat_history]\n\n        # Add current date tool if enabled\n        if self.add_current_date_tool:\n            if not isinstance(self.tools, list):  # type: ignore[has-type]\n                self.tools = []\n            current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\n\n            if not isinstance(current_date_tool, StructuredTool):\n                msg = \"CurrentDateComponent must be converted to a StructuredTool\"\n                raise TypeError(msg)\n            self.tools.append(current_date_tool)\n\n        # Set shared callbacks for tracing the tools used by the agent\n        self.set_tools_callbacks(self.tools, self._get_shared_callbacks())\n\n        return llm_model, self.chat_history, self.tools\n\n    async def message_response(self) -> Message:\n        try:\n            llm_model, self.chat_history, self.tools = await self.get_agent_requirements()\n            # Set up and run agent\n            self.set(\n                llm=llm_model,\n                tools=self.tools or [],\n                chat_history=self.chat_history,\n                input_value=self.input_value,\n                system_prompt=self.system_prompt,\n            )\n            agent = self.create_agent_runnable()\n            result = await self.run_agent(agent)\n\n            # Store result for potential JSON output\n            self._agent_result = result\n\n        except (ValueError, TypeError, KeyError) as e:\n            await logger.aerror(f\"{type(e).__name__}: {e!s}\")\n            raise\n        except ExceptionWithMessageError as e:\n            await logger.aerror(f\"ExceptionWithMessageError occurred: {e}\")\n            raise\n        # Avoid catching blind Exception; let truly unexpected exceptions propagate\n        except Exception as e:\n            await logger.aerror(f\"Unexpected error: {e!s}\")\n            raise\n        else:\n            return result\n\n    def _preprocess_schema(self, schema):\n        \"\"\"Preprocess schema to ensure correct data types for build_model_from_schema.\"\"\"\n        processed_schema = []\n        for field in schema:\n            processed_field = {\n                \"name\": str(field.get(\"name\", \"field\")),\n                \"type\": str(field.get(\"type\", \"str\")),\n                \"description\": str(field.get(\"description\", \"\")),\n                \"multiple\": field.get(\"multiple\", False),\n            }\n            # Ensure multiple is handled correctly\n            if isinstance(processed_field[\"multiple\"], str):\n                processed_field[\"multiple\"] = processed_field[\"multiple\"].lower() in [\n                    \"true\",\n                    \"1\",\n                    \"t\",\n                    \"y\",\n                    \"yes\",\n                ]\n            processed_schema.append(processed_field)\n        return processed_schema\n\n    async def build_structured_output_base(self, content: str):\n        \"\"\"Build structured output with optional BaseModel validation.\"\"\"\n        json_pattern = r\"\\{.*\\}\"\n        schema_error_msg = \"Try setting an output schema\"\n\n        # Try to parse content as JSON first\n        json_data = None\n        try:\n            json_data = json.loads(content)\n        except json.JSONDecodeError:\n            json_match = re.search(json_pattern, content, re.DOTALL)\n            if json_match:\n                try:\n                    json_data = json.loads(json_match.group())\n                except json.JSONDecodeError:\n                    return {\"content\": content, \"error\": schema_error_msg}\n            else:\n                return {\"content\": content, \"error\": schema_error_msg}\n\n        # If no output schema provided, return parsed JSON without validation\n        if not hasattr(self, \"output_schema\") or not self.output_schema or len(self.output_schema) == 0:\n            return json_data\n\n        # Use BaseModel validation with schema\n        try:\n            processed_schema = self._preprocess_schema(self.output_schema)\n            output_model = build_model_from_schema(processed_schema)\n\n            # Validate against the schema\n            if isinstance(json_data, list):\n                # Multiple objects\n                validated_objects = []\n                for item in json_data:\n                    try:\n                        validated_obj = output_model.model_validate(item)\n                        validated_objects.append(validated_obj.model_dump())\n                    except ValidationError as e:\n                        await logger.aerror(f\"Validation error for item: {e}\")\n                        # Include invalid items with error info\n                        validated_objects.append({\"data\": item, \"validation_error\": str(e)})\n                return validated_objects\n\n            # Single object\n            try:\n                validated_obj = output_model.model_validate(json_data)\n                return [validated_obj.model_dump()]  # Return as list for consistency\n            except ValidationError as e:\n                await logger.aerror(f\"Validation error: {e}\")\n                return [{\"data\": json_data, \"validation_error\": str(e)}]\n\n        except (TypeError, ValueError) as e:\n            await logger.aerror(f\"Error building structured output: {e}\")\n            # Fallback to parsed JSON without validation\n            return json_data\n\n    async def json_response(self) -> Data:\n        \"\"\"Convert agent response to structured JSON Data output with schema validation.\"\"\"\n        # Always use structured chat agent for JSON response mode for better JSON formatting\n        try:\n            system_components = []\n\n            # 1. Agent Instructions (system_prompt)\n            agent_instructions = getattr(self, \"system_prompt\", \"\") or \"\"\n            if agent_instructions:\n                system_components.append(f\"{agent_instructions}\")\n\n            # 2. Format Instructions\n            format_instructions = getattr(self, \"format_instructions\", \"\") or \"\"\n            if format_instructions:\n                system_components.append(f\"Format instructions: {format_instructions}\")\n\n            # 3. Schema Information from BaseModel\n            if hasattr(self, \"output_schema\") and self.output_schema and len(self.output_schema) > 0:\n                try:\n                    processed_schema = self._preprocess_schema(self.output_schema)\n                    output_model = build_model_from_schema(processed_schema)\n                    schema_dict = output_model.model_json_schema()\n                    schema_info = (\n                        \"You are given some text that may include format instructions, \"\n                        \"explanations, or other content alongside a JSON schema.\\n\\n\"\n                        \"Your task:\\n\"\n                        \"- Extract only the JSON schema.\\n\"\n                        \"- Return it as valid JSON.\\n\"\n                        \"- Do not include format instructions, explanations, or extra text.\\n\\n\"\n                        \"Input:\\n\"\n                        f\"{json.dumps(schema_dict, indent=2)}\\n\\n\"\n                        \"Output (only JSON schema):\"\n                    )\n                    system_components.append(schema_info)\n                except (ValidationError, ValueError, TypeError, KeyError) as e:\n                    await logger.aerror(f\"Could not build schema for prompt: {e}\", exc_info=True)\n\n            # Combine all components\n            combined_instructions = \"\\n\\n\".join(system_components) if system_components else \"\"\n            llm_model, self.chat_history, self.tools = await self.get_agent_requirements()\n            self.set(\n                llm=llm_model,\n                tools=self.tools or [],\n                chat_history=self.chat_history,\n                input_value=self.input_value,\n                system_prompt=combined_instructions,\n            )\n\n            # Create and run structured chat agent\n            try:\n                structured_agent = self.create_agent_runnable()\n            except (NotImplementedError, ValueError, TypeError) as e:\n                await logger.aerror(f\"Error with structured chat agent: {e}\")\n                raise\n            try:\n                result = await self.run_agent(structured_agent)\n            except (\n                ExceptionWithMessageError,\n                ValueError,\n                TypeError,\n                RuntimeError,\n            ) as e:\n                await logger.aerror(f\"Error with structured agent result: {e}\")\n                raise\n            # Extract content from structured agent result\n            if hasattr(result, \"content\"):\n                content = result.content\n            elif hasattr(result, \"text\"):\n                content = result.text\n            else:\n                content = str(result)\n\n        except (\n            ExceptionWithMessageError,\n            ValueError,\n            TypeError,\n            NotImplementedError,\n            AttributeError,\n        ) as e:\n            await logger.aerror(f\"Error with structured chat agent: {e}\")\n            # Fallback to regular agent\n            content_str = \"No content returned from agent\"\n            return Data(data={\"content\": content_str, \"error\": str(e)})\n\n        # Process with structured output validation\n        try:\n            structured_output = await self.build_structured_output_base(content)\n\n            # Handle different output formats\n            if isinstance(structured_output, list) and structured_output:\n                if len(structured_output) == 1:\n                    return Data(data=structured_output[0])\n                return Data(data={\"results\": structured_output})\n            if isinstance(structured_output, dict):\n                return Data(data=structured_output)\n            return Data(data={\"content\": content})\n\n        except (ValueError, TypeError) as e:\n            await logger.aerror(f\"Error in structured output processing: {e}\")\n            return Data(data={\"content\": content, \"error\": str(e)})\n\n    async def get_memory_data(self):\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\n        messages = (\n            await MemoryComponent(**self.get_base_args())\n            .set(\n                session_id=self.graph.session_id,\n                context_id=self.context_id,\n                order=\"Ascending\",\n                n_messages=self.n_messages,\n            )\n            .retrieve_messages()\n        )\n        return [\n            message for message in messages if getattr(message, \"id\", None) != getattr(self.input_value, \"id\", None)\n        ]\n\n    def update_input_types(self, build_config: dotdict) -> dotdict:\n        \"\"\"Update input types for all fields in build_config.\"\"\"\n        for key, value in build_config.items():\n            if isinstance(value, dict):\n                if value.get(\"input_types\") is None:\n                    build_config[key][\"input_types\"] = []\n            elif hasattr(value, \"input_types\") and value.input_types is None:\n                value.input_types = []\n        return build_config\n\n    async def update_build_config(\n        self,\n        build_config: dotdict,\n        field_value: list[dict],\n        field_name: str | None = None,\n    ) -> dotdict:\n        # Update model options with caching (for all field changes)\n        # Agents require tool calling, so filter for only tool-calling capable models\n        def get_tool_calling_model_options(user_id=None):\n            return get_language_model_options(user_id=user_id, tool_calling=True)\n\n        build_config = update_model_options_in_build_config(\n            component=self,\n            build_config=dict(build_config),\n            cache_key_prefix=\"language_model_options_tool_calling\",\n            get_options_func=get_tool_calling_model_options,\n            field_name=field_name,\n            field_value=field_value,\n        )\n        build_config = dotdict(build_config)\n\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\n        if field_name == \"model\":\n            # Update input types for all fields\n            build_config = self.update_input_types(build_config)\n\n            # Validate required keys\n            default_keys = [\n                \"code\",\n                \"_type\",\n                \"model\",\n                \"tools\",\n                \"input_value\",\n                \"add_current_date_tool\",\n                \"system_prompt\",\n                \"agent_description\",\n                \"max_iterations\",\n                \"handle_parsing_errors\",\n                \"verbose\",\n            ]\n            missing_keys = [key for key in default_keys if key not in build_config]\n            if missing_keys:\n                msg = f\"Missing required keys in build_config: {missing_keys}\"\n                raise ValueError(msg)\n        return dotdict({k: v.to_dict() if hasattr(v, \"to_dict\") else v for k, v in build_config.items()})\n\n    async def _get_tools(self) -> list[Tool]:\n        component_toolkit = get_component_toolkit()\n        tools_names = self._build_tools_names()\n        agent_description = self.get_tool_description()\n        # TODO: Agent Description Depreciated Feature to be removed\n        description = f\"{agent_description}{tools_names}\"\n\n        tools = component_toolkit(component=self).get_tools(\n            tool_name=\"Call_Agent\",\n            tool_description=description,\n            # here we do not use the shared callbacks as we are exposing the agent as a tool\n            callbacks=self.get_langchain_callbacks(),\n        )\n        if hasattr(self, \"tools_metadata\"):\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\n\n        return tools\n"
              },
              "context_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Context ID",
                "dynamic": false,
                "info": "The context ID of the chat. Adds an extra layer to the local memory.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "context_id",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "format_instructions": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "ai_enabled": false,
                "copy_field": false,
                "display_name": "Output Format Instructions",
                "dynamic": false,
                "info": "Generic Template for structured output formatting. Valid only with Structured response.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "format_instructions",
                "override_skip": false,
                "password": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "You are an AI that extracts structured JSON objects from unstructured text. Use a predefined schema with expected types (str, int, float, bool, dict). Extract ALL relevant instances that match the schema - if multiple patterns exist, capture them all. Fill missing or ambiguous values with defaults: null for missing values. Remove exact duplicates but keep variations that have different field values. Always return valid JSON in the expected format, never throw errors. If multiple objects can be extracted, return them all in the structured format."
              },
              "handle_parsing_errors": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Handle Parse Errors",
                "dynamic": false,
                "info": "Should the Agent fix errors when reading user input for better processing?",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "handle_parsing_errors",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": true
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "The input provided by the user for the agent to process.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "is_refresh": false,
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "int",
                "value": 15
              },
              "model": {
                "_input_type": "ModelInput",
                "advanced": false,
                "display_name": "Language Model",
                "dynamic": false,
                "external_options": {
                  "fields": {
                    "data": {
                      "node": {
                        "display_name": "Connect other models",
                        "icon": "CornerDownLeft",
                        "name": "connect_other_models"
                      }
                    }
                  }
                },
                "info": "Select your model provider",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "model_type": "language",
                "name": "model",
                "options": [
                  {
                    "category": "Anthropic",
                    "icon": "Anthropic",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatAnthropic",
                      "model_name_param": "model"
                    },
                    "name": "claude-opus-4-5-20251101",
                    "provider": "Anthropic"
                  },
                  {
                    "category": "Anthropic",
                    "icon": "Anthropic",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatAnthropic",
                      "model_name_param": "model"
                    },
                    "name": "claude-haiku-4-5-20251001",
                    "provider": "Anthropic"
                  },
                  {
                    "category": "Anthropic",
                    "icon": "Anthropic",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatAnthropic",
                      "model_name_param": "model"
                    },
                    "name": "claude-sonnet-4-5-20250929",
                    "provider": "Anthropic"
                  },
                  {
                    "category": "Anthropic",
                    "icon": "Anthropic",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatAnthropic",
                      "model_name_param": "model"
                    },
                    "name": "claude-opus-4-1-20250805",
                    "provider": "Anthropic"
                  },
                  {
                    "category": "Anthropic",
                    "icon": "Anthropic",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatAnthropic",
                      "model_name_param": "model"
                    },
                    "name": "claude-opus-4-20250514",
                    "provider": "Anthropic"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model",
                      "reasoning_models": [
                        "gpt-5.1"
                      ]
                    },
                    "name": "gpt-5.1",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model",
                      "reasoning_models": [
                        "gpt-5"
                      ]
                    },
                    "name": "gpt-5",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model",
                      "reasoning_models": [
                        "gpt-5-mini"
                      ]
                    },
                    "name": "gpt-5-mini",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model",
                      "reasoning_models": [
                        "gpt-5-nano"
                      ]
                    },
                    "name": "gpt-5-nano",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model"
                    },
                    "name": "gpt-4o-mini",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model"
                    },
                    "name": "gpt-4o",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model"
                    },
                    "name": "gpt-4-turbo",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model"
                    },
                    "name": "gpt-4",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model"
                    },
                    "name": "gpt-4o-mini-search-preview",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model"
                    },
                    "name": "gpt-4o-search-preview",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "Google Generative AI",
                    "icon": "GoogleGenerativeAI",
                    "metadata": {
                      "api_key_param": "google_api_key",
                      "context_length": 128000,
                      "model_class": "ChatGoogleGenerativeAIFixed",
                      "model_name_param": "model"
                    },
                    "name": "gemini-1.5-pro",
                    "provider": "Google Generative AI"
                  },
                  {
                    "category": "Google Generative AI",
                    "icon": "GoogleGenerativeAI",
                    "metadata": {
                      "api_key_param": "google_api_key",
                      "context_length": 128000,
                      "model_class": "ChatGoogleGenerativeAIFixed",
                      "model_name_param": "model"
                    },
                    "name": "gemini-1.5-flash",
                    "provider": "Google Generative AI"
                  },
                  {
                    "category": "Google Generative AI",
                    "icon": "GoogleGenerativeAI",
                    "metadata": {
                      "api_key_param": "google_api_key",
                      "context_length": 128000,
                      "model_class": "ChatGoogleGenerativeAIFixed",
                      "model_name_param": "model"
                    },
                    "name": "gemini-1.5-flash-8b",
                    "provider": "Google Generative AI"
                  },
                  {
                    "category": "Google Generative AI",
                    "icon": "GoogleGenerativeAI",
                    "metadata": {
                      "api_key_param": "google_api_key",
                      "context_length": 128000,
                      "model_class": "ChatGoogleGenerativeAIFixed",
                      "model_name_param": "model"
                    },
                    "name": "gemini-2.0-flash-lite",
                    "provider": "Google Generative AI"
                  },
                  {
                    "category": "Google Generative AI",
                    "icon": "GoogleGenerativeAI",
                    "metadata": {
                      "api_key_param": "google_api_key",
                      "context_length": 128000,
                      "model_class": "ChatGoogleGenerativeAIFixed",
                      "model_name_param": "model"
                    },
                    "name": "gemini-2.0-flash",
                    "provider": "Google Generative AI"
                  },
                  {
                    "category": "Ollama",
                    "icon": "Ollama",
                    "metadata": {
                      "api_key_param": "base_url",
                      "base_url_param": "base_url",
                      "context_length": 128000,
                      "model_class": "ChatOllama",
                      "model_name_param": "model"
                    },
                    "name": "llama3.3",
                    "provider": "Ollama"
                  },
                  {
                    "category": "Ollama",
                    "icon": "Ollama",
                    "metadata": {
                      "api_key_param": "base_url",
                      "base_url_param": "base_url",
                      "context_length": 128000,
                      "model_class": "ChatOllama",
                      "model_name_param": "model"
                    },
                    "name": "qwq",
                    "provider": "Ollama"
                  },
                  {
                    "category": "Ollama",
                    "icon": "Ollama",
                    "metadata": {
                      "api_key_param": "base_url",
                      "base_url_param": "base_url",
                      "context_length": 128000,
                      "model_class": "ChatOllama",
                      "model_name_param": "model"
                    },
                    "name": "llama3.2",
                    "provider": "Ollama"
                  },
                  {
                    "category": "Ollama",
                    "icon": "Ollama",
                    "metadata": {
                      "api_key_param": "base_url",
                      "base_url_param": "base_url",
                      "context_length": 128000,
                      "model_class": "ChatOllama",
                      "model_name_param": "model"
                    },
                    "name": "llama3.1",
                    "provider": "Ollama"
                  },
                  {
                    "category": "Ollama",
                    "icon": "Ollama",
                    "metadata": {
                      "api_key_param": "base_url",
                      "base_url_param": "base_url",
                      "context_length": 128000,
                      "model_class": "ChatOllama",
                      "model_name_param": "model"
                    },
                    "name": "mistral",
                    "provider": "Ollama"
                  },
                  {
                    "category": "IBM WatsonX",
                    "icon": "IBM",
                    "metadata": {
                      "api_key_param": "apikey",
                      "context_length": 128000,
                      "model_class": "ChatWatsonx",
                      "model_name_param": "model_id",
                      "project_id_param": "project_id",
                      "url_param": "url"
                    },
                    "name": "ibm/granite-3-2b-instruct",
                    "provider": "IBM WatsonX"
                  },
                  {
                    "category": "IBM WatsonX",
                    "icon": "IBM",
                    "metadata": {
                      "api_key_param": "apikey",
                      "context_length": 128000,
                      "model_class": "ChatWatsonx",
                      "model_name_param": "model_id",
                      "project_id_param": "project_id",
                      "url_param": "url"
                    },
                    "name": "ibm/granite-3-8b-instruct",
                    "provider": "IBM WatsonX"
                  },
                  {
                    "category": "IBM WatsonX",
                    "icon": "IBM",
                    "metadata": {
                      "api_key_param": "apikey",
                      "context_length": 128000,
                      "model_class": "ChatWatsonx",
                      "model_name_param": "model_id",
                      "project_id_param": "project_id",
                      "url_param": "url"
                    },
                    "name": "ibm/granite-13b-instruct-v2",
                    "provider": "IBM WatsonX"
                  }
                ],
                "override_skip": false,
                "placeholder": "Setup Provider",
                "real_time_refresh": true,
                "refresh_button": true,
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "track_in_telemetry": false,
                "type": "model",
                "value": [
                  {
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model",
                      "reasoning_models": [
                        "gpt-5-mini"
                      ]
                    },
                    "name": "gpt-5-mini",
                    "provider": "OpenAI"
                  }
                ]
              },
              "n_messages": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Chat History Messages",
                "dynamic": false,
                "info": "Number of chat history messages to retrieve.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "n_messages",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "int",
                "value": 100
              },
              "output_schema": {
                "_input_type": "TableInput",
                "advanced": true,
                "display_name": "Output Schema",
                "dynamic": false,
                "info": "Schema Validation: Define the structure and data types for structured output. No validation if no output schema.",
                "input_types": [],
                "is_list": true,
                "list_add_label": "Add More",
                "name": "output_schema",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "table_icon": "Table",
                "table_schema": [
                  {
                    "default": "field",
                    "description": "Specify the name of the output field.",
                    "display_name": "Name",
                    "edit_mode": "inline",
                    "name": "name",
                    "type": "str"
                  },
                  {
                    "default": "description of field",
                    "description": "Describe the purpose of the output field.",
                    "display_name": "Description",
                    "edit_mode": "popover",
                    "name": "description",
                    "type": "str"
                  },
                  {
                    "default": "str",
                    "description": "Indicate the data type of the output field (e.g., str, int, float, bool, dict).",
                    "display_name": "Type",
                    "edit_mode": "inline",
                    "name": "type",
                    "options": [
                      "str",
                      "int",
                      "float",
                      "bool",
                      "dict"
                    ],
                    "type": "str"
                  },
                  {
                    "default": "False",
                    "description": "Set to True if this output field should be a list of the specified type.",
                    "display_name": "As List",
                    "edit_mode": "inline",
                    "name": "multiple",
                    "type": "boolean"
                  }
                ],
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "trigger_icon": "Table",
                "trigger_text": "Open table",
                "type": "table",
                "value": []
              },
              "system_prompt": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "ai_enabled": false,
                "copy_field": false,
                "display_name": "Agent Instructions",
                "dynamic": false,
                "info": "System Prompt: Initial instructions and context provided to guide the agent's behavior.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_prompt",
                "override_skip": false,
                "password": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "You are a helpful assistant that can use tools to answer questions and perform tasks."
              },
              "tools": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Tools",
                "dynamic": false,
                "info": "These are the tools that the agent can use to help with tasks.",
                "input_types": [
                  "Tool"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "tools",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "other",
                "value": ""
              },
              "verbose": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Verbose",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "verbose",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Agent"
        },
        "dragging": false,
        "id": "Agent-XqPFn",
        "measured": {
          "height": 429,
          "width": 320
        },
        "position": {
          "x": -630.3945290224486,
          "y": 1196.7775758914229
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Prompt Template-EzpCN",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {
              "template": [
                "product-brand-topic",
                "days"
              ]
            },
            "description": "Create a prompt template with dynamic variables.",
            "display_name": "Prompt Template",
            "documentation": "https://docs.langflow.org/components-prompts",
            "edited": false,
            "error": null,
            "field_order": [
              "template",
              "use_double_brackets",
              "tool_placeholder"
            ],
            "frozen": false,
            "full_path": null,
            "icon": "prompts",
            "is_composition": null,
            "is_input": null,
            "is_output": null,
            "legacy": false,
            "lf_version": "1.8.0",
            "metadata": {
              "code_hash": "595f7c9c8463",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "lfx",
                    "version": null
                  }
                ],
                "total_dependencies": 1
              },
              "module": "lfx.components.models_and_agents.prompt.PromptComponent"
            },
            "minimized": false,
            "name": "",
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt",
                "group_outputs": false,
                "hidden": null,
                "loop_types": null,
                "method": "build_prompt",
                "name": "prompt",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": 0,
            "replacement": null,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nfrom lfx.base.prompts.api_utils import process_prompt_template\nfrom lfx.custom.custom_component.component import Component\nfrom lfx.inputs.input_mixin import FieldTypes\nfrom lfx.inputs.inputs import DefaultPromptField\nfrom lfx.io import BoolInput, MessageTextInput, Output, PromptInput\nfrom lfx.log.logger import logger\nfrom lfx.schema.dotdict import dotdict\nfrom lfx.schema.message import Message\nfrom lfx.template.utils import update_template_values\nfrom lfx.utils.mustache_security import validate_mustache_template\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt Template\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    documentation: str = \"https://docs.langflow.org/components-prompts\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt Template\"\n    priority = 0  # Set priority to 0 to make it appear first\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        BoolInput(\n            name=\"use_double_brackets\",\n            display_name=\"Use Double Brackets\",\n            value=False,\n            advanced=True,\n            info=\"Use {{variable}} syntax instead of {variable}.\",\n            real_time_refresh=True,\n        ),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None) -> dotdict:\n        \"\"\"Update the template field type based on the selected mode.\"\"\"\n        if field_name == \"use_double_brackets\":\n            # Change the template field type based on mode\n            is_mustache = field_value is True\n            if is_mustache:\n                build_config[\"template\"][\"type\"] = FieldTypes.MUSTACHE_PROMPT.value\n            else:\n                build_config[\"template\"][\"type\"] = FieldTypes.PROMPT.value\n\n            # Re-process the template to update variables when mode changes\n            template_value = build_config.get(\"template\", {}).get(\"value\", \"\")\n            if template_value:\n                # Ensure custom_fields is properly initialized\n                if \"custom_fields\" not in build_config:\n                    build_config[\"custom_fields\"] = {}\n\n                # Clean up fields from the OLD mode before processing with NEW mode\n                # This ensures we don't keep fields with wrong syntax even if validation fails\n                old_custom_fields = build_config[\"custom_fields\"].get(\"template\", [])\n                for old_field in list(old_custom_fields):\n                    # Remove the field from custom_fields and template\n                    if old_field in old_custom_fields:\n                        old_custom_fields.remove(old_field)\n                    build_config.pop(old_field, None)\n\n                # Try to process template with new mode to add new variables\n                # If validation fails, at least we cleaned up old fields\n                try:\n                    # Validate mustache templates for security\n                    if is_mustache:\n                        validate_mustache_template(template_value)\n\n                    # Re-process template with new mode to add new variables\n                    _ = process_prompt_template(\n                        template=template_value,\n                        name=\"template\",\n                        custom_fields=build_config[\"custom_fields\"],\n                        frontend_node_template=build_config,\n                        is_mustache=is_mustache,\n                    )\n                except ValueError as e:\n                    # If validation fails, we still updated the mode and cleaned old fields\n                    # User will see error when they try to save\n                    logger.debug(f\"Template validation failed during mode switch: {e}\")\n        return build_config\n\n    async def build_prompt(self) -> Message:\n        use_double_brackets = self.use_double_brackets if hasattr(self, \"use_double_brackets\") else False\n        template_format = \"mustache\" if use_double_brackets else \"f-string\"\n        prompt = await Message.from_template_and_variables(template_format=template_format, **self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        use_double_brackets = frontend_node[\"template\"].get(\"use_double_brackets\", {}).get(\"value\", False)\n        is_mustache = use_double_brackets is True\n\n        try:\n            # Validate mustache templates for security\n            if is_mustache:\n                validate_mustache_template(prompt_template)\n\n            custom_fields = frontend_node[\"custom_fields\"]\n            frontend_node_template = frontend_node[\"template\"]\n            _ = process_prompt_template(\n                template=prompt_template,\n                name=\"template\",\n                custom_fields=custom_fields,\n                frontend_node_template=frontend_node_template,\n                is_mustache=is_mustache,\n            )\n        except ValueError as e:\n            # If validation fails, don't add variables but allow component to be created\n            logger.debug(f\"Template validation failed in _update_template: {e}\")\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        use_double_brackets = frontend_node[\"template\"].get(\"use_double_brackets\", {}).get(\"value\", False)\n        is_mustache = use_double_brackets is True\n\n        try:\n            # Validate mustache templates for security\n            if is_mustache:\n                validate_mustache_template(template)\n\n            # Kept it duplicated for backwards compatibility\n            _ = process_prompt_template(\n                template=template,\n                name=\"template\",\n                custom_fields=frontend_node[\"custom_fields\"],\n                frontend_node_template=frontend_node[\"template\"],\n                is_mustache=is_mustache,\n            )\n        except ValueError as e:\n            # If validation fails, don't add variables but allow component to be updated\n            logger.debug(f\"Template validation failed in update_frontend_node: {e}\")\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n"
              },
              "days": {
                "advanced": false,
                "display_name": "days",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "days",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "product-brand-topic": {
                "advanced": false,
                "display_name": "product-brand-topic",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "product-brand-topic",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "template": {
                "_input_type": "PromptInput",
                "advanced": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "template",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "track_in_telemetry": false,
                "type": "prompt",
                "value": "You are a YouTube feedback collector.\n\nTASK:\nCollect video comments about \"{product-brand-topic}\" from the last {days} days using the YouTube tool.\n\nSTEP-BY-STEP INSTRUCTIONS:\n\nSTEP 1 - SEARCH VIDEOS:\n- Use the action \"Search YouTube\" (YOUTUBE_SEARCH_YOU_TUBE)\n- Search parameters:\n  * query: \"{product-brand-topic}\"\n  * type: \"video\"\n  * order: \"date\" (to get most recent)\n  * maxResults: 10\n  * publishedAfter: date from {days} days ago\n\nSTEP 2 - COLLECT COMMENTS:\n- For each video found, use the action \"List Comment Threads\" (YOUTUBE_LIST_COMMENT_THREADS)\n- Parameters:\n  * videoId: [video id found in step 1]\n  * maxResults: 100 (maximum per video)\n  * order: \"time\" (to get most recent if there are more than 100)\n\nSTEP 3 - EXTRACT AND FORMAT:\nFrom each collected comment, extract and format as below.\n\nMANDATORY OUTPUT FORMAT:\nReturn IMMEDIATELY all collected comments, one after another, in this exact format:\n\n---\nSOURCE: YouTube\nVIDEO_ID: [id]\nVIDEO_TITLE: [title]\nLINK: https://youtube.com/watch?v=[video_id]\nAUTHOR: [name]\nDATE: [YYYY-MM-DD]\nLIKES: [number]\nCOMMENT: [full text]\n---\n\nCRITICAL RULES:\n- DO NOT ask the user anything\n- DO NOT offer format or delivery options\n- DO NOT summarize or analyze the data\n- DO NOT explain what you did\n- RETURN ONLY the comments in the format specified above\n- Collect ALL comments found, up to the maximum limit of 100 comments per video\n- If there are more than 100 comments, collect only the 100 most recent\n- If a video has no comments, skip to the next\n- Keep the original comment text without modification\n- Your complete response will be sent directly for automated processing\n\nSTART OUTPUT NOW WITH THE FIRST \"---\" AND END WITH THE LAST \"---\""
              },
              "tool_placeholder": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Tool Placeholder",
                "dynamic": false,
                "info": "A placeholder input for tool mode.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_placeholder",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "use_double_brackets": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Use Double Brackets",
                "dynamic": false,
                "info": "Use {{variable}} syntax instead of {variable}.",
                "list": false,
                "list_add_label": "Add More",
                "name": "use_double_brackets",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": false
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Prompt Template"
        },
        "dragging": false,
        "id": "Prompt Template-EzpCN",
        "measured": {
          "height": 449,
          "width": 320
        },
        "position": {
          "x": -1430.0374774035843,
          "y": 648.5614917028839
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Prompt Template-VqFpy",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {
              "template": [
                "product-brand-topic",
                "days"
              ]
            },
            "description": "Create a prompt template with dynamic variables.",
            "display_name": "Prompt Template",
            "documentation": "https://docs.langflow.org/components-prompts",
            "edited": false,
            "error": null,
            "field_order": [
              "template",
              "use_double_brackets",
              "tool_placeholder"
            ],
            "frozen": false,
            "full_path": null,
            "icon": "prompts",
            "is_composition": null,
            "is_input": null,
            "is_output": null,
            "legacy": false,
            "lf_version": "1.8.0",
            "metadata": {
              "code_hash": "595f7c9c8463",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "lfx",
                    "version": null
                  }
                ],
                "total_dependencies": 1
              },
              "module": "lfx.components.models_and_agents.prompt.PromptComponent"
            },
            "minimized": false,
            "name": "",
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt",
                "group_outputs": false,
                "hidden": null,
                "loop_types": null,
                "method": "build_prompt",
                "name": "prompt",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": 0,
            "replacement": null,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nfrom lfx.base.prompts.api_utils import process_prompt_template\nfrom lfx.custom.custom_component.component import Component\nfrom lfx.inputs.input_mixin import FieldTypes\nfrom lfx.inputs.inputs import DefaultPromptField\nfrom lfx.io import BoolInput, MessageTextInput, Output, PromptInput\nfrom lfx.log.logger import logger\nfrom lfx.schema.dotdict import dotdict\nfrom lfx.schema.message import Message\nfrom lfx.template.utils import update_template_values\nfrom lfx.utils.mustache_security import validate_mustache_template\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt Template\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    documentation: str = \"https://docs.langflow.org/components-prompts\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt Template\"\n    priority = 0  # Set priority to 0 to make it appear first\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        BoolInput(\n            name=\"use_double_brackets\",\n            display_name=\"Use Double Brackets\",\n            value=False,\n            advanced=True,\n            info=\"Use {{variable}} syntax instead of {variable}.\",\n            real_time_refresh=True,\n        ),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None) -> dotdict:\n        \"\"\"Update the template field type based on the selected mode.\"\"\"\n        if field_name == \"use_double_brackets\":\n            # Change the template field type based on mode\n            is_mustache = field_value is True\n            if is_mustache:\n                build_config[\"template\"][\"type\"] = FieldTypes.MUSTACHE_PROMPT.value\n            else:\n                build_config[\"template\"][\"type\"] = FieldTypes.PROMPT.value\n\n            # Re-process the template to update variables when mode changes\n            template_value = build_config.get(\"template\", {}).get(\"value\", \"\")\n            if template_value:\n                # Ensure custom_fields is properly initialized\n                if \"custom_fields\" not in build_config:\n                    build_config[\"custom_fields\"] = {}\n\n                # Clean up fields from the OLD mode before processing with NEW mode\n                # This ensures we don't keep fields with wrong syntax even if validation fails\n                old_custom_fields = build_config[\"custom_fields\"].get(\"template\", [])\n                for old_field in list(old_custom_fields):\n                    # Remove the field from custom_fields and template\n                    if old_field in old_custom_fields:\n                        old_custom_fields.remove(old_field)\n                    build_config.pop(old_field, None)\n\n                # Try to process template with new mode to add new variables\n                # If validation fails, at least we cleaned up old fields\n                try:\n                    # Validate mustache templates for security\n                    if is_mustache:\n                        validate_mustache_template(template_value)\n\n                    # Re-process template with new mode to add new variables\n                    _ = process_prompt_template(\n                        template=template_value,\n                        name=\"template\",\n                        custom_fields=build_config[\"custom_fields\"],\n                        frontend_node_template=build_config,\n                        is_mustache=is_mustache,\n                    )\n                except ValueError as e:\n                    # If validation fails, we still updated the mode and cleaned old fields\n                    # User will see error when they try to save\n                    logger.debug(f\"Template validation failed during mode switch: {e}\")\n        return build_config\n\n    async def build_prompt(self) -> Message:\n        use_double_brackets = self.use_double_brackets if hasattr(self, \"use_double_brackets\") else False\n        template_format = \"mustache\" if use_double_brackets else \"f-string\"\n        prompt = await Message.from_template_and_variables(template_format=template_format, **self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        use_double_brackets = frontend_node[\"template\"].get(\"use_double_brackets\", {}).get(\"value\", False)\n        is_mustache = use_double_brackets is True\n\n        try:\n            # Validate mustache templates for security\n            if is_mustache:\n                validate_mustache_template(prompt_template)\n\n            custom_fields = frontend_node[\"custom_fields\"]\n            frontend_node_template = frontend_node[\"template\"]\n            _ = process_prompt_template(\n                template=prompt_template,\n                name=\"template\",\n                custom_fields=custom_fields,\n                frontend_node_template=frontend_node_template,\n                is_mustache=is_mustache,\n            )\n        except ValueError as e:\n            # If validation fails, don't add variables but allow component to be created\n            logger.debug(f\"Template validation failed in _update_template: {e}\")\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        use_double_brackets = frontend_node[\"template\"].get(\"use_double_brackets\", {}).get(\"value\", False)\n        is_mustache = use_double_brackets is True\n\n        try:\n            # Validate mustache templates for security\n            if is_mustache:\n                validate_mustache_template(template)\n\n            # Kept it duplicated for backwards compatibility\n            _ = process_prompt_template(\n                template=template,\n                name=\"template\",\n                custom_fields=frontend_node[\"custom_fields\"],\n                frontend_node_template=frontend_node[\"template\"],\n                is_mustache=is_mustache,\n            )\n        except ValueError as e:\n            # If validation fails, don't add variables but allow component to be updated\n            logger.debug(f\"Template validation failed in update_frontend_node: {e}\")\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n"
              },
              "days": {
                "advanced": false,
                "display_name": "days",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "days",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "product-brand-topic": {
                "advanced": false,
                "display_name": "product-brand-topic",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "product-brand-topic",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "template": {
                "_input_type": "PromptInput",
                "advanced": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "template",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "track_in_telemetry": false,
                "type": "prompt",
                "value": "You are a Reddit feedback collector.\n\nTASK:\nCollect posts and comments about \"{product-brand-topic}\" from the last {days} days using the Reddit tool.\n\nSTEP-BY-STEP INSTRUCTIONS:\n\nSTEP 1 - SEARCH STRATEGY (execute automatically in this order):\n\nATTEMPT 1: Search with full query \"{product-brand-topic}\"\n- Use the action \"Search Subreddits\" (REDDIT_GET_SUBREDDIT...)\n- If results are found, proceed to STEP 2\n\nATTEMPT 2: If ATTEMPT 1 returns no results, search separately:\n- Search for each keyword individually\n- Example: if \"{product-brand-topic}\" = \"Langflow IBM\", search \"Langflow\" AND \"IBM\"\n\nATTEMPT 3: If ATTEMPT 2 does not return sufficient results:\n- Search in relevant default subreddits: r/MachineLearning, r/ArtificialIntelligence, r/programming, r/opensource, r/technology, r/datascience\n- Look for posts that mention \"{product-brand-topic}\" or related keywords\n\nSTEP 2 - SEARCH POSTS:\n- In each subreddit found, search for posts published in the last {days} days\n- Filter posts that mention \"{product-brand-topic}\" or related keywords\n- Prioritize posts with more engagement (comments and score)\n\nSTEP 3 - COLLECT POST COMMENTS:\n- For each relevant post, use the action \"Retrieve Comments For A Post\" (REDDIT_RETRIEVE_POST_...)\n- Parameters:\n  * article: [post ID]\n  * limit: 100 (maximum per post)\n  * sort: \"top\"\n\nMANDATORY OUTPUT FORMAT:\nReturn IMMEDIATELY all collected items in this exact format:\n\n---\nSOURCE: Reddit\nSUBREDDIT: r/[name]\nTYPE: [post/comment]\nPOST_ID: [id]\nLINK: https://reddit.com/r/[subreddit]/comments/[post_id]\nAUTHOR: u/[username]\nDATE: [YYYY-MM-DD]\nSCORE: [upvotes]\nPOST_TITLE: [if post, include title]\nCONTENT: [full text of post or comment]\n---\n\nCRITICAL RULES - READ CAREFULLY:\n- DO NOT ask the user anything\n- DO NOT offer search options or strategies\n- DO NOT explain your strategy or what you did\n- AUTOMATICALLY execute search attempts in sequence until finding results\n- If no attempt returns results, return only: \"NO RESULTS FOUND\"\n- Collect ALL items found, up to the maximum limit of 100 items\n- If there are more than 100 items, collect only the 100 with highest score or most recent\n- Include both posts and relevant comments\n- Keep original text without modification\n- Your response will be sent directly for automated processing\n\nSTART OUTPUT NOW WITH THE FIRST \"---\" AND END WITH THE LAST \"---\""
              },
              "tool_placeholder": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Tool Placeholder",
                "dynamic": false,
                "info": "A placeholder input for tool mode.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_placeholder",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "use_double_brackets": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Use Double Brackets",
                "dynamic": false,
                "info": "Use {{variable}} syntax instead of {variable}.",
                "list": false,
                "list_add_label": "Add More",
                "name": "use_double_brackets",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": false
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Prompt Template"
        },
        "dragging": false,
        "id": "Prompt Template-VqFpy",
        "measured": {
          "height": 449,
          "width": 320
        },
        "position": {
          "x": -1433.4836194986071,
          "y": 1160.359056933444
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "TextInput-gl8uw",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Get user text inputs.",
            "display_name": "Product / Brand / Topic",
            "documentation": "https://docs.langflow.org/text-input-and-output",
            "edited": false,
            "field_order": [
              "input_value",
              "use_global_variable"
            ],
            "frozen": false,
            "icon": "type",
            "legacy": false,
            "lf_version": "1.8.0",
            "metadata": {
              "code_hash": "518f16485886",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "lfx",
                    "version": null
                  }
                ],
                "total_dependencies": 1
              },
              "module": "custom_components.text_input"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Output Text",
                "group_outputs": false,
                "loop_types": null,
                "method": "text_response",
                "name": "text",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nfrom lfx.base.io.text import TextComponent\nfrom lfx.io import BoolInput, MultilineInput, Output\nfrom lfx.schema.message import Message\n\n\nclass TextInputComponent(TextComponent):\n    display_name = \"Text Input\"\n    description = \"Get user text inputs.\"\n    documentation: str = \"https://docs.langflow.org/text-input-and-output\"\n    icon = \"type\"\n    name = \"TextInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as input.\",\n        ),\n        BoolInput(\n            name=\"use_global_variable\",\n            display_name=\"Use Global Variable\",\n            info=\"Enable to select from global variables (shows globe icon). Disables multiline editing.\",\n            value=False,\n            advanced=True,\n            real_time_refresh=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Output Text\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def update_build_config(self, build_config: dict, field_value: Any, field_name: str | None = None) -> dict:\n        if field_name == \"use_global_variable\":\n            if field_value:\n                # Enable global variable mode: single-line with password masking and globe dropdown\n                build_config[\"input_value\"][\"multiline\"] = False\n                build_config[\"input_value\"][\"password\"] = True\n            else:\n                # Default mode: multiline text editing\n                build_config[\"input_value\"][\"multiline\"] = True\n                build_config[\"input_value\"][\"password\"] = False\n        return build_config\n\n    def text_response(self) -> Message:\n        return Message(\n            text=self.input_value,\n        )\n"
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "ai_enabled": false,
                "copy_field": false,
                "display_name": "Text",
                "dynamic": false,
                "info": "Text to be passed as input.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "override_skip": false,
                "password": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "Langflow IBM"
              },
              "use_global_variable": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Use Global Variable",
                "dynamic": false,
                "info": "Enable to select from global variables (shows globe icon). Disables multiline editing.",
                "list": false,
                "list_add_label": "Add More",
                "name": "use_global_variable",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": false
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "TextInput"
        },
        "dragging": false,
        "id": "TextInput-gl8uw",
        "measured": {
          "height": 204,
          "width": 320
        },
        "position": {
          "x": -1970.2426221053743,
          "y": 936.9548727054053
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "TextInput-yH61g",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Get user text inputs.",
            "display_name": "Days",
            "documentation": "https://docs.langflow.org/text-input-and-output",
            "edited": false,
            "field_order": [
              "input_value",
              "use_global_variable"
            ],
            "frozen": false,
            "icon": "type",
            "legacy": false,
            "lf_version": "1.8.0",
            "metadata": {
              "code_hash": "518f16485886",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "lfx",
                    "version": null
                  }
                ],
                "total_dependencies": 1
              },
              "module": "custom_components.text_input"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Output Text",
                "group_outputs": false,
                "loop_types": null,
                "method": "text_response",
                "name": "text",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nfrom lfx.base.io.text import TextComponent\nfrom lfx.io import BoolInput, MultilineInput, Output\nfrom lfx.schema.message import Message\n\n\nclass TextInputComponent(TextComponent):\n    display_name = \"Text Input\"\n    description = \"Get user text inputs.\"\n    documentation: str = \"https://docs.langflow.org/text-input-and-output\"\n    icon = \"type\"\n    name = \"TextInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as input.\",\n        ),\n        BoolInput(\n            name=\"use_global_variable\",\n            display_name=\"Use Global Variable\",\n            info=\"Enable to select from global variables (shows globe icon). Disables multiline editing.\",\n            value=False,\n            advanced=True,\n            real_time_refresh=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Output Text\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def update_build_config(self, build_config: dict, field_value: Any, field_name: str | None = None) -> dict:\n        if field_name == \"use_global_variable\":\n            if field_value:\n                # Enable global variable mode: single-line with password masking and globe dropdown\n                build_config[\"input_value\"][\"multiline\"] = False\n                build_config[\"input_value\"][\"password\"] = True\n            else:\n                # Default mode: multiline text editing\n                build_config[\"input_value\"][\"multiline\"] = True\n                build_config[\"input_value\"][\"password\"] = False\n        return build_config\n\n    def text_response(self) -> Message:\n        return Message(\n            text=self.input_value,\n        )\n"
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "ai_enabled": false,
                "copy_field": false,
                "display_name": "Text",
                "dynamic": false,
                "info": "Text to be passed as input.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "override_skip": false,
                "password": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "90"
              },
              "use_global_variable": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Use Global Variable",
                "dynamic": false,
                "info": "Enable to select from global variables (shows globe icon). Disables multiline editing.",
                "list": false,
                "list_add_label": "Add More",
                "name": "use_global_variable",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": false
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "TextInput"
        },
        "dragging": false,
        "id": "TextInput-yH61g",
        "measured": {
          "height": 204,
          "width": 320
        },
        "position": {
          "x": -1984.9139301438142,
          "y": 1217.3504739015061
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Prompt Template-59kLB",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {
              "template": [
                "product-brand-topic",
                "days",
                "youtube_agent_response",
                "reddit_agent_response"
              ]
            },
            "description": "Create a prompt template with dynamic variables.",
            "display_name": "Prompt Template",
            "documentation": "https://docs.langflow.org/components-prompts",
            "edited": false,
            "error": null,
            "field_order": [
              "template",
              "use_double_brackets",
              "tool_placeholder"
            ],
            "frozen": false,
            "full_path": null,
            "icon": "prompts",
            "is_composition": null,
            "is_input": null,
            "is_output": null,
            "legacy": false,
            "lf_version": "1.8.0",
            "metadata": {
              "code_hash": "595f7c9c8463",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "lfx",
                    "version": null
                  }
                ],
                "total_dependencies": 1
              },
              "module": "lfx.components.models_and_agents.prompt.PromptComponent"
            },
            "minimized": false,
            "name": "",
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt",
                "group_outputs": false,
                "hidden": null,
                "loop_types": null,
                "method": "build_prompt",
                "name": "prompt",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": 0,
            "replacement": null,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nfrom lfx.base.prompts.api_utils import process_prompt_template\nfrom lfx.custom.custom_component.component import Component\nfrom lfx.inputs.input_mixin import FieldTypes\nfrom lfx.inputs.inputs import DefaultPromptField\nfrom lfx.io import BoolInput, MessageTextInput, Output, PromptInput\nfrom lfx.log.logger import logger\nfrom lfx.schema.dotdict import dotdict\nfrom lfx.schema.message import Message\nfrom lfx.template.utils import update_template_values\nfrom lfx.utils.mustache_security import validate_mustache_template\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt Template\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    documentation: str = \"https://docs.langflow.org/components-prompts\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt Template\"\n    priority = 0  # Set priority to 0 to make it appear first\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        BoolInput(\n            name=\"use_double_brackets\",\n            display_name=\"Use Double Brackets\",\n            value=False,\n            advanced=True,\n            info=\"Use {{variable}} syntax instead of {variable}.\",\n            real_time_refresh=True,\n        ),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None) -> dotdict:\n        \"\"\"Update the template field type based on the selected mode.\"\"\"\n        if field_name == \"use_double_brackets\":\n            # Change the template field type based on mode\n            is_mustache = field_value is True\n            if is_mustache:\n                build_config[\"template\"][\"type\"] = FieldTypes.MUSTACHE_PROMPT.value\n            else:\n                build_config[\"template\"][\"type\"] = FieldTypes.PROMPT.value\n\n            # Re-process the template to update variables when mode changes\n            template_value = build_config.get(\"template\", {}).get(\"value\", \"\")\n            if template_value:\n                # Ensure custom_fields is properly initialized\n                if \"custom_fields\" not in build_config:\n                    build_config[\"custom_fields\"] = {}\n\n                # Clean up fields from the OLD mode before processing with NEW mode\n                # This ensures we don't keep fields with wrong syntax even if validation fails\n                old_custom_fields = build_config[\"custom_fields\"].get(\"template\", [])\n                for old_field in list(old_custom_fields):\n                    # Remove the field from custom_fields and template\n                    if old_field in old_custom_fields:\n                        old_custom_fields.remove(old_field)\n                    build_config.pop(old_field, None)\n\n                # Try to process template with new mode to add new variables\n                # If validation fails, at least we cleaned up old fields\n                try:\n                    # Validate mustache templates for security\n                    if is_mustache:\n                        validate_mustache_template(template_value)\n\n                    # Re-process template with new mode to add new variables\n                    _ = process_prompt_template(\n                        template=template_value,\n                        name=\"template\",\n                        custom_fields=build_config[\"custom_fields\"],\n                        frontend_node_template=build_config,\n                        is_mustache=is_mustache,\n                    )\n                except ValueError as e:\n                    # If validation fails, we still updated the mode and cleaned old fields\n                    # User will see error when they try to save\n                    logger.debug(f\"Template validation failed during mode switch: {e}\")\n        return build_config\n\n    async def build_prompt(self) -> Message:\n        use_double_brackets = self.use_double_brackets if hasattr(self, \"use_double_brackets\") else False\n        template_format = \"mustache\" if use_double_brackets else \"f-string\"\n        prompt = await Message.from_template_and_variables(template_format=template_format, **self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        use_double_brackets = frontend_node[\"template\"].get(\"use_double_brackets\", {}).get(\"value\", False)\n        is_mustache = use_double_brackets is True\n\n        try:\n            # Validate mustache templates for security\n            if is_mustache:\n                validate_mustache_template(prompt_template)\n\n            custom_fields = frontend_node[\"custom_fields\"]\n            frontend_node_template = frontend_node[\"template\"]\n            _ = process_prompt_template(\n                template=prompt_template,\n                name=\"template\",\n                custom_fields=custom_fields,\n                frontend_node_template=frontend_node_template,\n                is_mustache=is_mustache,\n            )\n        except ValueError as e:\n            # If validation fails, don't add variables but allow component to be created\n            logger.debug(f\"Template validation failed in _update_template: {e}\")\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        use_double_brackets = frontend_node[\"template\"].get(\"use_double_brackets\", {}).get(\"value\", False)\n        is_mustache = use_double_brackets is True\n\n        try:\n            # Validate mustache templates for security\n            if is_mustache:\n                validate_mustache_template(template)\n\n            # Kept it duplicated for backwards compatibility\n            _ = process_prompt_template(\n                template=template,\n                name=\"template\",\n                custom_fields=frontend_node[\"custom_fields\"],\n                frontend_node_template=frontend_node[\"template\"],\n                is_mustache=is_mustache,\n            )\n        except ValueError as e:\n            # If validation fails, don't add variables but allow component to be updated\n            logger.debug(f\"Template validation failed in update_frontend_node: {e}\")\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n"
              },
              "days": {
                "advanced": false,
                "display_name": "days",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "days",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "product-brand-topic": {
                "advanced": false,
                "display_name": "product-brand-topic",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "product-brand-topic",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "reddit_agent_response": {
                "advanced": false,
                "display_name": "reddit_agent_response",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "reddit_agent_response",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "template": {
                "_input_type": "PromptInput",
                "advanced": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "template",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "track_in_telemetry": false,
                "type": "prompt",
                "value": "You are a Voice of Customer analyst.\n\nCONTEXT AND INPUT DATA:\n\nYou will receive raw data automatically collected from two platforms about the topic \"{product-brand-topic}\":\n\n**YOUTUBE:**\n- Contains: comments left by users on videos related to the topic\n- Period: comments from the last {days} days\n- Format: each comment includes full text, author, date, likes, source video, and link\n- Quantity: up to 100 comments collected from the most recent videos\n- Nature: spontaneous feedback from viewers about the topic\n\n{youtube_agent_response}\n\n**REDDIT:**\n- Contains: posts and comments from discussions in relevant subreddits\n- Period: posts and comments from the last {days} days\n- Format: each item includes full text, author, date, score (upvotes), subreddit, and link\n- Quantity: up to 100 items (posts + comments) collected\n- Nature: technical discussions, opinions, and experiences shared by the community\n\n{reddit_agent_response}\n\nIMPORTANT: These are REAL feedbacks from end users collected from the platforms. Analyze them as primary qualitative research data to understand public perception about \"{product-brand-topic}\".\n\n---\n\nTASK:\n1. Analyze ALL received feedbacks\n2. Extract insights, sentiments, and patterns\n3. Create structured consolidated report\n\n---\n\nREPORT STRUCTURE (use Markdown):\n\n# Voice of Customer Report: {product-brand-topic}\n**Collection Period:** Last {days} days | **Report Date:** [today]\n**Sources:** YouTube, Reddit\n\n## 1. EXECUTIVE SUMMARY\n[4-5 lines summarizing:]\n- How many feedbacks were analyzed (total YouTube + Reddit)\n- What is the predominant sentiment (positive/neutral/negative)\n- What is the main insight or discovery\n- What is the most urgent action recommendation\n\n## 2. ANALYSIS BY PLATFORM\n\n### YouTube\n- **Comments analyzed:** [X] from [Y] videos\n- **Main themes:** [list 3-5 most mentioned topics]\n- **Sentiment:** [X% positive, Y% neutral, Z% negative]\n- **Key insight:** [1-2 sentences about what stands out]\n\n### Reddit  \n- **Items analyzed:** [X posts + Y comments]\n- **Subreddits:** [list the main ones]\n- **Main themes:** [list 3-5 most mentioned topics]\n- **Sentiment:** [X% positive, Y% neutral, Z% negative]\n- **Key insight:** [1-2 sentences about what stands out]\n\n## 3. CONSOLIDATED OVERALL SENTIMENT\n😊 Positive: [X%] | 😐 Neutral: [X%] | 😞 Negative: [X%]\n\n**Analysis:**\n[2-3 sentences explaining what this distribution means about public perception]\n\n## 4. TOP 5 MOST MENTIONED THEMES\n[For each theme include:]\n- **Theme name:** [e.g., \"Ease of use\", \"Performance\", \"Bugs\"]\n- **Frequency:** [how many times it appeared in feedbacks]\n- **Predominant sentiment:** [positive/neutral/negative]\n- **Real example:** \"[quote from 1 feedback]\" - @[author] ([YouTube/Reddit])\n\n## 5. HIGHLIGHTS - MOST RELEVANT FEEDBACKS\n\n### 🌟 Top 3 Positive Feedbacks\n[For each one:]\n- **Comment:** \"[full or summarized quote]\"\n- **Author:** @[username]\n- **Platform:** [YouTube video X / Reddit r/subreddit]\n- **Link:** [full url]\n- **Date:** [YYYY-MM-DD]\n\n### ⚠️ Top 3 Critical Feedbacks\n[For each one:]\n- **Comment:** \"[quote]\"\n- **Author:** @[username]\n- **Platform:** [YouTube/Reddit]\n- **Link:** [url]\n- **Date:** [YYYY-MM-DD]\n- **Problem:** [explain in 1 sentence the identified problem]\n\n## 6. INSIGHTS AND IDENTIFIED PATTERNS\n[Write 4-6 paragraphs analyzing:]\n- What patterns repeat between YouTube and Reddit?\n- What notable differences exist between platforms?\n- What emerging trends or changes appear?\n- What issues remain unresolved or are recurring?\n- What opportunities can be explored?\n\n## 7. ACTION RECOMMENDATIONS\n\n**Short Term (0-30 days):**\n1. [Specific action based on urgent critical feedbacks]\n2. [Specific action]\n3. [Specific action]\n\n**Medium Term (30-90 days):**\n1. [Action based on identified patterns]\n2. [Specific action]\n3. [Specific action]\n\n**Long Term (90+ days):**\n1. [Strategic action]\n2. [Strategic action]\n\n## 8. KEY METRICS\n\n| Metric | YouTube | Reddit | Total |\n|---------|---------|--------|-------|\n| Feedbacks collected | [X] | [X] | [X] |\n| Positive sentiment | [X%] | [X%] | [X%] |\n| Negative sentiment | [X%] | [X%] | [X%] |\n| Average engagement | [likes] | [score] | - |\n\n## CONCLUSION\n[3 final paragraphs:]\n1. Summary: What is the overall perception about {product-brand-topic}?\n2. Positives: What is working well according to users?\n3. Attention: What needs urgent attention? What are the next steps?\n\n---\n**Methodology:** Automated qualitative analysis of public feedbacks\n**Period:** {days} days | **Platforms:** YouTube, Reddit | **Total N:** [X] feedbacks\n\n---\n\nCRITICAL RULES:\n\n✓ REAL DATA: Use ONLY information present in the inputs - do not invent quotes, numbers, or authors\n✓ SENTIMENT: Read each feedback individually, classify the sentiment, then calculate aggregated percentages\n✓ QUOTES: Always in quotes with correct attribution (author + platform + link)\n✓ COMPLETENESS: Fill ALL sections (if insufficient data: write \"Insufficient data for this analysis\")\n✓ AUTOMATION: DO NOT ask anything - execute the entire flow automatically\n✓ MARKDOWN: Use Markdown formatting for maximum compatibility"
              },
              "tool_placeholder": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Tool Placeholder",
                "dynamic": false,
                "info": "A placeholder input for tool mode.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_placeholder",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "use_double_brackets": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Use Double Brackets",
                "dynamic": false,
                "info": "Use {{variable}} syntax instead of {variable}.",
                "list": false,
                "list_add_label": "Add More",
                "name": "use_double_brackets",
                "override_skip": false,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": false
              },
              "youtube_agent_response": {
                "advanced": false,
                "display_name": "youtube_agent_response",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "youtube_agent_response",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Prompt Template"
        },
        "dragging": false,
        "id": "Prompt Template-59kLB",
        "measured": {
          "height": 614,
          "width": 320
        },
        "position": {
          "x": 22.128638958334747,
          "y": 944.4335153900704
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Agent-mPPC2",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Define the agent's instructions, then enter a task to complete using tools.",
            "display_name": "Agent",
            "documentation": "https://docs.langflow.org/agents",
            "edited": false,
            "field_order": [
              "model",
              "api_key",
              "system_prompt",
              "context_id",
              "n_messages",
              "format_instructions",
              "output_schema",
              "tools",
              "input_value",
              "handle_parsing_errors",
              "verbose",
              "max_iterations",
              "agent_description",
              "add_current_date_tool"
            ],
            "frozen": false,
            "icon": "bot",
            "last_updated": "2026-01-29T00:38:29.428Z",
            "legacy": false,
            "lf_version": "1.8.0",
            "metadata": {
              "code_hash": "b60d28d2784f",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "pydantic",
                    "version": "2.11.10"
                  },
                  {
                    "name": "lfx",
                    "version": null
                  },
                  {
                    "name": "langchain_core",
                    "version": "0.3.83"
                  }
                ],
                "total_dependencies": 3
              },
              "module": "custom_components.agent"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Response",
                "group_outputs": false,
                "hidden": null,
                "loop_types": null,
                "method": "message_response",
                "name": "response",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_frontend_node_flow_id": {
                "input_types": [],
                "value": "3fd2a061-6f21-4b25-8a3c-0bbb1e47fc6c"
              },
              "_frontend_node_folder_id": {
                "input_types": [],
                "value": "a265ce36-7e1f-43cb-9964-16a87b09def2"
              },
              "_type": "Component",
              "add_current_date_tool": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Current Date",
                "dynamic": false,
                "info": "If true, will add a tool to the agent that returns the current date.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "add_current_date_tool",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": true
              },
              "agent_description": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "ai_enabled": false,
                "copy_field": false,
                "display_name": "Agent Description [Deprecated]",
                "dynamic": false,
                "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "agent_description",
                "override_skip": false,
                "password": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "A helpful assistant with access to the following tools:"
              },
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": true,
                "display_name": "API Key",
                "dynamic": false,
                "info": "Model Provider API key",
                "input_types": [],
                "load_from_db": true,
                "name": "api_key",
                "override_skip": false,
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from __future__ import annotations\n\nimport json\nimport re\nfrom typing import TYPE_CHECKING\n\nfrom pydantic import ValidationError\n\nfrom lfx.components.models_and_agents.memory import MemoryComponent\n\nif TYPE_CHECKING:\n    from langchain_core.tools import Tool\n\nfrom lfx.base.agents.agent import LCToolsAgentComponent\nfrom lfx.base.agents.events import ExceptionWithMessageError\nfrom lfx.base.models.unified_models import (\n    get_language_model_options,\n    get_llm,\n    update_model_options_in_build_config,\n)\nfrom lfx.components.helpers import CurrentDateComponent\nfrom lfx.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\nfrom lfx.custom.custom_component.component import get_component_toolkit\nfrom lfx.helpers.base_model import build_model_from_schema\nfrom lfx.inputs.inputs import BoolInput, ModelInput\nfrom lfx.io import IntInput, MessageTextInput, MultilineInput, Output, SecretStrInput, TableInput\nfrom lfx.log.logger import logger\nfrom lfx.schema.data import Data\nfrom lfx.schema.dotdict import dotdict\nfrom lfx.schema.message import Message\nfrom lfx.schema.table import EditMode\n\n\ndef set_advanced_true(component_input):\n    component_input.advanced = True\n    return component_input\n\n\nclass AgentComponent(ToolCallingAgentComponent):\n    display_name: str = \"Agent\"\n    description: str = \"Define the agent's instructions, then enter a task to complete using tools.\"\n    documentation: str = \"https://docs.langflow.org/agents\"\n    icon = \"bot\"\n    beta = False\n    name = \"Agent\"\n\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\n\n    inputs = [\n        ModelInput(\n            name=\"model\",\n            display_name=\"Language Model\",\n            info=\"Select your model provider\",\n            real_time_refresh=True,\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"API Key\",\n            info=\"Model Provider API key\",\n            real_time_refresh=True,\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"system_prompt\",\n            display_name=\"Agent Instructions\",\n            info=\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\",\n            value=\"You are a helpful assistant that can use tools to answer questions and perform tasks.\",\n            advanced=False,\n        ),\n        MessageTextInput(\n            name=\"context_id\",\n            display_name=\"Context ID\",\n            info=\"The context ID of the chat. Adds an extra layer to the local memory.\",\n            value=\"\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"n_messages\",\n            display_name=\"Number of Chat History Messages\",\n            value=100,\n            info=\"Number of chat history messages to retrieve.\",\n            advanced=True,\n            show=True,\n        ),\n        MultilineInput(\n            name=\"format_instructions\",\n            display_name=\"Output Format Instructions\",\n            info=\"Generic Template for structured output formatting. Valid only with Structured response.\",\n            value=(\n                \"You are an AI that extracts structured JSON objects from unstructured text. \"\n                \"Use a predefined schema with expected types (str, int, float, bool, dict). \"\n                \"Extract ALL relevant instances that match the schema - if multiple patterns exist, capture them all. \"\n                \"Fill missing or ambiguous values with defaults: null for missing values. \"\n                \"Remove exact duplicates but keep variations that have different field values. \"\n                \"Always return valid JSON in the expected format, never throw errors. \"\n                \"If multiple objects can be extracted, return them all in the structured format.\"\n            ),\n            advanced=True,\n        ),\n        TableInput(\n            name=\"output_schema\",\n            display_name=\"Output Schema\",\n            info=(\n                \"Schema Validation: Define the structure and data types for structured output. \"\n                \"No validation if no output schema.\"\n            ),\n            advanced=True,\n            required=False,\n            value=[],\n            table_schema=[\n                {\n                    \"name\": \"name\",\n                    \"display_name\": \"Name\",\n                    \"type\": \"str\",\n                    \"description\": \"Specify the name of the output field.\",\n                    \"default\": \"field\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n                {\n                    \"name\": \"description\",\n                    \"display_name\": \"Description\",\n                    \"type\": \"str\",\n                    \"description\": \"Describe the purpose of the output field.\",\n                    \"default\": \"description of field\",\n                    \"edit_mode\": EditMode.POPOVER,\n                },\n                {\n                    \"name\": \"type\",\n                    \"display_name\": \"Type\",\n                    \"type\": \"str\",\n                    \"edit_mode\": EditMode.INLINE,\n                    \"description\": (\"Indicate the data type of the output field (e.g., str, int, float, bool, dict).\"),\n                    \"options\": [\"str\", \"int\", \"float\", \"bool\", \"dict\"],\n                    \"default\": \"str\",\n                },\n                {\n                    \"name\": \"multiple\",\n                    \"display_name\": \"As List\",\n                    \"type\": \"boolean\",\n                    \"description\": \"Set to True if this output field should be a list of the specified type.\",\n                    \"default\": \"False\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n            ],\n        ),\n        *LCToolsAgentComponent.get_base_inputs(),\n        # removed memory inputs from agent component\n        # *memory_inputs,\n        BoolInput(\n            name=\"add_current_date_tool\",\n            display_name=\"Current Date\",\n            advanced=True,\n            info=\"If true, will add a tool to the agent that returns the current date.\",\n            value=True,\n        ),\n    ]\n    outputs = [\n        Output(name=\"response\", display_name=\"Response\", method=\"message_response\"),\n    ]\n\n    async def get_agent_requirements(self):\n        \"\"\"Get the agent requirements for the agent.\"\"\"\n        from langchain_core.tools import StructuredTool\n\n        llm_model = get_llm(\n            model=self.model,\n            user_id=self.user_id,\n            api_key=self.api_key,\n        )\n        if llm_model is None:\n            msg = \"No language model selected. Please choose a model to proceed.\"\n            raise ValueError(msg)\n\n        # Get memory data\n        self.chat_history = await self.get_memory_data()\n        await logger.adebug(f\"Retrieved {len(self.chat_history)} chat history messages\")\n        if isinstance(self.chat_history, Message):\n            self.chat_history = [self.chat_history]\n\n        # Add current date tool if enabled\n        if self.add_current_date_tool:\n            if not isinstance(self.tools, list):  # type: ignore[has-type]\n                self.tools = []\n            current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\n\n            if not isinstance(current_date_tool, StructuredTool):\n                msg = \"CurrentDateComponent must be converted to a StructuredTool\"\n                raise TypeError(msg)\n            self.tools.append(current_date_tool)\n\n        # Set shared callbacks for tracing the tools used by the agent\n        self.set_tools_callbacks(self.tools, self._get_shared_callbacks())\n\n        return llm_model, self.chat_history, self.tools\n\n    async def message_response(self) -> Message:\n        try:\n            llm_model, self.chat_history, self.tools = await self.get_agent_requirements()\n            # Set up and run agent\n            self.set(\n                llm=llm_model,\n                tools=self.tools or [],\n                chat_history=self.chat_history,\n                input_value=self.input_value,\n                system_prompt=self.system_prompt,\n            )\n            agent = self.create_agent_runnable()\n            result = await self.run_agent(agent)\n\n            # Store result for potential JSON output\n            self._agent_result = result\n\n        except (ValueError, TypeError, KeyError) as e:\n            await logger.aerror(f\"{type(e).__name__}: {e!s}\")\n            raise\n        except ExceptionWithMessageError as e:\n            await logger.aerror(f\"ExceptionWithMessageError occurred: {e}\")\n            raise\n        # Avoid catching blind Exception; let truly unexpected exceptions propagate\n        except Exception as e:\n            await logger.aerror(f\"Unexpected error: {e!s}\")\n            raise\n        else:\n            return result\n\n    def _preprocess_schema(self, schema):\n        \"\"\"Preprocess schema to ensure correct data types for build_model_from_schema.\"\"\"\n        processed_schema = []\n        for field in schema:\n            processed_field = {\n                \"name\": str(field.get(\"name\", \"field\")),\n                \"type\": str(field.get(\"type\", \"str\")),\n                \"description\": str(field.get(\"description\", \"\")),\n                \"multiple\": field.get(\"multiple\", False),\n            }\n            # Ensure multiple is handled correctly\n            if isinstance(processed_field[\"multiple\"], str):\n                processed_field[\"multiple\"] = processed_field[\"multiple\"].lower() in [\n                    \"true\",\n                    \"1\",\n                    \"t\",\n                    \"y\",\n                    \"yes\",\n                ]\n            processed_schema.append(processed_field)\n        return processed_schema\n\n    async def build_structured_output_base(self, content: str):\n        \"\"\"Build structured output with optional BaseModel validation.\"\"\"\n        json_pattern = r\"\\{.*\\}\"\n        schema_error_msg = \"Try setting an output schema\"\n\n        # Try to parse content as JSON first\n        json_data = None\n        try:\n            json_data = json.loads(content)\n        except json.JSONDecodeError:\n            json_match = re.search(json_pattern, content, re.DOTALL)\n            if json_match:\n                try:\n                    json_data = json.loads(json_match.group())\n                except json.JSONDecodeError:\n                    return {\"content\": content, \"error\": schema_error_msg}\n            else:\n                return {\"content\": content, \"error\": schema_error_msg}\n\n        # If no output schema provided, return parsed JSON without validation\n        if not hasattr(self, \"output_schema\") or not self.output_schema or len(self.output_schema) == 0:\n            return json_data\n\n        # Use BaseModel validation with schema\n        try:\n            processed_schema = self._preprocess_schema(self.output_schema)\n            output_model = build_model_from_schema(processed_schema)\n\n            # Validate against the schema\n            if isinstance(json_data, list):\n                # Multiple objects\n                validated_objects = []\n                for item in json_data:\n                    try:\n                        validated_obj = output_model.model_validate(item)\n                        validated_objects.append(validated_obj.model_dump())\n                    except ValidationError as e:\n                        await logger.aerror(f\"Validation error for item: {e}\")\n                        # Include invalid items with error info\n                        validated_objects.append({\"data\": item, \"validation_error\": str(e)})\n                return validated_objects\n\n            # Single object\n            try:\n                validated_obj = output_model.model_validate(json_data)\n                return [validated_obj.model_dump()]  # Return as list for consistency\n            except ValidationError as e:\n                await logger.aerror(f\"Validation error: {e}\")\n                return [{\"data\": json_data, \"validation_error\": str(e)}]\n\n        except (TypeError, ValueError) as e:\n            await logger.aerror(f\"Error building structured output: {e}\")\n            # Fallback to parsed JSON without validation\n            return json_data\n\n    async def json_response(self) -> Data:\n        \"\"\"Convert agent response to structured JSON Data output with schema validation.\"\"\"\n        # Always use structured chat agent for JSON response mode for better JSON formatting\n        try:\n            system_components = []\n\n            # 1. Agent Instructions (system_prompt)\n            agent_instructions = getattr(self, \"system_prompt\", \"\") or \"\"\n            if agent_instructions:\n                system_components.append(f\"{agent_instructions}\")\n\n            # 2. Format Instructions\n            format_instructions = getattr(self, \"format_instructions\", \"\") or \"\"\n            if format_instructions:\n                system_components.append(f\"Format instructions: {format_instructions}\")\n\n            # 3. Schema Information from BaseModel\n            if hasattr(self, \"output_schema\") and self.output_schema and len(self.output_schema) > 0:\n                try:\n                    processed_schema = self._preprocess_schema(self.output_schema)\n                    output_model = build_model_from_schema(processed_schema)\n                    schema_dict = output_model.model_json_schema()\n                    schema_info = (\n                        \"You are given some text that may include format instructions, \"\n                        \"explanations, or other content alongside a JSON schema.\\n\\n\"\n                        \"Your task:\\n\"\n                        \"- Extract only the JSON schema.\\n\"\n                        \"- Return it as valid JSON.\\n\"\n                        \"- Do not include format instructions, explanations, or extra text.\\n\\n\"\n                        \"Input:\\n\"\n                        f\"{json.dumps(schema_dict, indent=2)}\\n\\n\"\n                        \"Output (only JSON schema):\"\n                    )\n                    system_components.append(schema_info)\n                except (ValidationError, ValueError, TypeError, KeyError) as e:\n                    await logger.aerror(f\"Could not build schema for prompt: {e}\", exc_info=True)\n\n            # Combine all components\n            combined_instructions = \"\\n\\n\".join(system_components) if system_components else \"\"\n            llm_model, self.chat_history, self.tools = await self.get_agent_requirements()\n            self.set(\n                llm=llm_model,\n                tools=self.tools or [],\n                chat_history=self.chat_history,\n                input_value=self.input_value,\n                system_prompt=combined_instructions,\n            )\n\n            # Create and run structured chat agent\n            try:\n                structured_agent = self.create_agent_runnable()\n            except (NotImplementedError, ValueError, TypeError) as e:\n                await logger.aerror(f\"Error with structured chat agent: {e}\")\n                raise\n            try:\n                result = await self.run_agent(structured_agent)\n            except (\n                ExceptionWithMessageError,\n                ValueError,\n                TypeError,\n                RuntimeError,\n            ) as e:\n                await logger.aerror(f\"Error with structured agent result: {e}\")\n                raise\n            # Extract content from structured agent result\n            if hasattr(result, \"content\"):\n                content = result.content\n            elif hasattr(result, \"text\"):\n                content = result.text\n            else:\n                content = str(result)\n\n        except (\n            ExceptionWithMessageError,\n            ValueError,\n            TypeError,\n            NotImplementedError,\n            AttributeError,\n        ) as e:\n            await logger.aerror(f\"Error with structured chat agent: {e}\")\n            # Fallback to regular agent\n            content_str = \"No content returned from agent\"\n            return Data(data={\"content\": content_str, \"error\": str(e)})\n\n        # Process with structured output validation\n        try:\n            structured_output = await self.build_structured_output_base(content)\n\n            # Handle different output formats\n            if isinstance(structured_output, list) and structured_output:\n                if len(structured_output) == 1:\n                    return Data(data=structured_output[0])\n                return Data(data={\"results\": structured_output})\n            if isinstance(structured_output, dict):\n                return Data(data=structured_output)\n            return Data(data={\"content\": content})\n\n        except (ValueError, TypeError) as e:\n            await logger.aerror(f\"Error in structured output processing: {e}\")\n            return Data(data={\"content\": content, \"error\": str(e)})\n\n    async def get_memory_data(self):\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\n        messages = (\n            await MemoryComponent(**self.get_base_args())\n            .set(\n                session_id=self.graph.session_id,\n                context_id=self.context_id,\n                order=\"Ascending\",\n                n_messages=self.n_messages,\n            )\n            .retrieve_messages()\n        )\n        return [\n            message for message in messages if getattr(message, \"id\", None) != getattr(self.input_value, \"id\", None)\n        ]\n\n    def update_input_types(self, build_config: dotdict) -> dotdict:\n        \"\"\"Update input types for all fields in build_config.\"\"\"\n        for key, value in build_config.items():\n            if isinstance(value, dict):\n                if value.get(\"input_types\") is None:\n                    build_config[key][\"input_types\"] = []\n            elif hasattr(value, \"input_types\") and value.input_types is None:\n                value.input_types = []\n        return build_config\n\n    async def update_build_config(\n        self,\n        build_config: dotdict,\n        field_value: list[dict],\n        field_name: str | None = None,\n    ) -> dotdict:\n        # Update model options with caching (for all field changes)\n        # Agents require tool calling, so filter for only tool-calling capable models\n        def get_tool_calling_model_options(user_id=None):\n            return get_language_model_options(user_id=user_id, tool_calling=True)\n\n        build_config = update_model_options_in_build_config(\n            component=self,\n            build_config=dict(build_config),\n            cache_key_prefix=\"language_model_options_tool_calling\",\n            get_options_func=get_tool_calling_model_options,\n            field_name=field_name,\n            field_value=field_value,\n        )\n        build_config = dotdict(build_config)\n\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\n        if field_name == \"model\":\n            # Update input types for all fields\n            build_config = self.update_input_types(build_config)\n\n            # Validate required keys\n            default_keys = [\n                \"code\",\n                \"_type\",\n                \"model\",\n                \"tools\",\n                \"input_value\",\n                \"add_current_date_tool\",\n                \"system_prompt\",\n                \"agent_description\",\n                \"max_iterations\",\n                \"handle_parsing_errors\",\n                \"verbose\",\n            ]\n            missing_keys = [key for key in default_keys if key not in build_config]\n            if missing_keys:\n                msg = f\"Missing required keys in build_config: {missing_keys}\"\n                raise ValueError(msg)\n        return dotdict({k: v.to_dict() if hasattr(v, \"to_dict\") else v for k, v in build_config.items()})\n\n    async def _get_tools(self) -> list[Tool]:\n        component_toolkit = get_component_toolkit()\n        tools_names = self._build_tools_names()\n        agent_description = self.get_tool_description()\n        # TODO: Agent Description Depreciated Feature to be removed\n        description = f\"{agent_description}{tools_names}\"\n\n        tools = component_toolkit(component=self).get_tools(\n            tool_name=\"Call_Agent\",\n            tool_description=description,\n            # here we do not use the shared callbacks as we are exposing the agent as a tool\n            callbacks=self.get_langchain_callbacks(),\n        )\n        if hasattr(self, \"tools_metadata\"):\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\n\n        return tools\n"
              },
              "context_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Context ID",
                "dynamic": false,
                "info": "The context ID of the chat. Adds an extra layer to the local memory.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "context_id",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "format_instructions": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "ai_enabled": false,
                "copy_field": false,
                "display_name": "Output Format Instructions",
                "dynamic": false,
                "info": "Generic Template for structured output formatting. Valid only with Structured response.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "format_instructions",
                "override_skip": false,
                "password": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "You are an AI that extracts structured JSON objects from unstructured text. Use a predefined schema with expected types (str, int, float, bool, dict). Extract ALL relevant instances that match the schema - if multiple patterns exist, capture them all. Fill missing or ambiguous values with defaults: null for missing values. Remove exact duplicates but keep variations that have different field values. Always return valid JSON in the expected format, never throw errors. If multiple objects can be extracted, return them all in the structured format."
              },
              "handle_parsing_errors": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Handle Parse Errors",
                "dynamic": false,
                "info": "Should the Agent fix errors when reading user input for better processing?",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "handle_parsing_errors",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": true
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "The input provided by the user for the agent to process.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "is_refresh": false,
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "int",
                "value": 15
              },
              "model": {
                "_input_type": "ModelInput",
                "advanced": false,
                "display_name": "Language Model",
                "dynamic": false,
                "external_options": {
                  "fields": {
                    "data": {
                      "node": {
                        "display_name": "Connect other models",
                        "icon": "CornerDownLeft",
                        "name": "connect_other_models"
                      }
                    }
                  }
                },
                "info": "Select your model provider",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "model_type": "language",
                "name": "model",
                "options": [
                  {
                    "category": "Anthropic",
                    "icon": "Anthropic",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatAnthropic",
                      "model_name_param": "model"
                    },
                    "name": "claude-opus-4-5-20251101",
                    "provider": "Anthropic"
                  },
                  {
                    "category": "Anthropic",
                    "icon": "Anthropic",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatAnthropic",
                      "model_name_param": "model"
                    },
                    "name": "claude-haiku-4-5-20251001",
                    "provider": "Anthropic"
                  },
                  {
                    "category": "Anthropic",
                    "icon": "Anthropic",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatAnthropic",
                      "model_name_param": "model"
                    },
                    "name": "claude-sonnet-4-5-20250929",
                    "provider": "Anthropic"
                  },
                  {
                    "category": "Anthropic",
                    "icon": "Anthropic",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatAnthropic",
                      "model_name_param": "model"
                    },
                    "name": "claude-opus-4-1-20250805",
                    "provider": "Anthropic"
                  },
                  {
                    "category": "Anthropic",
                    "icon": "Anthropic",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatAnthropic",
                      "model_name_param": "model"
                    },
                    "name": "claude-opus-4-20250514",
                    "provider": "Anthropic"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model",
                      "reasoning_models": [
                        "gpt-5.1"
                      ]
                    },
                    "name": "gpt-5.1",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model",
                      "reasoning_models": [
                        "gpt-5"
                      ]
                    },
                    "name": "gpt-5",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model",
                      "reasoning_models": [
                        "gpt-5-mini"
                      ]
                    },
                    "name": "gpt-5-mini",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model",
                      "reasoning_models": [
                        "gpt-5-nano"
                      ]
                    },
                    "name": "gpt-5-nano",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model"
                    },
                    "name": "gpt-4o-mini",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model"
                    },
                    "name": "gpt-4o",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model"
                    },
                    "name": "gpt-4-turbo",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model"
                    },
                    "name": "gpt-4",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model"
                    },
                    "name": "gpt-4o-mini-search-preview",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "OpenAI",
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model"
                    },
                    "name": "gpt-4o-search-preview",
                    "provider": "OpenAI"
                  },
                  {
                    "category": "Google Generative AI",
                    "icon": "GoogleGenerativeAI",
                    "metadata": {
                      "api_key_param": "google_api_key",
                      "context_length": 128000,
                      "model_class": "ChatGoogleGenerativeAIFixed",
                      "model_name_param": "model"
                    },
                    "name": "gemini-1.5-pro",
                    "provider": "Google Generative AI"
                  },
                  {
                    "category": "Google Generative AI",
                    "icon": "GoogleGenerativeAI",
                    "metadata": {
                      "api_key_param": "google_api_key",
                      "context_length": 128000,
                      "model_class": "ChatGoogleGenerativeAIFixed",
                      "model_name_param": "model"
                    },
                    "name": "gemini-1.5-flash",
                    "provider": "Google Generative AI"
                  },
                  {
                    "category": "Google Generative AI",
                    "icon": "GoogleGenerativeAI",
                    "metadata": {
                      "api_key_param": "google_api_key",
                      "context_length": 128000,
                      "model_class": "ChatGoogleGenerativeAIFixed",
                      "model_name_param": "model"
                    },
                    "name": "gemini-1.5-flash-8b",
                    "provider": "Google Generative AI"
                  },
                  {
                    "category": "Google Generative AI",
                    "icon": "GoogleGenerativeAI",
                    "metadata": {
                      "api_key_param": "google_api_key",
                      "context_length": 128000,
                      "model_class": "ChatGoogleGenerativeAIFixed",
                      "model_name_param": "model"
                    },
                    "name": "gemini-2.0-flash-lite",
                    "provider": "Google Generative AI"
                  },
                  {
                    "category": "Google Generative AI",
                    "icon": "GoogleGenerativeAI",
                    "metadata": {
                      "api_key_param": "google_api_key",
                      "context_length": 128000,
                      "model_class": "ChatGoogleGenerativeAIFixed",
                      "model_name_param": "model"
                    },
                    "name": "gemini-2.0-flash",
                    "provider": "Google Generative AI"
                  },
                  {
                    "category": "Ollama",
                    "icon": "Ollama",
                    "metadata": {
                      "api_key_param": "base_url",
                      "base_url_param": "base_url",
                      "context_length": 128000,
                      "model_class": "ChatOllama",
                      "model_name_param": "model"
                    },
                    "name": "llama3.3",
                    "provider": "Ollama"
                  },
                  {
                    "category": "Ollama",
                    "icon": "Ollama",
                    "metadata": {
                      "api_key_param": "base_url",
                      "base_url_param": "base_url",
                      "context_length": 128000,
                      "model_class": "ChatOllama",
                      "model_name_param": "model"
                    },
                    "name": "qwq",
                    "provider": "Ollama"
                  },
                  {
                    "category": "Ollama",
                    "icon": "Ollama",
                    "metadata": {
                      "api_key_param": "base_url",
                      "base_url_param": "base_url",
                      "context_length": 128000,
                      "model_class": "ChatOllama",
                      "model_name_param": "model"
                    },
                    "name": "llama3.2",
                    "provider": "Ollama"
                  },
                  {
                    "category": "Ollama",
                    "icon": "Ollama",
                    "metadata": {
                      "api_key_param": "base_url",
                      "base_url_param": "base_url",
                      "context_length": 128000,
                      "model_class": "ChatOllama",
                      "model_name_param": "model"
                    },
                    "name": "llama3.1",
                    "provider": "Ollama"
                  },
                  {
                    "category": "Ollama",
                    "icon": "Ollama",
                    "metadata": {
                      "api_key_param": "base_url",
                      "base_url_param": "base_url",
                      "context_length": 128000,
                      "model_class": "ChatOllama",
                      "model_name_param": "model"
                    },
                    "name": "mistral",
                    "provider": "Ollama"
                  },
                  {
                    "category": "IBM WatsonX",
                    "icon": "IBM",
                    "metadata": {
                      "api_key_param": "apikey",
                      "context_length": 128000,
                      "model_class": "ChatWatsonx",
                      "model_name_param": "model_id",
                      "project_id_param": "project_id",
                      "url_param": "url"
                    },
                    "name": "ibm/granite-3-2b-instruct",
                    "provider": "IBM WatsonX"
                  },
                  {
                    "category": "IBM WatsonX",
                    "icon": "IBM",
                    "metadata": {
                      "api_key_param": "apikey",
                      "context_length": 128000,
                      "model_class": "ChatWatsonx",
                      "model_name_param": "model_id",
                      "project_id_param": "project_id",
                      "url_param": "url"
                    },
                    "name": "ibm/granite-3-8b-instruct",
                    "provider": "IBM WatsonX"
                  },
                  {
                    "category": "IBM WatsonX",
                    "icon": "IBM",
                    "metadata": {
                      "api_key_param": "apikey",
                      "context_length": 128000,
                      "model_class": "ChatWatsonx",
                      "model_name_param": "model_id",
                      "project_id_param": "project_id",
                      "url_param": "url"
                    },
                    "name": "ibm/granite-13b-instruct-v2",
                    "provider": "IBM WatsonX"
                  }
                ],
                "override_skip": false,
                "placeholder": "Setup Provider",
                "real_time_refresh": true,
                "refresh_button": true,
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "track_in_telemetry": false,
                "type": "model",
                "value": [
                  {
                    "icon": "OpenAI",
                    "metadata": {
                      "api_key_param": "api_key",
                      "context_length": 128000,
                      "model_class": "ChatOpenAI",
                      "model_name_param": "model",
                      "reasoning_models": [
                        "gpt-5"
                      ]
                    },
                    "name": "gpt-5",
                    "provider": "OpenAI"
                  }
                ]
              },
              "n_messages": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Chat History Messages",
                "dynamic": false,
                "info": "Number of chat history messages to retrieve.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "n_messages",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "int",
                "value": 100
              },
              "output_schema": {
                "_input_type": "TableInput",
                "advanced": true,
                "display_name": "Output Schema",
                "dynamic": false,
                "info": "Schema Validation: Define the structure and data types for structured output. No validation if no output schema.",
                "input_types": [],
                "is_list": true,
                "list_add_label": "Add More",
                "name": "output_schema",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "table_icon": "Table",
                "table_schema": [
                  {
                    "default": "field",
                    "description": "Specify the name of the output field.",
                    "display_name": "Name",
                    "edit_mode": "inline",
                    "name": "name",
                    "type": "str"
                  },
                  {
                    "default": "description of field",
                    "description": "Describe the purpose of the output field.",
                    "display_name": "Description",
                    "edit_mode": "popover",
                    "name": "description",
                    "type": "str"
                  },
                  {
                    "default": "str",
                    "description": "Indicate the data type of the output field (e.g., str, int, float, bool, dict).",
                    "display_name": "Type",
                    "edit_mode": "inline",
                    "name": "type",
                    "options": [
                      "str",
                      "int",
                      "float",
                      "bool",
                      "dict"
                    ],
                    "type": "str"
                  },
                  {
                    "default": "False",
                    "description": "Set to True if this output field should be a list of the specified type.",
                    "display_name": "As List",
                    "edit_mode": "inline",
                    "name": "multiple",
                    "type": "boolean"
                  }
                ],
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "trigger_icon": "Table",
                "trigger_text": "Open table",
                "type": "table",
                "value": []
              },
              "system_prompt": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "ai_enabled": false,
                "copy_field": false,
                "display_name": "Agent Instructions",
                "dynamic": false,
                "info": "System Prompt: Initial instructions and context provided to guide the agent's behavior.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_prompt",
                "override_skip": false,
                "password": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "You are a helpful assistant that can use tools to answer questions and perform tasks."
              },
              "tools": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Tools",
                "dynamic": false,
                "info": "These are the tools that the agent can use to help with tasks.",
                "input_types": [
                  "Tool"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "tools",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "other",
                "value": ""
              },
              "verbose": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Verbose",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "verbose",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Agent"
        },
        "dragging": false,
        "id": "Agent-mPPC2",
        "measured": {
          "height": 429,
          "width": 320
        },
        "position": {
          "x": 599.8403143572066,
          "y": 1025.593403016897
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatOutput-4Nrbb",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "https://docs.langflow.org/chat-input-and-output",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "context_id",
              "data_template",
              "clean_data"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "lf_version": "1.8.0",
            "metadata": {
              "code_hash": "8c87e536cca4",
              "dependencies": {
                "dependencies": [
                  {
                    "name": "orjson",
                    "version": "3.10.15"
                  },
                  {
                    "name": "fastapi",
                    "version": "0.128.0"
                  },
                  {
                    "name": "lfx",
                    "version": null
                  }
                ],
                "total_dependencies": 3
              },
              "module": "lfx.components.input_output.chat_output.ChatOutput"
            },
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Output Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Basic Clean Data",
                "dynamic": false,
                "info": "Whether to clean data before converting to string.",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nimport orjson\nfrom fastapi.encoders import jsonable_encoder\n\nfrom lfx.base.io.chat import ChatComponent\nfrom lfx.helpers.data import safe_convert\nfrom lfx.inputs.inputs import BoolInput, DropdownInput, HandleInput, MessageTextInput\nfrom lfx.schema.data import Data\nfrom lfx.schema.dataframe import DataFrame\nfrom lfx.schema.message import Message\nfrom lfx.schema.properties import Source\nfrom lfx.template.field.base import Output\nfrom lfx.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    documentation: str = \"https://docs.langflow.org/chat-input-and-output\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Inputs\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"context_id\",\n            display_name=\"Context ID\",\n            info=\"The context ID of the chat. Adds an extra layer to the local memory.\",\n            value=\"\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Basic Clean Data\",\n            value=True,\n            advanced=True,\n            info=\"Whether to clean data before converting to string.\",\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Output Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n\n        # Get source properties\n        source, _, display_name, source_id = self.get_properties_from_source_component()\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message) and not self.is_connected_to_chat_input():\n            message = self.input_value\n            # Update message properties\n            message.text = text\n            # Preserve existing session_id from the incoming message if it exists\n            existing_session_id = message.session_id\n        else:\n            message = Message(text=text)\n            existing_session_id = None\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        # Preserve session_id from incoming message, or use component/graph session_id\n        message.session_id = (\n            self.session_id or existing_session_id or (self.graph.session_id if hasattr(self, \"graph\") else None) or \"\"\n        )\n        message.context_id = self.context_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n\n        # Store message if needed\n        if message.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _serialize_data(self, data: Data) -> str:\n        \"\"\"Serialize Data object to JSON string.\"\"\"\n        # Convert data.data to JSON-serializable format\n        serializable_data = jsonable_encoder(data.data)\n        # Serialize with orjson, enabling pretty printing with indentation\n        json_bytes = orjson.dumps(serializable_data, option=orjson.OPT_INDENT_2)\n        # Convert bytes to string and wrap in Markdown code blocks\n        return \"```json\\n\" + json_bytes.decode(\"utf-8\") + \"\\n```\"\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            clean_data: bool = getattr(self, \"clean_data\", False)\n            return \"\\n\".join([safe_convert(item, clean_data=clean_data) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return safe_convert(self.input_value)\n"
              },
              "context_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Context ID",
                "dynamic": false,
                "info": "The context ID of the chat. Adds an extra layer to the local memory.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "context_id",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Inputs",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "override_skip": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "external_options": {},
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "track_in_telemetry": false,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "override_skip": false,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "track_in_telemetry": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatOutput"
        },
        "dragging": false,
        "id": "ChatOutput-4Nrbb",
        "measured": {
          "height": 48,
          "width": 192
        },
        "position": {
          "x": 1063.9962346891507,
          "y": 1370.452874480228
        },
        "selected": false,
        "type": "genericNode"
      }
    ],
    "viewport": {
      "x": 643.9143775898768,
      "y": -104.98490636775625,
      "zoom": 0.3027525053473793
    }
  },
  "description": "Language Architect at Work!",
  "endpoint_name": null,
  "id": "3fd2a061-6f21-4b25-8a3c-0bbb1e47fc6c",
  "is_component": false,
  "last_tested_version": "1.8.0",
  "name": "Voice Of Customer Report Generator",
  "tags": []
}